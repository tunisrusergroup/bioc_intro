[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Data Analysis with R and Bioconductor",
    "section": "",
    "text": "Welcome to this Carpentries course designed to introduce you to the fundamentals of data analysis using R and Bioconductor. This course will guide you through working with data, manipulating it effectively, and visualizing it to gain insights in the context of bioinformatics."
  },
  {
    "objectID": "index.html#course-overview",
    "href": "index.html#course-overview",
    "title": "Introduction to Data Analysis with R and Bioconductor",
    "section": "Course Overview",
    "text": "Course Overview\nIn this course, we will cover:\n\nThe data structures in R and how to navigate them.\nTechniques for manipulating data using tools from the tidyverse, like dplyr and tibble.\nHow to create visualizations with ggplot2 to represent data in meaningful ways.\n\nThis course is tailored for those new to R and Bioconductor but assumes some familiarity with bioinformatics concepts."
  },
  {
    "objectID": "index.html#learning-goals",
    "href": "index.html#learning-goals",
    "title": "Introduction to Data Analysis with R and Bioconductor",
    "section": "Learning Goals",
    "text": "Learning Goals\nBy the end of this course, you will be able to:\n\nUnderstand and work with various data structures in R.\nPerform data manipulation tasks using dplyr and tidyverse tools.\nVisualize data using ggplot2 and understand how to interpret the results.\nLearn how to install and use Bioconductor packages to perform bioinformatics analyses."
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "Introduction to Data Analysis with R and Bioconductor",
    "section": "Prerequisites",
    "text": "Prerequisites\nThis course assumes that participants:\n\nHave basic knowledge of bioinformatics (though not required).\nHave some familiarity with programming concepts, preferably with R (though not required)."
  },
  {
    "objectID": "index.html#course-materials",
    "href": "index.html#course-materials",
    "title": "Introduction to Data Analysis with R and Bioconductor",
    "section": "Course Materials",
    "text": "Course Materials\n\nCourse Repository (GitHub) – Contains all the materials and code examples used in this course.\nDatasets for the course will be provided within the lessons.\nAdditional reading: R for Data Science and Bioconductor Documentation."
  },
  {
    "objectID": "index.html#course-outline",
    "href": "index.html#course-outline",
    "title": "Introduction to Data Analysis with R and Bioconductor",
    "section": "Course Outline",
    "text": "Course Outline\n\n\n\nDay\nTime\nSession\n\n\n\n\nDay 1\nMorning\nData organisation with spreadsheets, R and RStudio, Introduction to R\n\n\n\nAfternoon\nData Structure, Data Manipulation\n\n\nDay 2\nMorning\nData Manipulation, Data Visualization\n\n\n\nAfternoon\nData Visualization"
  },
  {
    "objectID": "index.html#contact",
    "href": "index.html#contact",
    "title": "Introduction to Data Analysis with R and Bioconductor",
    "section": "Contact",
    "text": "Contact\nIf you have any questions during the course, feel free to reach out to the course instructor."
  },
  {
    "objectID": "bioc_intro_dataStructure.html",
    "href": "bioc_intro_dataStructure.html",
    "title": "Introduction to data analysis with R and Bioconductor",
    "section": "",
    "text": "We are going to use part of the data published by Blackmore et al. (2017), The effect of upper-respiratory infection on transcriptomic changes in the CNS. The goal of the study was to determine the effect of an upper-respiratory infection on changes in RNA transcription occurring in the cerebellum and spinal cord post infection. Gender matched eight week old C57BL/6 mice were inoculated with saline or with Influenza A by intranasal route and transcriptomic changes in the cerebellum and spinal cord tissues were evaluated by RNA-seq at days 0 (non-infected), 4 and 8.\nThe dataset is stored as a comma-separated values (CSV) file. Each row holds information for a single RNA expression measurement, and the first eleven columns represent:\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\ngene\nThe name of the gene that was measured\n\n\nsample\nThe name of the sample the gene expression was measured in\n\n\nexpression\nThe value of the gene expression\n\n\norganism\nThe organism/species - here all data stem from mice\n\n\nage\nThe age of the mouse (all mice were 8 weeks here)\n\n\nsex\nThe sex of the mouse\n\n\ninfection\nThe infection state of the mouse, i.e. infected with Influenza A or not infected.\n\n\nstrain\nThe Influenza A strain.\n\n\ntime\nThe duration of the infection (in days).\n\n\ntissue\nThe tissue that was used for the gene expression experiment, i.e. cerebellum or spinal cord.\n\n\nmouse\nThe mouse unique identifier.\n\n\n\n\n# Load library here\nlibrary(here)\n\n\n# Define the full path for the destination file\ndest_path &lt;- here(\"data\", \"rnaseq.csv\")\n\n# Create the directory structure if it does not exist\nifelse(\n  !dir.exists(dirname(dest_path)),\n  {\n    dir.create(dirname(dest_path), recursive = TRUE, showWarnings = FALSE)\n    \"Directory Created\"\n  },\n  \"Directory Exists\"\n)\n\n# Download the file if it does not exist\nifelse(\n  !file.exists(dest_path),\n  {\n    download.file(\n      url = \"https://github.com/carpentries-incubator/bioc-intro/raw/main/episodes/data/rnaseq.csv\",\n      destfile = dest_path\n    )\n    \"File Downloaded\"\n  },\n  \"File Exists\"\n)\n\n\n# Load the CSV file\nrna &lt;- read.csv(dest_path)\n# Have a look at the CSV file\nrna\n\nLet’s check the top (the first 6 lines) of this data frame using the function head():\n\nhead(rna)\n\n\n\n\n\n\n\nNote\n\n\n\nread.csv() assumes that fields are delineated by commas. However, in several countries, the comma is used as a decimal separator, and the semicolon (;) is used as a field delineator. If you want to read in this type of file in R, you can use the read.csv2() function. It behaves exactly like read.csv() but uses different parameters for the decimal and the field separators. If you are working with another format, they can both be specified by the user. Check out the help for read.csv() by typing ?read.csv to learn more. There is also the read.delim() function for reading tab-separated data files. It is important to note that all of these functions are actually wrapper functions for the main read.table() function with different arguments. As such, the data above could also have been loaded by using read.table() with the separation argument as ,. The code is as follows:\n\n\n\nrna &lt;- read.table(file = \"data/rnaseq.csv\",sep = \",\",header = TRUE)\n\nThe header argument has to be set to TRUE to be able to read the headers as by default read.table() has the header argument set to FALSE.\n\n\n\nData frames are the de facto data structure for most tabular data, and what we use for statistics and plotting.\nA data frame can be created by hand, but most commonly they are generated by the functions read.csv() or read.table(); in other words, when importing spreadsheets from your hard drive (or the web).\nA data frame is the representation of data in the format of a table where the columns are vectors that all have the same length. Because columns are vectors, each column must contain a single type of data (e.g., characters, integers, factors). For example, here is a figure depicting a data frame comprising a numeric, a character, and a logical vector.\n\nWe can see this when inspecting the structure of a data frame with the function str():\n\nstr(rna)\n\n'data.frame':   32428 obs. of  19 variables:\n $ gene                                 : chr  \"Asl\" \"Apod\" \"Cyp2d22\" \"Klk6\" ...\n $ sample                               : chr  \"GSM2545336\" \"GSM2545336\" \"GSM2545336\" \"GSM2545336\" ...\n $ expression                           : int  1170 36194 4060 287 85 782 1619 288 43217 1071 ...\n $ organism                             : chr  \"Mus musculus\" \"Mus musculus\" \"Mus musculus\" \"Mus musculus\" ...\n $ age                                  : int  8 8 8 8 8 8 8 8 8 8 ...\n $ sex                                  : chr  \"Female\" \"Female\" \"Female\" \"Female\" ...\n $ infection                            : chr  \"InfluenzaA\" \"InfluenzaA\" \"InfluenzaA\" \"InfluenzaA\" ...\n $ strain                               : chr  \"C57BL/6\" \"C57BL/6\" \"C57BL/6\" \"C57BL/6\" ...\n $ time                                 : int  8 8 8 8 8 8 8 8 8 8 ...\n $ tissue                               : chr  \"Cerebellum\" \"Cerebellum\" \"Cerebellum\" \"Cerebellum\" ...\n $ mouse                                : int  14 14 14 14 14 14 14 14 14 14 ...\n $ ENTREZID                             : int  109900 11815 56448 19144 80891 20528 97827 118454 18823 14696 ...\n $ product                              : chr  \"argininosuccinate lyase, transcript variant X1\" \"apolipoprotein D, transcript variant 3\" \"cytochrome P450, family 2, subfamily d, polypeptide 22, transcript variant 2\" \"kallikrein related-peptidase 6, transcript variant 2\" ...\n $ ensembl_gene_id                      : chr  \"ENSMUSG00000025533\" \"ENSMUSG00000022548\" \"ENSMUSG00000061740\" \"ENSMUSG00000050063\" ...\n $ external_synonym                     : chr  \"2510006M18Rik\" NA \"2D22\" \"Bssp\" ...\n $ chromosome_name                      : chr  \"5\" \"16\" \"15\" \"7\" ...\n $ gene_biotype                         : chr  \"protein_coding\" \"protein_coding\" \"protein_coding\" \"protein_coding\" ...\n $ phenotype_description                : chr  \"abnormal circulating amino acid level\" \"abnormal lipid homeostasis\" \"abnormal skin morphology\" \"abnormal cytokine level\" ...\n $ hsapiens_homolog_associated_gene_name: chr  \"ASL\" \"APOD\" \"CYP2D6\" \"KLK6\" ...\n\n\n\n\nWe already saw how the functions head() and str() can be useful to check the content and the structure of a data frame. Here is a non-exhaustive list of functions to get a sense of the content/structure of the data. Let’s try them out!\nSize:\n\ndim(rna) - returns a vector with the number of rows as the first element, and the number of columns as the second element (the dimensions of the object).\nnrow(rna) - returns the number of rows.\nncol(rna) - returns the number of columns.\n\nContent:\n\nhead(rna) - shows the first 6 rows.\ntail(rna) - shows the last 6 rows.\n\nNames:\n\nnames(rna) - returns the column names (synonym of colnames() for data.frame objects).\nrownames(rna) - returns the row names.\n\nSummary:\n\nstr(rna) - structure of the object and information about the class, length and content of each column.\nsummary(rna) - summary statistics for each column.\n\n\n\n\n\n\n\nNote\n\n\n\nMost of these functions are “generic”, they can be used on other types of objects besides data.frame.\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nBased on the output of str(rna), can you answer the following questions?\n\nWhat is the class of the object rna?\nHow many rows and how many columns are in this object?\n\n\n\n\n\n\n\nOur rna data frame has rows and columns (it has 2 dimensions); if we want to extract some specific data from it, we need to specify the “coordinates” we want. Row numbers come first, followed by column numbers. However, note that different ways of specifying these coordinates lead to results with different classes.\n\n# first element in the first column of the data frame (as a vector)\nrna[1, 1]\n# first element in the 6th column (as a vector)\nrna[1, 6]\n# first column of the data frame (as a vector)\nrna[, 1]\n# first column of the data frame (as a data.frame)\nrna[1]\n# first three elements in the 7th column (as a vector)\nrna[1:3, 7]\n# the 3rd row of the data frame (as a data.frame)\nrna[3, ]\n# equivalent to head_rna &lt;- head(rna)\nhead_rna &lt;- rna[1:6, ]\nhead_rna\n\n: is a special function that creates numeric vectors of integers in increasing or decreasing order, test 1:10 and 10:1 for instance. See section @ref(sec:genvec) for details.\nYou can also exclude certain indices of a data frame using the “-” sign:\n\nrna[, -1]          ## The whole data frame, except the first column\nrna[-c(7:66465), ] ## Equivalent to head(rna)\n\nData frames can be subsetted by calling indices (as shown previously), but also by calling their column names directly:\n\nrna[\"gene\"]       # Result is a data.frame\nrna[, \"gene\"]     # Result is a vector\nrna[[\"gene\"]]     # Result is a vector\nrna$gene          # Result is a vector\n\nIn RStudio, you can use the autocompletion feature to get the full and correct names of the columns.\n\n\n\n\n\n\nChallenge\n\n\n\n\nCreate a data.frame (rna_200) containing only the data in row 200 of the rna dataset.\nNotice how nrow() gave you the number of rows in a data.frame?\n\n\nUse that number to pull out just that last row in the initial rna data frame.\nCompare that with what you see as the last row using tail() to make sure it’s meeting expectations.\nPull out that last row using nrow() instead of the row number.\nCreate a new data frame (rna_last) from that last row.\n\n\nUse nrow() to extract the row that is in the middle of the rna dataframe. Store the content of this row in an object named rna_middle.\nCombine nrow() with the - notation above to reproduce the behavior of head(rna), keeping just the first through 6th rows of the rna dataset.\n\n\n\n\n\n\n\nFactors represent categorical data. They are stored as integers associated with labels and they can be ordered or unordered. While factors look (and often behave) like character vectors, they are actually treated as integer vectors by R. So you need to be very careful when treating them as strings.\nOnce created, factors can only contain a pre-defined set of values, known as levels. By default, R always sorts levels in alphabetical order. For instance, if you have a factor with 2 levels:\n\nsex &lt;- factor(c(\"male\", \"female\", \"female\", \"male\", \"female\"))\n\nR will assign 1 to the level \"female\" and 2 to the level \"male\" (because f comes before m, even though the first element in this vector is \"male\"). You can see this by using the function levels() and you can find the number of levels using nlevels():\n\nlevels(sex)\n\n[1] \"female\" \"male\"  \n\n\n\nnlevels(sex)\n\n[1] 2\n\n\nSometimes, the order of the factors does not matter, other times you might want to specify the order because it is meaningful (e.g., “low”, “medium”, “high”), it improves your visualization, or it is required by a particular type of analysis. Here, one way to reorder our levels in the sex vector would be:\n\nsex ## current order\n\n[1] male   female female male   female\nLevels: female male\n\n\n\nsex &lt;- factor(sex, levels = c(\"male\", \"female\"))\nsex ## after re-ordering\n\n[1] male   female female male   female\nLevels: male female\n\n\nIn R’s memory, these factors are represented by integers (1, 2, 3), but are more informative than integers because factors are self describing: \"female\", \"male\" is more descriptive than 1, 2. Which one is “male”? You wouldn’t be able to tell just from the integer data. Factors, on the other hand, have this information built-in. It is particularly helpful when there are many levels (like the gene biotype in our example dataset).\nWhen your data is stored as a factor, you can use the plot() function to get a quick glance at the number of observations represented by each factor level. Let’s look at the number of males and females in our data.\n\nplot(sex)\n\n\n\n\n\n\n\n\n\n\nIf you need to convert a factor to a character vector, you use as.character(x).\n\nas.character(sex)\n\n[1] \"male\"   \"female\" \"female\" \"male\"   \"female\"\n\n\n\n\n\nIf we want to rename these factor, it is sufficient to change its levels:\n\nlevels(sex)\n\n[1] \"male\"   \"female\"\n\n\n\nlevels(sex) &lt;- c(\"M\", \"F\")\nsex\n\n[1] M F F M F\nLevels: M F\n\n\n\nplot(sex)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nRename “F” and “M” to “Female” and “Male” respectively.\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWe have seen how data frames are created when using read.csv(), but they can also be created by hand with the data.frame() function. There are a few mistakes in this hand-crafted data.frame. Can you spot and fix them? Don’t hesitate to experiment!\n\nanimal_data &lt;- data.frame(\n       animal = c(dog, cat, sea cucumber, sea urchin),\n       feel = c(\"furry\", \"squishy\", \"spiny\"),\n       weight = c(45, 8 1.1, 0.8))\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nCan you predict the class for each of the columns in the following example?\nCheck your guesses using str(country_climate):\n\nAre they what you expected? Why? Why not?\nTry again by adding stringsAsFactors = TRUE after the last variable when creating the data frame. What is happening now? stringsAsFactors can also be set when reading text-based spreadsheets into R using read.csv().\n\n\ncountry_climate &lt;- data.frame(\n       country = c(\"Canada\", \"Panama\", \"South Africa\", \"Australia\"),\n       climate = c(\"cold\", \"hot\", \"temperate\", \"hot/temperate\"),\n       temperature = c(10, 30, 18, \"15\"),\n       northern_hemisphere = c(TRUE, TRUE, FALSE, \"FALSE\"),\n       has_kangaroo = c(FALSE, FALSE, FALSE, 1)\n       )\n\n\n\nThe automatic conversion of data type is sometimes a blessing, sometimes an annoyance. Be aware that it exists, learn the rules, and double check that data you import in R are of the correct type within your data frame. If not, use it to your advantage to detect mistakes that might have been introduced during data entry (a letter in a column that should only contain numbers for instance).\nLearn more in this RStudio tutorial.\n\n\n\n\nBefore proceeding, now that we have learnt about data frames, let’s recap package installation and learn about a new data type, namely the matrix. Like a data.frame, a matrix has two dimensions, rows and columns. But the major difference is that all cells in a matrix must be of the same type: numeric, character, logical, … In that respect, matrices are closer to a vector than a data.frame.\nThe default constructor for a matrix is matrix. It takes a vector of values to populate the matrix and the number of row and/or columns1. The values are sorted along the columns, as illustrated below.\n\nm &lt;- matrix(1:9, ncol = 3, nrow = 3)\n\n\n\n\n\n\n\nChallenge\n\n\n\nUsing the function installed.packages(), create a character matrix containing the information about all packages currently installed on your computer. Explore it.\n\n\nIt is often useful to create large random data matrices as test data. The exercise below asks you to create such a matrix with random data drawn from a normal distribution of mean 0 and standard deviation 1, which can be done with the rnorm() function.\n\n\n\n\n\n\nChallenge\n\n\n\nConstruct a matrix of dimension 1000 by 3 of normally distributed data (mean 0, standard deviation 1)\n\n\n\n\n\nOne of the most common issues that new (and experienced!) R users have is converting date and time information into a variable that is appropriate and usable during analyses.\n\n\n\nDates in spreadsheets are generally stored in a single column. While this seems the most natural way to record dates, it actually is not best practice. A spreadsheet application will display the dates in a seemingly correct way (to a human observer) but how it actually handles and stores the dates may be problematic. It is often much safer to store dates with YEAR, MONTH and DAY in separate columns or as YEAR and DAY-OF-YEAR in separate columns.\nSpreadsheet programs such as LibreOffice, Microsoft Excel, OpenOffice, Gnumeric, … have different (and often incompatible) ways of encoding dates (even for the same program between versions and operating systems). Additionally, Excel can turn things that aren’t dates into dates (@Zeeberg:2004), for example names or identifiers like MAR1, DEC1, OCT4. So if you’re avoiding the date format overall, it’s easier to identify these issues.\nThe Dates as data section of the Data Carpentry lesson provides additional insights about pitfalls of dates with spreadsheets.\nWe are going to use the ymd() function from the package lubridate (which belongs to the tidyverse; learn more here). . lubridate gets installed as part of the tidyverse installation. When you load the tidyverse (library(tidyverse)), the core packages (the packages used in most data analyses) get loaded. lubridate however does not belong to the core tidyverse, so you have to load it explicitly with library(lubridate).\nStart by loading the required package:\n\nlibrary(\"lubridate\")\n\n\nAttaching package: 'lubridate'\n\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n\n\nymd() takes a vector representing year, month, and day, and converts it to a Date vector. Date is a class of data recognized by R as being a date and can be manipulated as such. The argument that the function requires is flexible, but, as a best practice, is a character vector formatted as “YYYY-MM-DD”.\nLet’s create a date object and inspect the structure:\n\nmy_date &lt;- ymd(\"2015-01-01\")\nstr(my_date)\n\n Date[1:1], format: \"2015-01-01\"\n\n\nNow let’s paste the year, month, and day separately - we get the same result:\n\n# sep indicates the character to use to separate each component\nmy_date &lt;- ymd(paste(\"2015\", \"1\", \"1\", sep = \"-\"))\nstr(my_date)\n\n Date[1:1], format: \"2015-01-01\"\n\n\nLet’s now familiarise ourselves with a typical date manipulation pipeline. The small data below has stored dates in different year, month and day columns.\n\nx &lt;- data.frame(year = c(1996, 1992, 1987, 1986, 2000, 1990, 2002, 1994, 1997, 1985),\nmonth = c(2,  3,  3, 10,  1,  8,  3,  4,  5,  5),day = c(24,  8,  1,  5,  8, 17, 13, 10, 11, 24),\nvalue = c(4,  5,  1,  9,  3,  8, 10,  2,  6,  7))\nx\n\n   year month day value\n1  1996     2  24     4\n2  1992     3   8     5\n3  1987     3   1     1\n4  1986    10   5     9\n5  2000     1   8     3\n6  1990     8  17     8\n7  2002     3  13    10\n8  1994     4  10     2\n9  1997     5  11     6\n10 1985     5  24     7\n\n\nNow we apply this function to the x dataset. We first create a character vector from the year, month, and day columns of x using paste():\n\npaste(x$year, x$month, x$day, sep = \"-\")\n\n [1] \"1996-2-24\" \"1992-3-8\"  \"1987-3-1\"  \"1986-10-5\" \"2000-1-8\"  \"1990-8-17\"\n [7] \"2002-3-13\" \"1994-4-10\" \"1997-5-11\" \"1985-5-24\"\n\n\nThis character vector can be used as the argument for ymd():\n\nymd(paste(x$year, x$month, x$day, sep = \"-\"))\n\n [1] \"1996-02-24\" \"1992-03-08\" \"1987-03-01\" \"1986-10-05\" \"2000-01-08\"\n [6] \"1990-08-17\" \"2002-03-13\" \"1994-04-10\" \"1997-05-11\" \"1985-05-24\"\n\n\nThe resulting Date vector can be added to x as a new column called date:\n\nx$date &lt;- ymd(paste(x$year, x$month, x$day, sep = \"-\"))\nstr(x) # notice the new column, with 'date' as the class\n\n'data.frame':   10 obs. of  5 variables:\n $ year : num  1996 1992 1987 1986 2000 ...\n $ month: num  2 3 3 10 1 8 3 4 5 5\n $ day  : num  24 8 1 5 8 17 13 10 11 24\n $ value: num  4 5 1 9 3 8 10 2 6 7\n $ date : Date, format: \"1996-02-24\" \"1992-03-08\" ...\n\n\nLet’s make sure everything worked correctly. One way to inspect the new column is to use summary():\n\nsummary(x$date)\n\n        Min.      1st Qu.       Median         Mean      3rd Qu.         Max. \n\"1985-05-24\" \"1988-01-11\" \"1993-03-24\" \"1993-03-18\" \"1997-01-20\" \"2002-03-13\" \n\n\nNote that ymd() expects to have the year, month and day, in that order. If you have for instance day, month and year, you would need dmy().\n\ndmy(paste(x$day, x$month, x$year, sep = \"-\"))\n\n [1] \"1996-02-24\" \"1992-03-08\" \"1987-03-01\" \"1986-10-05\" \"2000-01-08\"\n [6] \"1990-08-17\" \"2002-03-13\" \"1994-04-10\" \"1997-05-11\" \"1985-05-24\"\n\n\nlubdridate has many functions to address all date variations.\n\n\n\n\n\n\nNote\n\n\n\nSummary of R objects\nSo far, we have seen several types of R object varying in the number of dimensions and whether they could store a single or multiple data types:\n\nvector: one dimension (they have a length), single type of data.\nmatrix: two dimensions, single type of data.\ndata.frame: two dimensions, one type per column.\n\n\n\n\n\n\nA data type that we haven’t seen yet, but that is useful to know, and follows from the summary that we have just seen are lists:\n\nlist: one dimension, every item can be of a different data type.\n\nBelow, let’s create a list containing a vector of numbers, characters, a matrix, a dataframe and another list:\n\nl &lt;- list(1:10, ## numeric\n          letters, ## character\n          installed.packages(), ## a matrix\n          cars, ## a data.frame\n          list(1, 2, 3)) ## a list\nlength(l)\n\n[1] 5\n\n\n\nstr(l)\n\nList of 5\n $ : int [1:10] 1 2 3 4 5 6 7 8 9 10\n $ : chr [1:26] \"a\" \"b\" \"c\" \"d\" ...\n $ : chr [1:391, 1:16] \"abind\" \"annotate\" \"AnnotationDbi\" \"AnnotationHub\" ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : chr [1:391] \"abind\" \"annotate\" \"AnnotationDbi\" \"AnnotationHub\" ...\n  .. ..$ : chr [1:16] \"Package\" \"LibPath\" \"Version\" \"Priority\" ...\n $ :'data.frame':   50 obs. of  2 variables:\n  ..$ speed: num [1:50] 4 4 7 7 8 9 10 10 10 11 ...\n  ..$ dist : num [1:50] 2 10 4 22 16 10 18 26 34 17 ...\n $ :List of 3\n  ..$ : num 1\n  ..$ : num 2\n  ..$ : num 3\n\n\nList subsetting is done using [] to subset a new sub-list or [[]] to extract a single element of that list (using indices or names, if the list is named).\n\nl[[1]] ## first element\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\nl[1:2] ## a list of length 2\n\n[[1]]\n [1]  1  2  3  4  5  6  7  8  9 10\n\n[[2]]\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\n\nl[1]   ## a list of length 1\n\n[[1]]\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\n\n\nWe have seen how to read a text-based spreadsheet into R using the read.table family of functions. To export a data.frame to a text-based spreadsheet, we can use the write.table set of functions (write.csv, write.delim, …). They all take the variable to be exported and the file to be exported to. For example, to export the rna data to the my_rna.csv file in the data_output directory, we would execute:\n\ndir.create(here(\"data_output\"))\n\nWarning in dir.create(here(\"data_output\")):\n'/Users/hediatnani/Documents/bioc_intro/data_output' already exists\n\nwrite.csv(rna, file = here(\"data_output/my_rna.csv\"))\n\nThis new csv file can now be shared with other collaborators who aren’t familiar with R. Note that even though there are commas in some of the fields in the data.frame (see for example the “product” column), R will by default surround each field with quotes, and thus we will be able to read it back into R correctly, despite also using commas as column separators."
  },
  {
    "objectID": "bioc_intro_dataStructure.html#starting-with-data",
    "href": "bioc_intro_dataStructure.html#starting-with-data",
    "title": "Introduction to data analysis with R and Bioconductor",
    "section": "",
    "text": "We are going to use part of the data published by Blackmore et al. (2017), The effect of upper-respiratory infection on transcriptomic changes in the CNS. The goal of the study was to determine the effect of an upper-respiratory infection on changes in RNA transcription occurring in the cerebellum and spinal cord post infection. Gender matched eight week old C57BL/6 mice were inoculated with saline or with Influenza A by intranasal route and transcriptomic changes in the cerebellum and spinal cord tissues were evaluated by RNA-seq at days 0 (non-infected), 4 and 8.\nThe dataset is stored as a comma-separated values (CSV) file. Each row holds information for a single RNA expression measurement, and the first eleven columns represent:\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\ngene\nThe name of the gene that was measured\n\n\nsample\nThe name of the sample the gene expression was measured in\n\n\nexpression\nThe value of the gene expression\n\n\norganism\nThe organism/species - here all data stem from mice\n\n\nage\nThe age of the mouse (all mice were 8 weeks here)\n\n\nsex\nThe sex of the mouse\n\n\ninfection\nThe infection state of the mouse, i.e. infected with Influenza A or not infected.\n\n\nstrain\nThe Influenza A strain.\n\n\ntime\nThe duration of the infection (in days).\n\n\ntissue\nThe tissue that was used for the gene expression experiment, i.e. cerebellum or spinal cord.\n\n\nmouse\nThe mouse unique identifier.\n\n\n\n\n# Load library here\nlibrary(here)\n\n\n# Define the full path for the destination file\ndest_path &lt;- here(\"data\", \"rnaseq.csv\")\n\n# Create the directory structure if it does not exist\nifelse(\n  !dir.exists(dirname(dest_path)),\n  {\n    dir.create(dirname(dest_path), recursive = TRUE, showWarnings = FALSE)\n    \"Directory Created\"\n  },\n  \"Directory Exists\"\n)\n\n# Download the file if it does not exist\nifelse(\n  !file.exists(dest_path),\n  {\n    download.file(\n      url = \"https://github.com/carpentries-incubator/bioc-intro/raw/main/episodes/data/rnaseq.csv\",\n      destfile = dest_path\n    )\n    \"File Downloaded\"\n  },\n  \"File Exists\"\n)\n\n\n# Load the CSV file\nrna &lt;- read.csv(dest_path)\n# Have a look at the CSV file\nrna\n\nLet’s check the top (the first 6 lines) of this data frame using the function head():\n\nhead(rna)\n\n\n\n\n\n\n\nNote\n\n\n\nread.csv() assumes that fields are delineated by commas. However, in several countries, the comma is used as a decimal separator, and the semicolon (;) is used as a field delineator. If you want to read in this type of file in R, you can use the read.csv2() function. It behaves exactly like read.csv() but uses different parameters for the decimal and the field separators. If you are working with another format, they can both be specified by the user. Check out the help for read.csv() by typing ?read.csv to learn more. There is also the read.delim() function for reading tab-separated data files. It is important to note that all of these functions are actually wrapper functions for the main read.table() function with different arguments. As such, the data above could also have been loaded by using read.table() with the separation argument as ,. The code is as follows:\n\n\n\nrna &lt;- read.table(file = \"data/rnaseq.csv\",sep = \",\",header = TRUE)\n\nThe header argument has to be set to TRUE to be able to read the headers as by default read.table() has the header argument set to FALSE.\n\n\n\nData frames are the de facto data structure for most tabular data, and what we use for statistics and plotting.\nA data frame can be created by hand, but most commonly they are generated by the functions read.csv() or read.table(); in other words, when importing spreadsheets from your hard drive (or the web).\nA data frame is the representation of data in the format of a table where the columns are vectors that all have the same length. Because columns are vectors, each column must contain a single type of data (e.g., characters, integers, factors). For example, here is a figure depicting a data frame comprising a numeric, a character, and a logical vector.\n\nWe can see this when inspecting the structure of a data frame with the function str():\n\nstr(rna)\n\n'data.frame':   32428 obs. of  19 variables:\n $ gene                                 : chr  \"Asl\" \"Apod\" \"Cyp2d22\" \"Klk6\" ...\n $ sample                               : chr  \"GSM2545336\" \"GSM2545336\" \"GSM2545336\" \"GSM2545336\" ...\n $ expression                           : int  1170 36194 4060 287 85 782 1619 288 43217 1071 ...\n $ organism                             : chr  \"Mus musculus\" \"Mus musculus\" \"Mus musculus\" \"Mus musculus\" ...\n $ age                                  : int  8 8 8 8 8 8 8 8 8 8 ...\n $ sex                                  : chr  \"Female\" \"Female\" \"Female\" \"Female\" ...\n $ infection                            : chr  \"InfluenzaA\" \"InfluenzaA\" \"InfluenzaA\" \"InfluenzaA\" ...\n $ strain                               : chr  \"C57BL/6\" \"C57BL/6\" \"C57BL/6\" \"C57BL/6\" ...\n $ time                                 : int  8 8 8 8 8 8 8 8 8 8 ...\n $ tissue                               : chr  \"Cerebellum\" \"Cerebellum\" \"Cerebellum\" \"Cerebellum\" ...\n $ mouse                                : int  14 14 14 14 14 14 14 14 14 14 ...\n $ ENTREZID                             : int  109900 11815 56448 19144 80891 20528 97827 118454 18823 14696 ...\n $ product                              : chr  \"argininosuccinate lyase, transcript variant X1\" \"apolipoprotein D, transcript variant 3\" \"cytochrome P450, family 2, subfamily d, polypeptide 22, transcript variant 2\" \"kallikrein related-peptidase 6, transcript variant 2\" ...\n $ ensembl_gene_id                      : chr  \"ENSMUSG00000025533\" \"ENSMUSG00000022548\" \"ENSMUSG00000061740\" \"ENSMUSG00000050063\" ...\n $ external_synonym                     : chr  \"2510006M18Rik\" NA \"2D22\" \"Bssp\" ...\n $ chromosome_name                      : chr  \"5\" \"16\" \"15\" \"7\" ...\n $ gene_biotype                         : chr  \"protein_coding\" \"protein_coding\" \"protein_coding\" \"protein_coding\" ...\n $ phenotype_description                : chr  \"abnormal circulating amino acid level\" \"abnormal lipid homeostasis\" \"abnormal skin morphology\" \"abnormal cytokine level\" ...\n $ hsapiens_homolog_associated_gene_name: chr  \"ASL\" \"APOD\" \"CYP2D6\" \"KLK6\" ...\n\n\n\n\nWe already saw how the functions head() and str() can be useful to check the content and the structure of a data frame. Here is a non-exhaustive list of functions to get a sense of the content/structure of the data. Let’s try them out!\nSize:\n\ndim(rna) - returns a vector with the number of rows as the first element, and the number of columns as the second element (the dimensions of the object).\nnrow(rna) - returns the number of rows.\nncol(rna) - returns the number of columns.\n\nContent:\n\nhead(rna) - shows the first 6 rows.\ntail(rna) - shows the last 6 rows.\n\nNames:\n\nnames(rna) - returns the column names (synonym of colnames() for data.frame objects).\nrownames(rna) - returns the row names.\n\nSummary:\n\nstr(rna) - structure of the object and information about the class, length and content of each column.\nsummary(rna) - summary statistics for each column.\n\n\n\n\n\n\n\nNote\n\n\n\nMost of these functions are “generic”, they can be used on other types of objects besides data.frame.\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nBased on the output of str(rna), can you answer the following questions?\n\nWhat is the class of the object rna?\nHow many rows and how many columns are in this object?\n\n\n\n\n\n\n\nOur rna data frame has rows and columns (it has 2 dimensions); if we want to extract some specific data from it, we need to specify the “coordinates” we want. Row numbers come first, followed by column numbers. However, note that different ways of specifying these coordinates lead to results with different classes.\n\n# first element in the first column of the data frame (as a vector)\nrna[1, 1]\n# first element in the 6th column (as a vector)\nrna[1, 6]\n# first column of the data frame (as a vector)\nrna[, 1]\n# first column of the data frame (as a data.frame)\nrna[1]\n# first three elements in the 7th column (as a vector)\nrna[1:3, 7]\n# the 3rd row of the data frame (as a data.frame)\nrna[3, ]\n# equivalent to head_rna &lt;- head(rna)\nhead_rna &lt;- rna[1:6, ]\nhead_rna\n\n: is a special function that creates numeric vectors of integers in increasing or decreasing order, test 1:10 and 10:1 for instance. See section @ref(sec:genvec) for details.\nYou can also exclude certain indices of a data frame using the “-” sign:\n\nrna[, -1]          ## The whole data frame, except the first column\nrna[-c(7:66465), ] ## Equivalent to head(rna)\n\nData frames can be subsetted by calling indices (as shown previously), but also by calling their column names directly:\n\nrna[\"gene\"]       # Result is a data.frame\nrna[, \"gene\"]     # Result is a vector\nrna[[\"gene\"]]     # Result is a vector\nrna$gene          # Result is a vector\n\nIn RStudio, you can use the autocompletion feature to get the full and correct names of the columns.\n\n\n\n\n\n\nChallenge\n\n\n\n\nCreate a data.frame (rna_200) containing only the data in row 200 of the rna dataset.\nNotice how nrow() gave you the number of rows in a data.frame?\n\n\nUse that number to pull out just that last row in the initial rna data frame.\nCompare that with what you see as the last row using tail() to make sure it’s meeting expectations.\nPull out that last row using nrow() instead of the row number.\nCreate a new data frame (rna_last) from that last row.\n\n\nUse nrow() to extract the row that is in the middle of the rna dataframe. Store the content of this row in an object named rna_middle.\nCombine nrow() with the - notation above to reproduce the behavior of head(rna), keeping just the first through 6th rows of the rna dataset.\n\n\n\n\n\n\n\nFactors represent categorical data. They are stored as integers associated with labels and they can be ordered or unordered. While factors look (and often behave) like character vectors, they are actually treated as integer vectors by R. So you need to be very careful when treating them as strings.\nOnce created, factors can only contain a pre-defined set of values, known as levels. By default, R always sorts levels in alphabetical order. For instance, if you have a factor with 2 levels:\n\nsex &lt;- factor(c(\"male\", \"female\", \"female\", \"male\", \"female\"))\n\nR will assign 1 to the level \"female\" and 2 to the level \"male\" (because f comes before m, even though the first element in this vector is \"male\"). You can see this by using the function levels() and you can find the number of levels using nlevels():\n\nlevels(sex)\n\n[1] \"female\" \"male\"  \n\n\n\nnlevels(sex)\n\n[1] 2\n\n\nSometimes, the order of the factors does not matter, other times you might want to specify the order because it is meaningful (e.g., “low”, “medium”, “high”), it improves your visualization, or it is required by a particular type of analysis. Here, one way to reorder our levels in the sex vector would be:\n\nsex ## current order\n\n[1] male   female female male   female\nLevels: female male\n\n\n\nsex &lt;- factor(sex, levels = c(\"male\", \"female\"))\nsex ## after re-ordering\n\n[1] male   female female male   female\nLevels: male female\n\n\nIn R’s memory, these factors are represented by integers (1, 2, 3), but are more informative than integers because factors are self describing: \"female\", \"male\" is more descriptive than 1, 2. Which one is “male”? You wouldn’t be able to tell just from the integer data. Factors, on the other hand, have this information built-in. It is particularly helpful when there are many levels (like the gene biotype in our example dataset).\nWhen your data is stored as a factor, you can use the plot() function to get a quick glance at the number of observations represented by each factor level. Let’s look at the number of males and females in our data.\n\nplot(sex)\n\n\n\n\n\n\n\n\n\n\nIf you need to convert a factor to a character vector, you use as.character(x).\n\nas.character(sex)\n\n[1] \"male\"   \"female\" \"female\" \"male\"   \"female\"\n\n\n\n\n\nIf we want to rename these factor, it is sufficient to change its levels:\n\nlevels(sex)\n\n[1] \"male\"   \"female\"\n\n\n\nlevels(sex) &lt;- c(\"M\", \"F\")\nsex\n\n[1] M F F M F\nLevels: M F\n\n\n\nplot(sex)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nRename “F” and “M” to “Female” and “Male” respectively.\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWe have seen how data frames are created when using read.csv(), but they can also be created by hand with the data.frame() function. There are a few mistakes in this hand-crafted data.frame. Can you spot and fix them? Don’t hesitate to experiment!\n\nanimal_data &lt;- data.frame(\n       animal = c(dog, cat, sea cucumber, sea urchin),\n       feel = c(\"furry\", \"squishy\", \"spiny\"),\n       weight = c(45, 8 1.1, 0.8))\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nCan you predict the class for each of the columns in the following example?\nCheck your guesses using str(country_climate):\n\nAre they what you expected? Why? Why not?\nTry again by adding stringsAsFactors = TRUE after the last variable when creating the data frame. What is happening now? stringsAsFactors can also be set when reading text-based spreadsheets into R using read.csv().\n\n\ncountry_climate &lt;- data.frame(\n       country = c(\"Canada\", \"Panama\", \"South Africa\", \"Australia\"),\n       climate = c(\"cold\", \"hot\", \"temperate\", \"hot/temperate\"),\n       temperature = c(10, 30, 18, \"15\"),\n       northern_hemisphere = c(TRUE, TRUE, FALSE, \"FALSE\"),\n       has_kangaroo = c(FALSE, FALSE, FALSE, 1)\n       )\n\n\n\nThe automatic conversion of data type is sometimes a blessing, sometimes an annoyance. Be aware that it exists, learn the rules, and double check that data you import in R are of the correct type within your data frame. If not, use it to your advantage to detect mistakes that might have been introduced during data entry (a letter in a column that should only contain numbers for instance).\nLearn more in this RStudio tutorial.\n\n\n\n\nBefore proceeding, now that we have learnt about data frames, let’s recap package installation and learn about a new data type, namely the matrix. Like a data.frame, a matrix has two dimensions, rows and columns. But the major difference is that all cells in a matrix must be of the same type: numeric, character, logical, … In that respect, matrices are closer to a vector than a data.frame.\nThe default constructor for a matrix is matrix. It takes a vector of values to populate the matrix and the number of row and/or columns1. The values are sorted along the columns, as illustrated below.\n\nm &lt;- matrix(1:9, ncol = 3, nrow = 3)\n\n\n\n\n\n\n\nChallenge\n\n\n\nUsing the function installed.packages(), create a character matrix containing the information about all packages currently installed on your computer. Explore it.\n\n\nIt is often useful to create large random data matrices as test data. The exercise below asks you to create such a matrix with random data drawn from a normal distribution of mean 0 and standard deviation 1, which can be done with the rnorm() function.\n\n\n\n\n\n\nChallenge\n\n\n\nConstruct a matrix of dimension 1000 by 3 of normally distributed data (mean 0, standard deviation 1)\n\n\n\n\n\nOne of the most common issues that new (and experienced!) R users have is converting date and time information into a variable that is appropriate and usable during analyses.\n\n\n\nDates in spreadsheets are generally stored in a single column. While this seems the most natural way to record dates, it actually is not best practice. A spreadsheet application will display the dates in a seemingly correct way (to a human observer) but how it actually handles and stores the dates may be problematic. It is often much safer to store dates with YEAR, MONTH and DAY in separate columns or as YEAR and DAY-OF-YEAR in separate columns.\nSpreadsheet programs such as LibreOffice, Microsoft Excel, OpenOffice, Gnumeric, … have different (and often incompatible) ways of encoding dates (even for the same program between versions and operating systems). Additionally, Excel can turn things that aren’t dates into dates (@Zeeberg:2004), for example names or identifiers like MAR1, DEC1, OCT4. So if you’re avoiding the date format overall, it’s easier to identify these issues.\nThe Dates as data section of the Data Carpentry lesson provides additional insights about pitfalls of dates with spreadsheets.\nWe are going to use the ymd() function from the package lubridate (which belongs to the tidyverse; learn more here). . lubridate gets installed as part of the tidyverse installation. When you load the tidyverse (library(tidyverse)), the core packages (the packages used in most data analyses) get loaded. lubridate however does not belong to the core tidyverse, so you have to load it explicitly with library(lubridate).\nStart by loading the required package:\n\nlibrary(\"lubridate\")\n\n\nAttaching package: 'lubridate'\n\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n\n\nymd() takes a vector representing year, month, and day, and converts it to a Date vector. Date is a class of data recognized by R as being a date and can be manipulated as such. The argument that the function requires is flexible, but, as a best practice, is a character vector formatted as “YYYY-MM-DD”.\nLet’s create a date object and inspect the structure:\n\nmy_date &lt;- ymd(\"2015-01-01\")\nstr(my_date)\n\n Date[1:1], format: \"2015-01-01\"\n\n\nNow let’s paste the year, month, and day separately - we get the same result:\n\n# sep indicates the character to use to separate each component\nmy_date &lt;- ymd(paste(\"2015\", \"1\", \"1\", sep = \"-\"))\nstr(my_date)\n\n Date[1:1], format: \"2015-01-01\"\n\n\nLet’s now familiarise ourselves with a typical date manipulation pipeline. The small data below has stored dates in different year, month and day columns.\n\nx &lt;- data.frame(year = c(1996, 1992, 1987, 1986, 2000, 1990, 2002, 1994, 1997, 1985),\nmonth = c(2,  3,  3, 10,  1,  8,  3,  4,  5,  5),day = c(24,  8,  1,  5,  8, 17, 13, 10, 11, 24),\nvalue = c(4,  5,  1,  9,  3,  8, 10,  2,  6,  7))\nx\n\n   year month day value\n1  1996     2  24     4\n2  1992     3   8     5\n3  1987     3   1     1\n4  1986    10   5     9\n5  2000     1   8     3\n6  1990     8  17     8\n7  2002     3  13    10\n8  1994     4  10     2\n9  1997     5  11     6\n10 1985     5  24     7\n\n\nNow we apply this function to the x dataset. We first create a character vector from the year, month, and day columns of x using paste():\n\npaste(x$year, x$month, x$day, sep = \"-\")\n\n [1] \"1996-2-24\" \"1992-3-8\"  \"1987-3-1\"  \"1986-10-5\" \"2000-1-8\"  \"1990-8-17\"\n [7] \"2002-3-13\" \"1994-4-10\" \"1997-5-11\" \"1985-5-24\"\n\n\nThis character vector can be used as the argument for ymd():\n\nymd(paste(x$year, x$month, x$day, sep = \"-\"))\n\n [1] \"1996-02-24\" \"1992-03-08\" \"1987-03-01\" \"1986-10-05\" \"2000-01-08\"\n [6] \"1990-08-17\" \"2002-03-13\" \"1994-04-10\" \"1997-05-11\" \"1985-05-24\"\n\n\nThe resulting Date vector can be added to x as a new column called date:\n\nx$date &lt;- ymd(paste(x$year, x$month, x$day, sep = \"-\"))\nstr(x) # notice the new column, with 'date' as the class\n\n'data.frame':   10 obs. of  5 variables:\n $ year : num  1996 1992 1987 1986 2000 ...\n $ month: num  2 3 3 10 1 8 3 4 5 5\n $ day  : num  24 8 1 5 8 17 13 10 11 24\n $ value: num  4 5 1 9 3 8 10 2 6 7\n $ date : Date, format: \"1996-02-24\" \"1992-03-08\" ...\n\n\nLet’s make sure everything worked correctly. One way to inspect the new column is to use summary():\n\nsummary(x$date)\n\n        Min.      1st Qu.       Median         Mean      3rd Qu.         Max. \n\"1985-05-24\" \"1988-01-11\" \"1993-03-24\" \"1993-03-18\" \"1997-01-20\" \"2002-03-13\" \n\n\nNote that ymd() expects to have the year, month and day, in that order. If you have for instance day, month and year, you would need dmy().\n\ndmy(paste(x$day, x$month, x$year, sep = \"-\"))\n\n [1] \"1996-02-24\" \"1992-03-08\" \"1987-03-01\" \"1986-10-05\" \"2000-01-08\"\n [6] \"1990-08-17\" \"2002-03-13\" \"1994-04-10\" \"1997-05-11\" \"1985-05-24\"\n\n\nlubdridate has many functions to address all date variations.\n\n\n\n\n\n\nNote\n\n\n\nSummary of R objects\nSo far, we have seen several types of R object varying in the number of dimensions and whether they could store a single or multiple data types:\n\nvector: one dimension (they have a length), single type of data.\nmatrix: two dimensions, single type of data.\ndata.frame: two dimensions, one type per column.\n\n\n\n\n\n\nA data type that we haven’t seen yet, but that is useful to know, and follows from the summary that we have just seen are lists:\n\nlist: one dimension, every item can be of a different data type.\n\nBelow, let’s create a list containing a vector of numbers, characters, a matrix, a dataframe and another list:\n\nl &lt;- list(1:10, ## numeric\n          letters, ## character\n          installed.packages(), ## a matrix\n          cars, ## a data.frame\n          list(1, 2, 3)) ## a list\nlength(l)\n\n[1] 5\n\n\n\nstr(l)\n\nList of 5\n $ : int [1:10] 1 2 3 4 5 6 7 8 9 10\n $ : chr [1:26] \"a\" \"b\" \"c\" \"d\" ...\n $ : chr [1:391, 1:16] \"abind\" \"annotate\" \"AnnotationDbi\" \"AnnotationHub\" ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : chr [1:391] \"abind\" \"annotate\" \"AnnotationDbi\" \"AnnotationHub\" ...\n  .. ..$ : chr [1:16] \"Package\" \"LibPath\" \"Version\" \"Priority\" ...\n $ :'data.frame':   50 obs. of  2 variables:\n  ..$ speed: num [1:50] 4 4 7 7 8 9 10 10 10 11 ...\n  ..$ dist : num [1:50] 2 10 4 22 16 10 18 26 34 17 ...\n $ :List of 3\n  ..$ : num 1\n  ..$ : num 2\n  ..$ : num 3\n\n\nList subsetting is done using [] to subset a new sub-list or [[]] to extract a single element of that list (using indices or names, if the list is named).\n\nl[[1]] ## first element\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\nl[1:2] ## a list of length 2\n\n[[1]]\n [1]  1  2  3  4  5  6  7  8  9 10\n\n[[2]]\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\n\nl[1]   ## a list of length 1\n\n[[1]]\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\n\n\nWe have seen how to read a text-based spreadsheet into R using the read.table family of functions. To export a data.frame to a text-based spreadsheet, we can use the write.table set of functions (write.csv, write.delim, …). They all take the variable to be exported and the file to be exported to. For example, to export the rna data to the my_rna.csv file in the data_output directory, we would execute:\n\ndir.create(here(\"data_output\"))\n\nWarning in dir.create(here(\"data_output\")):\n'/Users/hediatnani/Documents/bioc_intro/data_output' already exists\n\nwrite.csv(rna, file = here(\"data_output/my_rna.csv\"))\n\nThis new csv file can now be shared with other collaborators who aren’t familiar with R. Note that even though there are commas in some of the fields in the data.frame (see for example the “product” column), R will by default surround each field with quotes, and thus we will be able to read it back into R correctly, despite also using commas as column separators."
  },
  {
    "objectID": "bioc_intro_dataStructure_solutions.html",
    "href": "bioc_intro_dataStructure_solutions.html",
    "title": "Introduction to data analysis with R and Bioconductor",
    "section": "",
    "text": "We are going to use part of the data published by Blackmore et al. (2017), The effect of upper-respiratory infection on transcriptomic changes in the CNS. The goal of the study was to determine the effect of an upper-respiratory infection on changes in RNA transcription occurring in the cerebellum and spinal cord post infection. Gender matched eight week old C57BL/6 mice were inoculated with saline or with Influenza A by intranasal route and transcriptomic changes in the cerebellum and spinal cord tissues were evaluated by RNA-seq at days 0 (non-infected), 4 and 8.\nThe dataset is stored as a comma-separated values (CSV) file. Each row holds information for a single RNA expression measurement, and the first eleven columns represent:\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\ngene\nThe name of the gene that was measured\n\n\nsample\nThe name of the sample the gene expression was measured in\n\n\nexpression\nThe value of the gene expression\n\n\norganism\nThe organism/species - here all data stem from mice\n\n\nage\nThe age of the mouse (all mice were 8 weeks here)\n\n\nsex\nThe sex of the mouse\n\n\ninfection\nThe infection state of the mouse, i.e. infected with Influenza A or not infected.\n\n\nstrain\nThe Influenza A strain.\n\n\ntime\nThe duration of the infection (in days).\n\n\ntissue\nThe tissue that was used for the gene expression experiment, i.e. cerebellum or spinal cord.\n\n\nmouse\nThe mouse unique identifier.\n\n\n\n\n# Load library here\nlibrary(here)\n\n\n# Define the full path for the destination file\ndest_path &lt;- here(\"data\", \"rnaseq.csv\")\n\n# Create the directory structure if it does not exist\nifelse(\n  !dir.exists(dirname(dest_path)),\n  {\n    dir.create(dirname(dest_path), recursive = TRUE, showWarnings = FALSE)\n    \"Directory Created\"\n  },\n  \"Directory Exists\"\n)\n\n# Download the file if it does not exist\nifelse(\n  !file.exists(dest_path),\n  {\n    download.file(\n      url = \"https://github.com/carpentries-incubator/bioc-intro/raw/main/episodes/data/rnaseq.csv\",\n      destfile = dest_path\n    )\n    \"File Downloaded\"\n  },\n  \"File Exists\"\n)\n\n\n# Load the CSV file\nrna &lt;- read.csv(dest_path)\n# Have a look at the CSV file\nrna\n\nLet’s check the top (the first 6 lines) of this data frame using the function head():\n\nhead(rna)\n\n\n\n\n\n\n\nNote\n\n\n\nread.csv() assumes that fields are delineated by commas. However, in several countries, the comma is used as a decimal separator, and the semicolon (;) is used as a field delineator. If you want to read in this type of file in R, you can use the read.csv2() function. It behaves exactly like read.csv() but uses different parameters for the decimal and the field separators. If you are working with another format, they can both be specified by the user. Check out the help for read.csv() by typing ?read.csv to learn more. There is also the read.delim() function for reading tab-separated data files. It is important to note that all of these functions are actually wrapper functions for the main read.table() function with different arguments. As such, the data above could also have been loaded by using read.table() with the separation argument as ,. The code is as follows:\n\n\n\nrna &lt;- read.table(file = \"data/rnaseq.csv\",sep = \",\",header = TRUE)\n\nThe header argument has to be set to TRUE to be able to read the headers as by default read.table() has the header argument set to FALSE.\n\n\n\nData frames are the de facto data structure for most tabular data, and what we use for statistics and plotting.\nA data frame can be created by hand, but most commonly they are generated by the functions read.csv() or read.table(); in other words, when importing spreadsheets from your hard drive (or the web).\nA data frame is the representation of data in the format of a table where the columns are vectors that all have the same length. Because columns are vectors, each column must contain a single type of data (e.g., characters, integers, factors). For example, here is a figure depicting a data frame comprising a numeric, a character, and a logical vector.\n\nWe can see this when inspecting the structure of a data frame with the function str():\n\nstr(rna)\n\n'data.frame':   32428 obs. of  19 variables:\n $ gene                                 : chr  \"Asl\" \"Apod\" \"Cyp2d22\" \"Klk6\" ...\n $ sample                               : chr  \"GSM2545336\" \"GSM2545336\" \"GSM2545336\" \"GSM2545336\" ...\n $ expression                           : int  1170 36194 4060 287 85 782 1619 288 43217 1071 ...\n $ organism                             : chr  \"Mus musculus\" \"Mus musculus\" \"Mus musculus\" \"Mus musculus\" ...\n $ age                                  : int  8 8 8 8 8 8 8 8 8 8 ...\n $ sex                                  : chr  \"Female\" \"Female\" \"Female\" \"Female\" ...\n $ infection                            : chr  \"InfluenzaA\" \"InfluenzaA\" \"InfluenzaA\" \"InfluenzaA\" ...\n $ strain                               : chr  \"C57BL/6\" \"C57BL/6\" \"C57BL/6\" \"C57BL/6\" ...\n $ time                                 : int  8 8 8 8 8 8 8 8 8 8 ...\n $ tissue                               : chr  \"Cerebellum\" \"Cerebellum\" \"Cerebellum\" \"Cerebellum\" ...\n $ mouse                                : int  14 14 14 14 14 14 14 14 14 14 ...\n $ ENTREZID                             : int  109900 11815 56448 19144 80891 20528 97827 118454 18823 14696 ...\n $ product                              : chr  \"argininosuccinate lyase, transcript variant X1\" \"apolipoprotein D, transcript variant 3\" \"cytochrome P450, family 2, subfamily d, polypeptide 22, transcript variant 2\" \"kallikrein related-peptidase 6, transcript variant 2\" ...\n $ ensembl_gene_id                      : chr  \"ENSMUSG00000025533\" \"ENSMUSG00000022548\" \"ENSMUSG00000061740\" \"ENSMUSG00000050063\" ...\n $ external_synonym                     : chr  \"2510006M18Rik\" NA \"2D22\" \"Bssp\" ...\n $ chromosome_name                      : chr  \"5\" \"16\" \"15\" \"7\" ...\n $ gene_biotype                         : chr  \"protein_coding\" \"protein_coding\" \"protein_coding\" \"protein_coding\" ...\n $ phenotype_description                : chr  \"abnormal circulating amino acid level\" \"abnormal lipid homeostasis\" \"abnormal skin morphology\" \"abnormal cytokine level\" ...\n $ hsapiens_homolog_associated_gene_name: chr  \"ASL\" \"APOD\" \"CYP2D6\" \"KLK6\" ...\n\n\n\n\nWe already saw how the functions head() and str() can be useful to check the content and the structure of a data frame. Here is a non-exhaustive list of functions to get a sense of the content/structure of the data. Let’s try them out!\nSize:\n\ndim(rna) - returns a vector with the number of rows as the first element, and the number of columns as the second element (the dimensions of the object).\nnrow(rna) - returns the number of rows.\nncol(rna) - returns the number of columns.\n\nContent:\n\nhead(rna) - shows the first 6 rows.\ntail(rna) - shows the last 6 rows.\n\nNames:\n\nnames(rna) - returns the column names (synonym of colnames() for data.frame objects).\nrownames(rna) - returns the row names.\n\nSummary:\n\nstr(rna) - structure of the object and information about the class, length and content of each column.\nsummary(rna) - summary statistics for each column.\n\n\n\n\n\n\n\nNote\n\n\n\nMost of these functions are “generic”, they can be used on other types of objects besides data.frame.\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nBased on the output of str(rna), can you answer the following questions?\n\nWhat is the class of the object rna?\nHow many rows and how many columns are in this object?\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nclass: data frame\nhow many rows: 66465, how many columns: 11\n\n\n\n\n\n\n\nOur rna data frame has rows and columns (it has 2 dimensions); if we want to extract some specific data from it, we need to specify the “coordinates” we want. Row numbers come first, followed by column numbers. However, note that different ways of specifying these coordinates lead to results with different classes.\n\n# first element in the first column of the data frame (as a vector)\nrna[1, 1]\n# first element in the 6th column (as a vector)\nrna[1, 6]\n# first column of the data frame (as a vector)\nrna[, 1]\n# first column of the data frame (as a data.frame)\nrna[1]\n# first three elements in the 7th column (as a vector)\nrna[1:3, 7]\n# the 3rd row of the data frame (as a data.frame)\nrna[3, ]\n# equivalent to head_rna &lt;- head(rna)\nhead_rna &lt;- rna[1:6, ]\nhead_rna\n\n: is a special function that creates numeric vectors of integers in increasing or decreasing order, test 1:10 and 10:1 for instance. See section @ref(sec:genvec) for details.\nYou can also exclude certain indices of a data frame using the “-” sign:\n\nrna[, -1]          ## The whole data frame, except the first column\nrna[-c(7:66465), ] ## Equivalent to head(rna)\n\nData frames can be subsetted by calling indices (as shown previously), but also by calling their column names directly:\n\nrna[\"gene\"]       # Result is a data.frame\nrna[, \"gene\"]     # Result is a vector\nrna[[\"gene\"]]     # Result is a vector\nrna$gene          # Result is a vector\n\nIn RStudio, you can use the autocompletion feature to get the full and correct names of the columns.\n\n\n\n\n\n\nChallenge\n\n\n\n\nCreate a data.frame (rna_200) containing only the data in row 200 of the rna dataset.\nNotice how nrow() gave you the number of rows in a data.frame?\n\n\nUse that number to pull out just that last row in the initial rna data frame.\nCompare that with what you see as the last row using tail() to make sure it’s meeting expectations.\nPull out that last row using nrow() instead of the row number.\nCreate a new data frame (rna_last) from that last row.\n\n\nUse nrow() to extract the row that is in the middle of the rna dataframe. Store the content of this row in an object named rna_middle.\nCombine nrow() with the - notation above to reproduce the behavior of head(rna), keeping just the first through 6th rows of the rna dataset.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n## 1.\nrna_200 &lt;- rna[200, ]\n## 2.\n## Saving `n_rows` to improve readability and reduce duplication\nn_rows &lt;- nrow(rna)\nrna_last &lt;- rna[n_rows, ]\n## 3.\nrna_middle &lt;- rna[n_rows / 2, ]\n## 4.\nrna_head &lt;- rna[-(7:n_rows), ]\n\n\n\n\n\n\n\n\nFactors represent categorical data. They are stored as integers associated with labels and they can be ordered or unordered. While factors look (and often behave) like character vectors, they are actually treated as integer vectors by R. So you need to be very careful when treating them as strings.\nOnce created, factors can only contain a pre-defined set of values, known as levels. By default, R always sorts levels in alphabetical order. For instance, if you have a factor with 2 levels:\n\nsex &lt;- factor(c(\"male\", \"female\", \"female\", \"male\", \"female\"))\n\nR will assign 1 to the level \"female\" and 2 to the level \"male\" (because f comes before m, even though the first element in this vector is \"male\"). You can see this by using the function levels() and you can find the number of levels using nlevels():\n\nlevels(sex)\n\n[1] \"female\" \"male\"  \n\n\n\nnlevels(sex)\n\n[1] 2\n\n\nSometimes, the order of the factors does not matter, other times you might want to specify the order because it is meaningful (e.g., “low”, “medium”, “high”), it improves your visualization, or it is required by a particular type of analysis. Here, one way to reorder our levels in the sex vector would be:\n\nsex ## current order\n\n[1] male   female female male   female\nLevels: female male\n\n\n\nsex &lt;- factor(sex, levels = c(\"male\", \"female\"))\nsex ## after re-ordering\n\n[1] male   female female male   female\nLevels: male female\n\n\nIn R’s memory, these factors are represented by integers (1, 2, 3), but are more informative than integers because factors are self describing: \"female\", \"male\" is more descriptive than 1, 2. Which one is “male”? You wouldn’t be able to tell just from the integer data. Factors, on the other hand, have this information built-in. It is particularly helpful when there are many levels (like the gene biotype in our example dataset).\nWhen your data is stored as a factor, you can use the plot() function to get a quick glance at the number of observations represented by each factor level. Let’s look at the number of males and females in our data.\n\nplot(sex)\n\n\n\n\n\n\n\n\n\n\nIf you need to convert a factor to a character vector, you use as.character(x).\n\nas.character(sex)\n\n[1] \"male\"   \"female\" \"female\" \"male\"   \"female\"\n\n\n\n\n\nIf we want to rename these factor, it is sufficient to change its levels:\n\nlevels(sex)\n\n[1] \"male\"   \"female\"\n\n\n\nlevels(sex) &lt;- c(\"M\", \"F\")\nsex\n\n[1] M F F M F\nLevels: M F\n\n\n\nplot(sex)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nRename “F” and “M” to “Female” and “Male” respectively.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nlevels(sex)\n\n[1] \"M\" \"F\"\n\n\n\nlevels(sex) &lt;- c(\"Male\", \"Female\")\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWe have seen how data frames are created when using read.csv(), but they can also be created by hand with the data.frame() function. There are a few mistakes in this hand-crafted data.frame. Can you spot and fix them? Don’t hesitate to experiment!\n\nanimal_data &lt;- data.frame(\n       animal = c(dog, cat, sea cucumber, sea urchin),\n       feel = c(\"furry\", \"squishy\", \"spiny\"),\n       weight = c(45, 8 1.1, 0.8))\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nmissing quotations around the names of the animals\nmissing one entry in the “feel” column (probably for one of the furry animals)\nmissing one comma in the weight column\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nCan you predict the class for each of the columns in the following example?\nCheck your guesses using str(country_climate):\n\nAre they what you expected? Why? Why not?\nTry again by adding stringsAsFactors = TRUE after the last variable when creating the data frame. What is happening now? stringsAsFactors can also be set when reading text-based spreadsheets into R using read.csv().\n\n\ncountry_climate &lt;- data.frame(\n       country = c(\"Canada\", \"Panama\", \"South Africa\", \"Australia\"),\n       climate = c(\"cold\", \"hot\", \"temperate\", \"hot/temperate\"),\n       temperature = c(10, 30, 18, \"15\"),\n       northern_hemisphere = c(TRUE, TRUE, FALSE, \"FALSE\"),\n       has_kangaroo = c(FALSE, FALSE, FALSE, 1)\n       )\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ncountry_climate &lt;- data.frame(\n       country = c(\"Canada\", \"Panama\", \"South Africa\", \"Australia\"),\n       climate = c(\"cold\", \"hot\", \"temperate\", \"hot/temperate\"),\n       temperature = c(10, 30, 18, \"15\"),\n       northern_hemisphere = c(TRUE, TRUE, FALSE, \"FALSE\"),\n       has_kangaroo = c(FALSE, FALSE, FALSE, 1)\n       )\nstr(country_climate)\n\n'data.frame':   4 obs. of  5 variables:\n $ country            : chr  \"Canada\" \"Panama\" \"South Africa\" \"Australia\"\n $ climate            : chr  \"cold\" \"hot\" \"temperate\" \"hot/temperate\"\n $ temperature        : chr  \"10\" \"30\" \"18\" \"15\"\n $ northern_hemisphere: chr  \"TRUE\" \"TRUE\" \"FALSE\" \"FALSE\"\n $ has_kangaroo       : num  0 0 0 1\n\n\n\n\n\nThe automatic conversion of data type is sometimes a blessing, sometimes an annoyance. Be aware that it exists, learn the rules, and double check that data you import in R are of the correct type within your data frame. If not, use it to your advantage to detect mistakes that might have been introduced during data entry (a letter in a column that should only contain numbers for instance).\nLearn more in this RStudio tutorial.\n\n\n\n\nBefore proceeding, now that we have learnt about data frames, let’s recap package installation and learn about a new data type, namely the matrix. Like a data.frame, a matrix has two dimensions, rows and columns. But the major difference is that all cells in a matrix must be of the same type: numeric, character, logical, … In that respect, matrices are closer to a vector than a data.frame.\nThe default constructor for a matrix is matrix. It takes a vector of values to populate the matrix and the number of row and/or columns1. The values are sorted along the columns, as illustrated below.\n\nm &lt;- matrix(1:9, ncol = 3, nrow = 3)\n\n\n\n\n\n\n\nChallenge\n\n\n\nUsing the function installed.packages(), create a character matrix containing the information about all packages currently installed on your computer. Explore it.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n## create the matrix\nip &lt;- installed.packages()\nhead(ip)\n\n              Package        \nabind         \"abind\"        \nannotate      \"annotate\"     \nAnnotationDbi \"AnnotationDbi\"\nAnnotationHub \"AnnotationHub\"\nAsioHeaders   \"AsioHeaders\"  \naskpass       \"askpass\"      \n              LibPath                                                               \nabind         \"/Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\"\nannotate      \"/Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\"\nAnnotationDbi \"/Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\"\nAnnotationHub \"/Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\"\nAsioHeaders   \"/Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\"\naskpass       \"/Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\"\n              Version    Priority\nabind         \"1.4-5\"    NA      \nannotate      \"1.80.0\"   NA      \nAnnotationDbi \"1.64.1\"   NA      \nAnnotationHub \"3.10.0\"   NA      \nAsioHeaders   \"1.22.1-2\" NA      \naskpass       \"1.2.0\"    NA      \n              Depends                                                                                 \nabind         \"R (&gt;= 1.5.0)\"                                                                          \nannotate      \"R (&gt;= 2.10), AnnotationDbi (&gt;= 1.27.5), XML\"                                           \nAnnotationDbi \"R (&gt;= 2.7.0), methods, stats4, BiocGenerics (&gt;= 0.29.2),\\nBiobase (&gt;= 1.17.0), IRanges\"\nAnnotationHub \"BiocGenerics (&gt;= 0.15.10), BiocFileCache (&gt;= 1.5.1)\"                                   \nAsioHeaders   NA                                                                                      \naskpass       NA                                                                                      \n              Imports                                                                                                                                                           \nabind         \"methods, utils\"                                                                                                                                                  \nannotate      \"Biobase, DBI, xtable, graphics, utils, stats, methods,\\nBiocGenerics (&gt;= 0.13.8), httr\"                                                                          \nAnnotationDbi \"DBI, RSQLite, S4Vectors (&gt;= 0.9.25), stats, KEGGREST\"                                                                                                            \nAnnotationHub \"utils, methods, grDevices, RSQLite, BiocManager, BiocVersion,\\ncurl, rappdirs, AnnotationDbi (&gt;= 1.31.19), S4Vectors, httr,\\nyaml, dplyr, interactiveDisplayBase\"\nAsioHeaders   NA                                                                                                                                                                \naskpass       \"sys (&gt;= 2.1)\"                                                                                                                                                    \n              LinkingTo\nabind         NA       \nannotate      NA       \nAnnotationDbi NA       \nAnnotationHub NA       \nAsioHeaders   NA       \naskpass       NA       \n              Suggests                                                                                                                                                                                                                                                                               \nabind         NA                                                                                                                                                                                                                                                                                     \nannotate      \"hgu95av2.db, genefilter, Biostrings (&gt;= 2.25.10), IRanges,\\nrae230a.db, rae230aprobe, tkWidgets, GO.db, org.Hs.eg.db,\\norg.Mm.eg.db, humanCHRLOC, Rgraphviz, RUnit,\"                                                                                                                  \nAnnotationDbi \"utils, hgu95av2.db, GO.db, org.Sc.sgd.db, org.At.tair.db,\\nRUnit, TxDb.Hsapiens.UCSC.hg19.knownGene, org.Hs.eg.db,\\nreactome.db, AnnotationForge, graph, EnsDb.Hsapiens.v75,\\nBiocStyle, knitr\"                                                                                       \nAnnotationHub \"IRanges, GenomicRanges, GenomeInfoDb, VariantAnnotation,\\nRsamtools, rtracklayer, BiocStyle, knitr, AnnotationForge,\\nrBiopaxParser, RUnit, GenomicFeatures, MSnbase, mzR,\\nBiostrings, CompoundDb, keras, ensembldb, SummarizedExperiment,\\nExperimentHub, gdsfmt, rmarkdown, HubPub\"\nAsioHeaders   NA                                                                                                                                                                                                                                                                                     \naskpass       \"testthat\"                                                                                                                                                                                                                                                                             \n              Enhances            License              License_is_FOSS\nabind         NA                  \"LGPL (&gt;= 2)\"        NA             \nannotate      NA                  \"Artistic-2.0\"       NA             \nAnnotationDbi NA                  \"Artistic-2.0\"       NA             \nAnnotationHub \"AnnotationHubData\" \"Artistic-2.0\"       NA             \nAsioHeaders   NA                  \"BSL-1.0\"            NA             \naskpass       NA                  \"MIT + file LICENSE\" NA             \n              License_restricts_use OS_type MD5sum NeedsCompilation Built  \nabind         NA                    NA      NA     \"no\"             \"4.3.0\"\nannotate      NA                    NA      NA     \"no\"             \"4.3.1\"\nAnnotationDbi NA                    NA      NA     \"no\"             \"4.3.1\"\nAnnotationHub NA                    NA      NA     \"yes\"            \"4.3.1\"\nAsioHeaders   NA                    NA      NA     \"no\"             \"4.3.0\"\naskpass       NA                    NA      NA     \"yes\"            \"4.3.0\"\n\n## try also View(ip)\n## number of package\nnrow(ip)\n\n[1] 391\n\n## names of all installed packages\nrownames(ip)\n\n  [1] \"abind\"                  \"annotate\"               \"AnnotationDbi\"         \n  [4] \"AnnotationHub\"          \"AsioHeaders\"            \"askpass\"               \n  [7] \"backports\"              \"base\"                   \"base64enc\"             \n [10] \"beachmat\"               \"beeswarm\"               \"BH\"                    \n [13] \"Biobase\"                \"BiocFileCache\"          \"BiocGenerics\"          \n [16] \"BiocIO\"                 \"BiocManager\"            \"BiocParallel\"          \n [19] \"BiocStyle\"              \"BiocVersion\"            \"biomaRt\"               \n [22] \"Biostrings\"             \"bit\"                    \"bit64\"                 \n [25] \"bitops\"                 \"blob\"                   \"bookdown\"              \n [28] \"boot\"                   \"BPCells\"                \"brew\"                  \n [31] \"brio\"                   \"broom\"                  \"bslib\"                 \n [34] \"cachem\"                 \"callr\"                  \"caTools\"               \n [37] \"celldex\"                \"cellranger\"             \"checkmate\"             \n [40] \"circlize\"               \"class\"                  \"cli\"                   \n [43] \"clipr\"                  \"clock\"                  \"cluster\"               \n [46] \"codetools\"              \"colorout\"               \"colorspace\"            \n [49] \"commonmark\"             \"compiler\"               \"ComplexUpset\"          \n [52] \"conflicted\"             \"countdown\"              \"cowplot\"               \n [55] \"cpp11\"                  \"crayon\"                 \"credentials\"           \n [58] \"crosstalk\"              \"curl\"                   \"data.table\"            \n [61] \"datasets\"               \"DBI\"                    \"dbplyr\"                \n [64] \"DelayedArray\"           \"DelayedMatrixStats\"     \"deldir\"                \n [67] \"desc\"                   \"devtools\"               \"diagram\"               \n [70] \"dials\"                  \"DiceDesign\"             \"diffobj\"               \n [73] \"digest\"                 \"doFuture\"               \"dotCall64\"             \n [76] \"downlit\"                \"downloader\"             \"dplyr\"                 \n [79] \"dqrng\"                  \"DT\"                     \"dtplyr\"                \n [82] \"edgeR\"                  \"ellipsis\"               \"EnhancedVolcano\"       \n [85] \"evaluate\"               \"ExperimentHub\"          \"fansi\"                 \n [88] \"farver\"                 \"fastDummies\"            \"fastmap\"               \n [91] \"filelock\"               \"fitdistrplus\"           \"FNN\"                   \n [94] \"fontawesome\"            \"forcats\"                \"foreach\"               \n [97] \"foreign\"                \"formatR\"                \"Formula\"               \n[100] \"fs\"                     \"furrr\"                  \"futile.logger\"         \n[103] \"futile.options\"         \"future\"                 \"future.apply\"          \n[106] \"gargle\"                 \"genefilter\"             \"generics\"              \n[109] \"GeneSelectR\"            \"GenomeInfoDb\"           \"GenomeInfoDbData\"      \n[112] \"GenomicAlignments\"      \"GenomicRanges\"          \"gert\"                  \n[115] \"ggcorrplot\"             \"ggplot2\"                \"ggplot2movies\"         \n[118] \"ggrepel\"                \"ggridges\"               \"gh\"                    \n[121] \"gitcreds\"               \"glmGamPoi\"              \"glmnet\"                \n[124] \"GlobalOptions\"          \"globals\"                \"glue\"                  \n[127] \"goftest\"                \"googledrive\"            \"googlesheets4\"         \n[130] \"gower\"                  \"GPfit\"                  \"gplots\"                \n[133] \"graphics\"               \"grDevices\"              \"grid\"                  \n[136] \"gridExtra\"              \"gtable\"                 \"gtools\"                \n[139] \"hardhat\"                \"haven\"                  \"HDF5Array\"             \n[142] \"here\"                   \"hexbin\"                 \"highr\"                 \n[145] \"Hmisc\"                  \"hms\"                    \"htmlTable\"             \n[148] \"htmltools\"              \"htmlwidgets\"            \"httpuv\"                \n[151] \"httr\"                   \"httr2\"                  \"ica\"                   \n[154] \"ids\"                    \"igraph\"                 \"infer\"                 \n[157] \"ini\"                    \"interactiveDisplayBase\" \"interp\"                \n[160] \"ipred\"                  \"IRanges\"                \"irlba\"                 \n[163] \"isoband\"                \"iterators\"              \"jaffelab\"              \n[166] \"jpeg\"                   \"jquerylib\"              \"jsonlite\"              \n[169] \"KEGGREST\"               \"kernlab\"                \"KernSmooth\"            \n[172] \"knitr\"                  \"labeling\"               \"lambda.r\"              \n[175] \"later\"                  \"lattice\"                \"latticeExtra\"          \n[178] \"lava\"                   \"lazyeval\"               \"leiden\"                \n[181] \"lhs\"                    \"lifecycle\"              \"limma\"                 \n[184] \"listenv\"                \"lmtest\"                 \"locfit\"                \n[187] \"lubridate\"              \"magrittr\"               \"MASS\"                  \n[190] \"Matrix\"                 \"MatrixGenerics\"         \"matrixStats\"           \n[193] \"memoise\"                \"methods\"                \"mgcv\"                  \n[196] \"mime\"                   \"miniUI\"                 \"modeldata\"             \n[199] \"modelenv\"               \"modelr\"                 \"munsell\"               \n[202] \"nlme\"                   \"nnet\"                   \"numDeriv\"              \n[205] \"openssl\"                \"org.Hs.eg.db\"           \"packrat\"               \n[208] \"pagedown\"               \"pak\"                    \"parallel\"              \n[211] \"parallelly\"             \"parsnip\"                \"patchwork\"             \n[214] \"pbapply\"                \"pheatmap\"               \"pillar\"                \n[217] \"pkgbuild\"               \"pkgconfig\"              \"pkgdown\"               \n[220] \"pkgload\"                \"PKI\"                    \"plogr\"                 \n[223] \"plotly\"                 \"plotwidgets\"            \"plumber\"               \n[226] \"plyr\"                   \"png\"                    \"polyclip\"              \n[229] \"postcards\"              \"praise\"                 \"presto\"                \n[232] \"prettyunits\"            \"prismatic\"              \"processx\"              \n[235] \"prodlim\"                \"profvis\"                \"progress\"              \n[238] \"progressr\"              \"promises\"               \"prompt\"                \n[241] \"ps\"                     \"purrr\"                  \"qsvaR\"                 \n[244] \"R.methodsS3\"            \"R.oo\"                   \"R.utils\"               \n[247] \"R6\"                     \"rafalib\"                \"ragg\"                  \n[250] \"RANN\"                   \"rappdirs\"               \"rcmdcheck\"             \n[253] \"RColorBrewer\"           \"Rcpp\"                   \"RcppAnnoy\"             \n[256] \"RcppArmadillo\"          \"RcppEigen\"              \"RcppHNSW\"              \n[259] \"RcppProgress\"           \"RcppTOML\"               \"RCurl\"                 \n[262] \"readr\"                  \"readxl\"                 \"recipes\"               \n[265] \"rematch\"                \"rematch2\"               \"remotes\"               \n[268] \"renv\"                   \"reprex\"                 \"reshape2\"              \n[271] \"restfulr\"               \"reticulate\"             \"rhdf5\"                 \n[274] \"rhdf5filters\"           \"Rhdf5lib\"               \"Rhtslib\"               \n[277] \"rjson\"                  \"rlang\"                  \"rmarkdown\"             \n[280] \"ROCR\"                   \"roxygen2\"               \"rpart\"                 \n[283] \"rprojroot\"              \"rsample\"                \"Rsamtools\"             \n[286] \"rsconnect\"              \"RSpectra\"               \"RSQLite\"               \n[289] \"rstudioapi\"             \"rtracklayer\"            \"Rtsne\"                 \n[292] \"rversions\"              \"rvest\"                  \"S4Arrays\"              \n[295] \"S4Vectors\"              \"SASmixed\"               \"sass\"                  \n[298] \"scales\"                 \"scattermore\"            \"sctransform\"           \n[301] \"segmented\"              \"selectr\"                \"servr\"                 \n[304] \"sessioninfo\"            \"Seurat\"                 \"SeuratObject\"          \n[307] \"sfd\"                    \"sfsmisc\"                \"shape\"                 \n[310] \"shiny\"                  \"SingleCellExperiment\"   \"sitmo\"                 \n[313] \"slider\"                 \"snow\"                   \"sodium\"                \n[316] \"sourcetools\"            \"sp\"                     \"spam\"                  \n[319] \"SparseArray\"            \"sparseMatrixStats\"      \"spatial\"               \n[322] \"spatstat.data\"          \"spatstat.explore\"       \"spatstat.geom\"         \n[325] \"spatstat.random\"        \"spatstat.sparse\"        \"spatstat.univar\"       \n[328] \"spatstat.utils\"         \"splines\"                \"SQUAREM\"               \n[331] \"statmod\"                \"stats\"                  \"stats4\"                \n[334] \"stringi\"                \"stringr\"                \"SummarizedExperiment\"  \n[337] \"survival\"               \"sva\"                    \"swagger\"               \n[340] \"sys\"                    \"systemfonts\"            \"tagcloud\"              \n[343] \"TCGAbiolinks\"           \"TCGAbiolinksGUI.data\"   \"tcltk\"                 \n[346] \"tensor\"                 \"testthat\"               \"textshaping\"           \n[349] \"tibble\"                 \"tidymodels\"             \"tidyr\"                 \n[352] \"tidyselect\"             \"tidyverse\"              \"timechange\"            \n[355] \"timeDate\"               \"tinytex\"                \"tmod\"                  \n[358] \"tools\"                  \"tune\"                   \"tximport\"              \n[361] \"tzdb\"                   \"urlchecker\"             \"usethis\"               \n[364] \"utf8\"                   \"utils\"                  \"uuid\"                  \n[367] \"uwot\"                   \"vctrs\"                  \"viridis\"               \n[370] \"viridisLite\"            \"vroom\"                  \"waldo\"                 \n[373] \"warp\"                   \"webexercises\"           \"websocket\"             \n[376] \"webutils\"               \"whisker\"                \"withr\"                 \n[379] \"workflows\"              \"workflowsets\"           \"xfun\"                  \n[382] \"XML\"                    \"xml2\"                   \"xopen\"                 \n[385] \"xtable\"                 \"XVector\"                \"yaml\"                  \n[388] \"yardstick\"              \"zip\"                    \"zlibbioc\"              \n[391] \"zoo\"                   \n\n## type of information we have about each package\ncolnames(ip)\n\n [1] \"Package\"               \"LibPath\"               \"Version\"              \n [4] \"Priority\"              \"Depends\"               \"Imports\"              \n [7] \"LinkingTo\"             \"Suggests\"              \"Enhances\"             \n[10] \"License\"               \"License_is_FOSS\"       \"License_restricts_use\"\n[13] \"OS_type\"               \"MD5sum\"                \"NeedsCompilation\"     \n[16] \"Built\"                \n\n\n\n\n\nIt is often useful to create large random data matrices as test data. The exercise below asks you to create such a matrix with random data drawn from a normal distribution of mean 0 and standard deviation 1, which can be done with the rnorm() function.\n\n\n\n\n\n\nChallenge\n\n\n\nConstruct a matrix of dimension 1000 by 3 of normally distributed data (mean 0, standard deviation 1)\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nset.seed(123)\nm &lt;- matrix(rnorm(3000), ncol = 3)\ndim(m)\n\n[1] 1000    3\n\n\n\nhead(m)\n\n            [,1]        [,2]       [,3]\n[1,] -0.56047565 -0.99579872 -0.5116037\n[2,] -0.23017749 -1.03995504  0.2369379\n[3,]  1.55870831 -0.01798024 -0.5415892\n[4,]  0.07050839 -0.13217513  1.2192276\n[5,]  0.12928774 -2.54934277  0.1741359\n[6,]  1.71506499  1.04057346 -0.6152683\n\n\n\n\n\n\n\n\nOne of the most common issues that new (and experienced!) R users have is converting date and time information into a variable that is appropriate and usable during analyses.\n\n\n\nDates in spreadsheets are generally stored in a single column. While this seems the most natural way to record dates, it actually is not best practice. A spreadsheet application will display the dates in a seemingly correct way (to a human observer) but how it actually handles and stores the dates may be problematic. It is often much safer to store dates with YEAR, MONTH and DAY in separate columns or as YEAR and DAY-OF-YEAR in separate columns.\nSpreadsheet programs such as LibreOffice, Microsoft Excel, OpenOffice, Gnumeric, … have different (and often incompatible) ways of encoding dates (even for the same program between versions and operating systems). Additionally, Excel can turn things that aren’t dates into dates (@Zeeberg:2004), for example names or identifiers like MAR1, DEC1, OCT4. So if you’re avoiding the date format overall, it’s easier to identify these issues.\nThe Dates as data section of the Data Carpentry lesson provides additional insights about pitfalls of dates with spreadsheets.\nWe are going to use the ymd() function from the package lubridate (which belongs to the tidyverse; learn more here). . lubridate gets installed as part of the tidyverse installation. When you load the tidyverse (library(tidyverse)), the core packages (the packages used in most data analyses) get loaded. lubridate however does not belong to the core tidyverse, so you have to load it explicitly with library(lubridate).\nStart by loading the required package:\n\nlibrary(\"lubridate\")\n\n\nAttaching package: 'lubridate'\n\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n\n\nymd() takes a vector representing year, month, and day, and converts it to a Date vector. Date is a class of data recognized by R as being a date and can be manipulated as such. The argument that the function requires is flexible, but, as a best practice, is a character vector formatted as “YYYY-MM-DD”.\nLet’s create a date object and inspect the structure:\n\nmy_date &lt;- ymd(\"2015-01-01\")\nstr(my_date)\n\n Date[1:1], format: \"2015-01-01\"\n\n\nNow let’s paste the year, month, and day separately - we get the same result:\n\n# sep indicates the character to use to separate each component\nmy_date &lt;- ymd(paste(\"2015\", \"1\", \"1\", sep = \"-\"))\nstr(my_date)\n\n Date[1:1], format: \"2015-01-01\"\n\n\nLet’s now familiarise ourselves with a typical date manipulation pipeline. The small data below has stored dates in different year, month and day columns.\n\nx &lt;- data.frame(year = c(1996, 1992, 1987, 1986, 2000, 1990, 2002, 1994, 1997, 1985),\nmonth = c(2,  3,  3, 10,  1,  8,  3,  4,  5,  5),day = c(24,  8,  1,  5,  8, 17, 13, 10, 11, 24),\nvalue = c(4,  5,  1,  9,  3,  8, 10,  2,  6,  7))\nx\n\n   year month day value\n1  1996     2  24     4\n2  1992     3   8     5\n3  1987     3   1     1\n4  1986    10   5     9\n5  2000     1   8     3\n6  1990     8  17     8\n7  2002     3  13    10\n8  1994     4  10     2\n9  1997     5  11     6\n10 1985     5  24     7\n\n\nNow we apply this function to the x dataset. We first create a character vector from the year, month, and day columns of x using paste():\n\npaste(x$year, x$month, x$day, sep = \"-\")\n\n [1] \"1996-2-24\" \"1992-3-8\"  \"1987-3-1\"  \"1986-10-5\" \"2000-1-8\"  \"1990-8-17\"\n [7] \"2002-3-13\" \"1994-4-10\" \"1997-5-11\" \"1985-5-24\"\n\n\nThis character vector can be used as the argument for ymd():\n\nymd(paste(x$year, x$month, x$day, sep = \"-\"))\n\n [1] \"1996-02-24\" \"1992-03-08\" \"1987-03-01\" \"1986-10-05\" \"2000-01-08\"\n [6] \"1990-08-17\" \"2002-03-13\" \"1994-04-10\" \"1997-05-11\" \"1985-05-24\"\n\n\nThe resulting Date vector can be added to x as a new column called date:\n\nx$date &lt;- ymd(paste(x$year, x$month, x$day, sep = \"-\"))\nstr(x) # notice the new column, with 'date' as the class\n\n'data.frame':   10 obs. of  5 variables:\n $ year : num  1996 1992 1987 1986 2000 ...\n $ month: num  2 3 3 10 1 8 3 4 5 5\n $ day  : num  24 8 1 5 8 17 13 10 11 24\n $ value: num  4 5 1 9 3 8 10 2 6 7\n $ date : Date, format: \"1996-02-24\" \"1992-03-08\" ...\n\n\nLet’s make sure everything worked correctly. One way to inspect the new column is to use summary():\n\nsummary(x$date)\n\n        Min.      1st Qu.       Median         Mean      3rd Qu.         Max. \n\"1985-05-24\" \"1988-01-11\" \"1993-03-24\" \"1993-03-18\" \"1997-01-20\" \"2002-03-13\" \n\n\nNote that ymd() expects to have the year, month and day, in that order. If you have for instance day, month and year, you would need dmy().\n\ndmy(paste(x$day, x$month, x$year, sep = \"-\"))\n\n [1] \"1996-02-24\" \"1992-03-08\" \"1987-03-01\" \"1986-10-05\" \"2000-01-08\"\n [6] \"1990-08-17\" \"2002-03-13\" \"1994-04-10\" \"1997-05-11\" \"1985-05-24\"\n\n\nlubdridate has many functions to address all date variations.\n\n\n\n\n\n\nNote\n\n\n\nSummary of R objects\nSo far, we have seen several types of R object varying in the number of dimensions and whether they could store a single or multiple data types:\n\nvector: one dimension (they have a length), single type of data.\nmatrix: two dimensions, single type of data.\ndata.frame: two dimensions, one type per column.\n\n\n\n\n\n\nA data type that we haven’t seen yet, but that is useful to know, and follows from the summary that we have just seen are lists:\n\nlist: one dimension, every item can be of a different data type.\n\nBelow, let’s create a list containing a vector of numbers, characters, a matrix, a dataframe and another list:\n\nl &lt;- list(1:10, ## numeric\n          letters, ## character\n          installed.packages(), ## a matrix\n          cars, ## a data.frame\n          list(1, 2, 3)) ## a list\nlength(l)\n\n[1] 5\n\n\n\nstr(l)\n\nList of 5\n $ : int [1:10] 1 2 3 4 5 6 7 8 9 10\n $ : chr [1:26] \"a\" \"b\" \"c\" \"d\" ...\n $ : chr [1:391, 1:16] \"abind\" \"annotate\" \"AnnotationDbi\" \"AnnotationHub\" ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : chr [1:391] \"abind\" \"annotate\" \"AnnotationDbi\" \"AnnotationHub\" ...\n  .. ..$ : chr [1:16] \"Package\" \"LibPath\" \"Version\" \"Priority\" ...\n $ :'data.frame':   50 obs. of  2 variables:\n  ..$ speed: num [1:50] 4 4 7 7 8 9 10 10 10 11 ...\n  ..$ dist : num [1:50] 2 10 4 22 16 10 18 26 34 17 ...\n $ :List of 3\n  ..$ : num 1\n  ..$ : num 2\n  ..$ : num 3\n\n\nList subsetting is done using [] to subset a new sub-list or [[]] to extract a single element of that list (using indices or names, if the list is named).\n\nl[[1]] ## first element\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\nl[1:2] ## a list of length 2\n\n[[1]]\n [1]  1  2  3  4  5  6  7  8  9 10\n\n[[2]]\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\n\nl[1]   ## a list of length 1\n\n[[1]]\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\n\n\nWe have seen how to read a text-based spreadsheet into R using the read.table family of functions. To export a data.frame to a text-based spreadsheet, we can use the write.table set of functions (write.csv, write.delim, …). They all take the variable to be exported and the file to be exported to. For example, to export the rna data to the my_rna.csv file in the data_output directory, we would execute:\n\ndir.create(here(\"data_output\"))\n\nWarning in dir.create(here(\"data_output\")):\n'/Users/hediatnani/Documents/bioc_intro/data_output' already exists\n\nwrite.csv(rna, file = here(\"data_output/my_rna.csv\"))\n\nThis new csv file can now be shared with other collaborators who aren’t familiar with R. Note that even though there are commas in some of the fields in the data.frame (see for example the “product” column), R will by default surround each field with quotes, and thus we will be able to read it back into R correctly, despite also using commas as column separators."
  },
  {
    "objectID": "bioc_intro_dataStructure_solutions.html#starting-with-data",
    "href": "bioc_intro_dataStructure_solutions.html#starting-with-data",
    "title": "Introduction to data analysis with R and Bioconductor",
    "section": "",
    "text": "We are going to use part of the data published by Blackmore et al. (2017), The effect of upper-respiratory infection on transcriptomic changes in the CNS. The goal of the study was to determine the effect of an upper-respiratory infection on changes in RNA transcription occurring in the cerebellum and spinal cord post infection. Gender matched eight week old C57BL/6 mice were inoculated with saline or with Influenza A by intranasal route and transcriptomic changes in the cerebellum and spinal cord tissues were evaluated by RNA-seq at days 0 (non-infected), 4 and 8.\nThe dataset is stored as a comma-separated values (CSV) file. Each row holds information for a single RNA expression measurement, and the first eleven columns represent:\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\ngene\nThe name of the gene that was measured\n\n\nsample\nThe name of the sample the gene expression was measured in\n\n\nexpression\nThe value of the gene expression\n\n\norganism\nThe organism/species - here all data stem from mice\n\n\nage\nThe age of the mouse (all mice were 8 weeks here)\n\n\nsex\nThe sex of the mouse\n\n\ninfection\nThe infection state of the mouse, i.e. infected with Influenza A or not infected.\n\n\nstrain\nThe Influenza A strain.\n\n\ntime\nThe duration of the infection (in days).\n\n\ntissue\nThe tissue that was used for the gene expression experiment, i.e. cerebellum or spinal cord.\n\n\nmouse\nThe mouse unique identifier.\n\n\n\n\n# Load library here\nlibrary(here)\n\n\n# Define the full path for the destination file\ndest_path &lt;- here(\"data\", \"rnaseq.csv\")\n\n# Create the directory structure if it does not exist\nifelse(\n  !dir.exists(dirname(dest_path)),\n  {\n    dir.create(dirname(dest_path), recursive = TRUE, showWarnings = FALSE)\n    \"Directory Created\"\n  },\n  \"Directory Exists\"\n)\n\n# Download the file if it does not exist\nifelse(\n  !file.exists(dest_path),\n  {\n    download.file(\n      url = \"https://github.com/carpentries-incubator/bioc-intro/raw/main/episodes/data/rnaseq.csv\",\n      destfile = dest_path\n    )\n    \"File Downloaded\"\n  },\n  \"File Exists\"\n)\n\n\n# Load the CSV file\nrna &lt;- read.csv(dest_path)\n# Have a look at the CSV file\nrna\n\nLet’s check the top (the first 6 lines) of this data frame using the function head():\n\nhead(rna)\n\n\n\n\n\n\n\nNote\n\n\n\nread.csv() assumes that fields are delineated by commas. However, in several countries, the comma is used as a decimal separator, and the semicolon (;) is used as a field delineator. If you want to read in this type of file in R, you can use the read.csv2() function. It behaves exactly like read.csv() but uses different parameters for the decimal and the field separators. If you are working with another format, they can both be specified by the user. Check out the help for read.csv() by typing ?read.csv to learn more. There is also the read.delim() function for reading tab-separated data files. It is important to note that all of these functions are actually wrapper functions for the main read.table() function with different arguments. As such, the data above could also have been loaded by using read.table() with the separation argument as ,. The code is as follows:\n\n\n\nrna &lt;- read.table(file = \"data/rnaseq.csv\",sep = \",\",header = TRUE)\n\nThe header argument has to be set to TRUE to be able to read the headers as by default read.table() has the header argument set to FALSE.\n\n\n\nData frames are the de facto data structure for most tabular data, and what we use for statistics and plotting.\nA data frame can be created by hand, but most commonly they are generated by the functions read.csv() or read.table(); in other words, when importing spreadsheets from your hard drive (or the web).\nA data frame is the representation of data in the format of a table where the columns are vectors that all have the same length. Because columns are vectors, each column must contain a single type of data (e.g., characters, integers, factors). For example, here is a figure depicting a data frame comprising a numeric, a character, and a logical vector.\n\nWe can see this when inspecting the structure of a data frame with the function str():\n\nstr(rna)\n\n'data.frame':   32428 obs. of  19 variables:\n $ gene                                 : chr  \"Asl\" \"Apod\" \"Cyp2d22\" \"Klk6\" ...\n $ sample                               : chr  \"GSM2545336\" \"GSM2545336\" \"GSM2545336\" \"GSM2545336\" ...\n $ expression                           : int  1170 36194 4060 287 85 782 1619 288 43217 1071 ...\n $ organism                             : chr  \"Mus musculus\" \"Mus musculus\" \"Mus musculus\" \"Mus musculus\" ...\n $ age                                  : int  8 8 8 8 8 8 8 8 8 8 ...\n $ sex                                  : chr  \"Female\" \"Female\" \"Female\" \"Female\" ...\n $ infection                            : chr  \"InfluenzaA\" \"InfluenzaA\" \"InfluenzaA\" \"InfluenzaA\" ...\n $ strain                               : chr  \"C57BL/6\" \"C57BL/6\" \"C57BL/6\" \"C57BL/6\" ...\n $ time                                 : int  8 8 8 8 8 8 8 8 8 8 ...\n $ tissue                               : chr  \"Cerebellum\" \"Cerebellum\" \"Cerebellum\" \"Cerebellum\" ...\n $ mouse                                : int  14 14 14 14 14 14 14 14 14 14 ...\n $ ENTREZID                             : int  109900 11815 56448 19144 80891 20528 97827 118454 18823 14696 ...\n $ product                              : chr  \"argininosuccinate lyase, transcript variant X1\" \"apolipoprotein D, transcript variant 3\" \"cytochrome P450, family 2, subfamily d, polypeptide 22, transcript variant 2\" \"kallikrein related-peptidase 6, transcript variant 2\" ...\n $ ensembl_gene_id                      : chr  \"ENSMUSG00000025533\" \"ENSMUSG00000022548\" \"ENSMUSG00000061740\" \"ENSMUSG00000050063\" ...\n $ external_synonym                     : chr  \"2510006M18Rik\" NA \"2D22\" \"Bssp\" ...\n $ chromosome_name                      : chr  \"5\" \"16\" \"15\" \"7\" ...\n $ gene_biotype                         : chr  \"protein_coding\" \"protein_coding\" \"protein_coding\" \"protein_coding\" ...\n $ phenotype_description                : chr  \"abnormal circulating amino acid level\" \"abnormal lipid homeostasis\" \"abnormal skin morphology\" \"abnormal cytokine level\" ...\n $ hsapiens_homolog_associated_gene_name: chr  \"ASL\" \"APOD\" \"CYP2D6\" \"KLK6\" ...\n\n\n\n\nWe already saw how the functions head() and str() can be useful to check the content and the structure of a data frame. Here is a non-exhaustive list of functions to get a sense of the content/structure of the data. Let’s try them out!\nSize:\n\ndim(rna) - returns a vector with the number of rows as the first element, and the number of columns as the second element (the dimensions of the object).\nnrow(rna) - returns the number of rows.\nncol(rna) - returns the number of columns.\n\nContent:\n\nhead(rna) - shows the first 6 rows.\ntail(rna) - shows the last 6 rows.\n\nNames:\n\nnames(rna) - returns the column names (synonym of colnames() for data.frame objects).\nrownames(rna) - returns the row names.\n\nSummary:\n\nstr(rna) - structure of the object and information about the class, length and content of each column.\nsummary(rna) - summary statistics for each column.\n\n\n\n\n\n\n\nNote\n\n\n\nMost of these functions are “generic”, they can be used on other types of objects besides data.frame.\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nBased on the output of str(rna), can you answer the following questions?\n\nWhat is the class of the object rna?\nHow many rows and how many columns are in this object?\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nclass: data frame\nhow many rows: 66465, how many columns: 11\n\n\n\n\n\n\n\nOur rna data frame has rows and columns (it has 2 dimensions); if we want to extract some specific data from it, we need to specify the “coordinates” we want. Row numbers come first, followed by column numbers. However, note that different ways of specifying these coordinates lead to results with different classes.\n\n# first element in the first column of the data frame (as a vector)\nrna[1, 1]\n# first element in the 6th column (as a vector)\nrna[1, 6]\n# first column of the data frame (as a vector)\nrna[, 1]\n# first column of the data frame (as a data.frame)\nrna[1]\n# first three elements in the 7th column (as a vector)\nrna[1:3, 7]\n# the 3rd row of the data frame (as a data.frame)\nrna[3, ]\n# equivalent to head_rna &lt;- head(rna)\nhead_rna &lt;- rna[1:6, ]\nhead_rna\n\n: is a special function that creates numeric vectors of integers in increasing or decreasing order, test 1:10 and 10:1 for instance. See section @ref(sec:genvec) for details.\nYou can also exclude certain indices of a data frame using the “-” sign:\n\nrna[, -1]          ## The whole data frame, except the first column\nrna[-c(7:66465), ] ## Equivalent to head(rna)\n\nData frames can be subsetted by calling indices (as shown previously), but also by calling their column names directly:\n\nrna[\"gene\"]       # Result is a data.frame\nrna[, \"gene\"]     # Result is a vector\nrna[[\"gene\"]]     # Result is a vector\nrna$gene          # Result is a vector\n\nIn RStudio, you can use the autocompletion feature to get the full and correct names of the columns.\n\n\n\n\n\n\nChallenge\n\n\n\n\nCreate a data.frame (rna_200) containing only the data in row 200 of the rna dataset.\nNotice how nrow() gave you the number of rows in a data.frame?\n\n\nUse that number to pull out just that last row in the initial rna data frame.\nCompare that with what you see as the last row using tail() to make sure it’s meeting expectations.\nPull out that last row using nrow() instead of the row number.\nCreate a new data frame (rna_last) from that last row.\n\n\nUse nrow() to extract the row that is in the middle of the rna dataframe. Store the content of this row in an object named rna_middle.\nCombine nrow() with the - notation above to reproduce the behavior of head(rna), keeping just the first through 6th rows of the rna dataset.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n## 1.\nrna_200 &lt;- rna[200, ]\n## 2.\n## Saving `n_rows` to improve readability and reduce duplication\nn_rows &lt;- nrow(rna)\nrna_last &lt;- rna[n_rows, ]\n## 3.\nrna_middle &lt;- rna[n_rows / 2, ]\n## 4.\nrna_head &lt;- rna[-(7:n_rows), ]\n\n\n\n\n\n\n\n\nFactors represent categorical data. They are stored as integers associated with labels and they can be ordered or unordered. While factors look (and often behave) like character vectors, they are actually treated as integer vectors by R. So you need to be very careful when treating them as strings.\nOnce created, factors can only contain a pre-defined set of values, known as levels. By default, R always sorts levels in alphabetical order. For instance, if you have a factor with 2 levels:\n\nsex &lt;- factor(c(\"male\", \"female\", \"female\", \"male\", \"female\"))\n\nR will assign 1 to the level \"female\" and 2 to the level \"male\" (because f comes before m, even though the first element in this vector is \"male\"). You can see this by using the function levels() and you can find the number of levels using nlevels():\n\nlevels(sex)\n\n[1] \"female\" \"male\"  \n\n\n\nnlevels(sex)\n\n[1] 2\n\n\nSometimes, the order of the factors does not matter, other times you might want to specify the order because it is meaningful (e.g., “low”, “medium”, “high”), it improves your visualization, or it is required by a particular type of analysis. Here, one way to reorder our levels in the sex vector would be:\n\nsex ## current order\n\n[1] male   female female male   female\nLevels: female male\n\n\n\nsex &lt;- factor(sex, levels = c(\"male\", \"female\"))\nsex ## after re-ordering\n\n[1] male   female female male   female\nLevels: male female\n\n\nIn R’s memory, these factors are represented by integers (1, 2, 3), but are more informative than integers because factors are self describing: \"female\", \"male\" is more descriptive than 1, 2. Which one is “male”? You wouldn’t be able to tell just from the integer data. Factors, on the other hand, have this information built-in. It is particularly helpful when there are many levels (like the gene biotype in our example dataset).\nWhen your data is stored as a factor, you can use the plot() function to get a quick glance at the number of observations represented by each factor level. Let’s look at the number of males and females in our data.\n\nplot(sex)\n\n\n\n\n\n\n\n\n\n\nIf you need to convert a factor to a character vector, you use as.character(x).\n\nas.character(sex)\n\n[1] \"male\"   \"female\" \"female\" \"male\"   \"female\"\n\n\n\n\n\nIf we want to rename these factor, it is sufficient to change its levels:\n\nlevels(sex)\n\n[1] \"male\"   \"female\"\n\n\n\nlevels(sex) &lt;- c(\"M\", \"F\")\nsex\n\n[1] M F F M F\nLevels: M F\n\n\n\nplot(sex)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nRename “F” and “M” to “Female” and “Male” respectively.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nlevels(sex)\n\n[1] \"M\" \"F\"\n\n\n\nlevels(sex) &lt;- c(\"Male\", \"Female\")\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWe have seen how data frames are created when using read.csv(), but they can also be created by hand with the data.frame() function. There are a few mistakes in this hand-crafted data.frame. Can you spot and fix them? Don’t hesitate to experiment!\n\nanimal_data &lt;- data.frame(\n       animal = c(dog, cat, sea cucumber, sea urchin),\n       feel = c(\"furry\", \"squishy\", \"spiny\"),\n       weight = c(45, 8 1.1, 0.8))\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nmissing quotations around the names of the animals\nmissing one entry in the “feel” column (probably for one of the furry animals)\nmissing one comma in the weight column\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nCan you predict the class for each of the columns in the following example?\nCheck your guesses using str(country_climate):\n\nAre they what you expected? Why? Why not?\nTry again by adding stringsAsFactors = TRUE after the last variable when creating the data frame. What is happening now? stringsAsFactors can also be set when reading text-based spreadsheets into R using read.csv().\n\n\ncountry_climate &lt;- data.frame(\n       country = c(\"Canada\", \"Panama\", \"South Africa\", \"Australia\"),\n       climate = c(\"cold\", \"hot\", \"temperate\", \"hot/temperate\"),\n       temperature = c(10, 30, 18, \"15\"),\n       northern_hemisphere = c(TRUE, TRUE, FALSE, \"FALSE\"),\n       has_kangaroo = c(FALSE, FALSE, FALSE, 1)\n       )\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ncountry_climate &lt;- data.frame(\n       country = c(\"Canada\", \"Panama\", \"South Africa\", \"Australia\"),\n       climate = c(\"cold\", \"hot\", \"temperate\", \"hot/temperate\"),\n       temperature = c(10, 30, 18, \"15\"),\n       northern_hemisphere = c(TRUE, TRUE, FALSE, \"FALSE\"),\n       has_kangaroo = c(FALSE, FALSE, FALSE, 1)\n       )\nstr(country_climate)\n\n'data.frame':   4 obs. of  5 variables:\n $ country            : chr  \"Canada\" \"Panama\" \"South Africa\" \"Australia\"\n $ climate            : chr  \"cold\" \"hot\" \"temperate\" \"hot/temperate\"\n $ temperature        : chr  \"10\" \"30\" \"18\" \"15\"\n $ northern_hemisphere: chr  \"TRUE\" \"TRUE\" \"FALSE\" \"FALSE\"\n $ has_kangaroo       : num  0 0 0 1\n\n\n\n\n\nThe automatic conversion of data type is sometimes a blessing, sometimes an annoyance. Be aware that it exists, learn the rules, and double check that data you import in R are of the correct type within your data frame. If not, use it to your advantage to detect mistakes that might have been introduced during data entry (a letter in a column that should only contain numbers for instance).\nLearn more in this RStudio tutorial.\n\n\n\n\nBefore proceeding, now that we have learnt about data frames, let’s recap package installation and learn about a new data type, namely the matrix. Like a data.frame, a matrix has two dimensions, rows and columns. But the major difference is that all cells in a matrix must be of the same type: numeric, character, logical, … In that respect, matrices are closer to a vector than a data.frame.\nThe default constructor for a matrix is matrix. It takes a vector of values to populate the matrix and the number of row and/or columns1. The values are sorted along the columns, as illustrated below.\n\nm &lt;- matrix(1:9, ncol = 3, nrow = 3)\n\n\n\n\n\n\n\nChallenge\n\n\n\nUsing the function installed.packages(), create a character matrix containing the information about all packages currently installed on your computer. Explore it.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n## create the matrix\nip &lt;- installed.packages()\nhead(ip)\n\n              Package        \nabind         \"abind\"        \nannotate      \"annotate\"     \nAnnotationDbi \"AnnotationDbi\"\nAnnotationHub \"AnnotationHub\"\nAsioHeaders   \"AsioHeaders\"  \naskpass       \"askpass\"      \n              LibPath                                                               \nabind         \"/Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\"\nannotate      \"/Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\"\nAnnotationDbi \"/Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\"\nAnnotationHub \"/Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\"\nAsioHeaders   \"/Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\"\naskpass       \"/Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\"\n              Version    Priority\nabind         \"1.4-5\"    NA      \nannotate      \"1.80.0\"   NA      \nAnnotationDbi \"1.64.1\"   NA      \nAnnotationHub \"3.10.0\"   NA      \nAsioHeaders   \"1.22.1-2\" NA      \naskpass       \"1.2.0\"    NA      \n              Depends                                                                                 \nabind         \"R (&gt;= 1.5.0)\"                                                                          \nannotate      \"R (&gt;= 2.10), AnnotationDbi (&gt;= 1.27.5), XML\"                                           \nAnnotationDbi \"R (&gt;= 2.7.0), methods, stats4, BiocGenerics (&gt;= 0.29.2),\\nBiobase (&gt;= 1.17.0), IRanges\"\nAnnotationHub \"BiocGenerics (&gt;= 0.15.10), BiocFileCache (&gt;= 1.5.1)\"                                   \nAsioHeaders   NA                                                                                      \naskpass       NA                                                                                      \n              Imports                                                                                                                                                           \nabind         \"methods, utils\"                                                                                                                                                  \nannotate      \"Biobase, DBI, xtable, graphics, utils, stats, methods,\\nBiocGenerics (&gt;= 0.13.8), httr\"                                                                          \nAnnotationDbi \"DBI, RSQLite, S4Vectors (&gt;= 0.9.25), stats, KEGGREST\"                                                                                                            \nAnnotationHub \"utils, methods, grDevices, RSQLite, BiocManager, BiocVersion,\\ncurl, rappdirs, AnnotationDbi (&gt;= 1.31.19), S4Vectors, httr,\\nyaml, dplyr, interactiveDisplayBase\"\nAsioHeaders   NA                                                                                                                                                                \naskpass       \"sys (&gt;= 2.1)\"                                                                                                                                                    \n              LinkingTo\nabind         NA       \nannotate      NA       \nAnnotationDbi NA       \nAnnotationHub NA       \nAsioHeaders   NA       \naskpass       NA       \n              Suggests                                                                                                                                                                                                                                                                               \nabind         NA                                                                                                                                                                                                                                                                                     \nannotate      \"hgu95av2.db, genefilter, Biostrings (&gt;= 2.25.10), IRanges,\\nrae230a.db, rae230aprobe, tkWidgets, GO.db, org.Hs.eg.db,\\norg.Mm.eg.db, humanCHRLOC, Rgraphviz, RUnit,\"                                                                                                                  \nAnnotationDbi \"utils, hgu95av2.db, GO.db, org.Sc.sgd.db, org.At.tair.db,\\nRUnit, TxDb.Hsapiens.UCSC.hg19.knownGene, org.Hs.eg.db,\\nreactome.db, AnnotationForge, graph, EnsDb.Hsapiens.v75,\\nBiocStyle, knitr\"                                                                                       \nAnnotationHub \"IRanges, GenomicRanges, GenomeInfoDb, VariantAnnotation,\\nRsamtools, rtracklayer, BiocStyle, knitr, AnnotationForge,\\nrBiopaxParser, RUnit, GenomicFeatures, MSnbase, mzR,\\nBiostrings, CompoundDb, keras, ensembldb, SummarizedExperiment,\\nExperimentHub, gdsfmt, rmarkdown, HubPub\"\nAsioHeaders   NA                                                                                                                                                                                                                                                                                     \naskpass       \"testthat\"                                                                                                                                                                                                                                                                             \n              Enhances            License              License_is_FOSS\nabind         NA                  \"LGPL (&gt;= 2)\"        NA             \nannotate      NA                  \"Artistic-2.0\"       NA             \nAnnotationDbi NA                  \"Artistic-2.0\"       NA             \nAnnotationHub \"AnnotationHubData\" \"Artistic-2.0\"       NA             \nAsioHeaders   NA                  \"BSL-1.0\"            NA             \naskpass       NA                  \"MIT + file LICENSE\" NA             \n              License_restricts_use OS_type MD5sum NeedsCompilation Built  \nabind         NA                    NA      NA     \"no\"             \"4.3.0\"\nannotate      NA                    NA      NA     \"no\"             \"4.3.1\"\nAnnotationDbi NA                    NA      NA     \"no\"             \"4.3.1\"\nAnnotationHub NA                    NA      NA     \"yes\"            \"4.3.1\"\nAsioHeaders   NA                    NA      NA     \"no\"             \"4.3.0\"\naskpass       NA                    NA      NA     \"yes\"            \"4.3.0\"\n\n## try also View(ip)\n## number of package\nnrow(ip)\n\n[1] 391\n\n## names of all installed packages\nrownames(ip)\n\n  [1] \"abind\"                  \"annotate\"               \"AnnotationDbi\"         \n  [4] \"AnnotationHub\"          \"AsioHeaders\"            \"askpass\"               \n  [7] \"backports\"              \"base\"                   \"base64enc\"             \n [10] \"beachmat\"               \"beeswarm\"               \"BH\"                    \n [13] \"Biobase\"                \"BiocFileCache\"          \"BiocGenerics\"          \n [16] \"BiocIO\"                 \"BiocManager\"            \"BiocParallel\"          \n [19] \"BiocStyle\"              \"BiocVersion\"            \"biomaRt\"               \n [22] \"Biostrings\"             \"bit\"                    \"bit64\"                 \n [25] \"bitops\"                 \"blob\"                   \"bookdown\"              \n [28] \"boot\"                   \"BPCells\"                \"brew\"                  \n [31] \"brio\"                   \"broom\"                  \"bslib\"                 \n [34] \"cachem\"                 \"callr\"                  \"caTools\"               \n [37] \"celldex\"                \"cellranger\"             \"checkmate\"             \n [40] \"circlize\"               \"class\"                  \"cli\"                   \n [43] \"clipr\"                  \"clock\"                  \"cluster\"               \n [46] \"codetools\"              \"colorout\"               \"colorspace\"            \n [49] \"commonmark\"             \"compiler\"               \"ComplexUpset\"          \n [52] \"conflicted\"             \"countdown\"              \"cowplot\"               \n [55] \"cpp11\"                  \"crayon\"                 \"credentials\"           \n [58] \"crosstalk\"              \"curl\"                   \"data.table\"            \n [61] \"datasets\"               \"DBI\"                    \"dbplyr\"                \n [64] \"DelayedArray\"           \"DelayedMatrixStats\"     \"deldir\"                \n [67] \"desc\"                   \"devtools\"               \"diagram\"               \n [70] \"dials\"                  \"DiceDesign\"             \"diffobj\"               \n [73] \"digest\"                 \"doFuture\"               \"dotCall64\"             \n [76] \"downlit\"                \"downloader\"             \"dplyr\"                 \n [79] \"dqrng\"                  \"DT\"                     \"dtplyr\"                \n [82] \"edgeR\"                  \"ellipsis\"               \"EnhancedVolcano\"       \n [85] \"evaluate\"               \"ExperimentHub\"          \"fansi\"                 \n [88] \"farver\"                 \"fastDummies\"            \"fastmap\"               \n [91] \"filelock\"               \"fitdistrplus\"           \"FNN\"                   \n [94] \"fontawesome\"            \"forcats\"                \"foreach\"               \n [97] \"foreign\"                \"formatR\"                \"Formula\"               \n[100] \"fs\"                     \"furrr\"                  \"futile.logger\"         \n[103] \"futile.options\"         \"future\"                 \"future.apply\"          \n[106] \"gargle\"                 \"genefilter\"             \"generics\"              \n[109] \"GeneSelectR\"            \"GenomeInfoDb\"           \"GenomeInfoDbData\"      \n[112] \"GenomicAlignments\"      \"GenomicRanges\"          \"gert\"                  \n[115] \"ggcorrplot\"             \"ggplot2\"                \"ggplot2movies\"         \n[118] \"ggrepel\"                \"ggridges\"               \"gh\"                    \n[121] \"gitcreds\"               \"glmGamPoi\"              \"glmnet\"                \n[124] \"GlobalOptions\"          \"globals\"                \"glue\"                  \n[127] \"goftest\"                \"googledrive\"            \"googlesheets4\"         \n[130] \"gower\"                  \"GPfit\"                  \"gplots\"                \n[133] \"graphics\"               \"grDevices\"              \"grid\"                  \n[136] \"gridExtra\"              \"gtable\"                 \"gtools\"                \n[139] \"hardhat\"                \"haven\"                  \"HDF5Array\"             \n[142] \"here\"                   \"hexbin\"                 \"highr\"                 \n[145] \"Hmisc\"                  \"hms\"                    \"htmlTable\"             \n[148] \"htmltools\"              \"htmlwidgets\"            \"httpuv\"                \n[151] \"httr\"                   \"httr2\"                  \"ica\"                   \n[154] \"ids\"                    \"igraph\"                 \"infer\"                 \n[157] \"ini\"                    \"interactiveDisplayBase\" \"interp\"                \n[160] \"ipred\"                  \"IRanges\"                \"irlba\"                 \n[163] \"isoband\"                \"iterators\"              \"jaffelab\"              \n[166] \"jpeg\"                   \"jquerylib\"              \"jsonlite\"              \n[169] \"KEGGREST\"               \"kernlab\"                \"KernSmooth\"            \n[172] \"knitr\"                  \"labeling\"               \"lambda.r\"              \n[175] \"later\"                  \"lattice\"                \"latticeExtra\"          \n[178] \"lava\"                   \"lazyeval\"               \"leiden\"                \n[181] \"lhs\"                    \"lifecycle\"              \"limma\"                 \n[184] \"listenv\"                \"lmtest\"                 \"locfit\"                \n[187] \"lubridate\"              \"magrittr\"               \"MASS\"                  \n[190] \"Matrix\"                 \"MatrixGenerics\"         \"matrixStats\"           \n[193] \"memoise\"                \"methods\"                \"mgcv\"                  \n[196] \"mime\"                   \"miniUI\"                 \"modeldata\"             \n[199] \"modelenv\"               \"modelr\"                 \"munsell\"               \n[202] \"nlme\"                   \"nnet\"                   \"numDeriv\"              \n[205] \"openssl\"                \"org.Hs.eg.db\"           \"packrat\"               \n[208] \"pagedown\"               \"pak\"                    \"parallel\"              \n[211] \"parallelly\"             \"parsnip\"                \"patchwork\"             \n[214] \"pbapply\"                \"pheatmap\"               \"pillar\"                \n[217] \"pkgbuild\"               \"pkgconfig\"              \"pkgdown\"               \n[220] \"pkgload\"                \"PKI\"                    \"plogr\"                 \n[223] \"plotly\"                 \"plotwidgets\"            \"plumber\"               \n[226] \"plyr\"                   \"png\"                    \"polyclip\"              \n[229] \"postcards\"              \"praise\"                 \"presto\"                \n[232] \"prettyunits\"            \"prismatic\"              \"processx\"              \n[235] \"prodlim\"                \"profvis\"                \"progress\"              \n[238] \"progressr\"              \"promises\"               \"prompt\"                \n[241] \"ps\"                     \"purrr\"                  \"qsvaR\"                 \n[244] \"R.methodsS3\"            \"R.oo\"                   \"R.utils\"               \n[247] \"R6\"                     \"rafalib\"                \"ragg\"                  \n[250] \"RANN\"                   \"rappdirs\"               \"rcmdcheck\"             \n[253] \"RColorBrewer\"           \"Rcpp\"                   \"RcppAnnoy\"             \n[256] \"RcppArmadillo\"          \"RcppEigen\"              \"RcppHNSW\"              \n[259] \"RcppProgress\"           \"RcppTOML\"               \"RCurl\"                 \n[262] \"readr\"                  \"readxl\"                 \"recipes\"               \n[265] \"rematch\"                \"rematch2\"               \"remotes\"               \n[268] \"renv\"                   \"reprex\"                 \"reshape2\"              \n[271] \"restfulr\"               \"reticulate\"             \"rhdf5\"                 \n[274] \"rhdf5filters\"           \"Rhdf5lib\"               \"Rhtslib\"               \n[277] \"rjson\"                  \"rlang\"                  \"rmarkdown\"             \n[280] \"ROCR\"                   \"roxygen2\"               \"rpart\"                 \n[283] \"rprojroot\"              \"rsample\"                \"Rsamtools\"             \n[286] \"rsconnect\"              \"RSpectra\"               \"RSQLite\"               \n[289] \"rstudioapi\"             \"rtracklayer\"            \"Rtsne\"                 \n[292] \"rversions\"              \"rvest\"                  \"S4Arrays\"              \n[295] \"S4Vectors\"              \"SASmixed\"               \"sass\"                  \n[298] \"scales\"                 \"scattermore\"            \"sctransform\"           \n[301] \"segmented\"              \"selectr\"                \"servr\"                 \n[304] \"sessioninfo\"            \"Seurat\"                 \"SeuratObject\"          \n[307] \"sfd\"                    \"sfsmisc\"                \"shape\"                 \n[310] \"shiny\"                  \"SingleCellExperiment\"   \"sitmo\"                 \n[313] \"slider\"                 \"snow\"                   \"sodium\"                \n[316] \"sourcetools\"            \"sp\"                     \"spam\"                  \n[319] \"SparseArray\"            \"sparseMatrixStats\"      \"spatial\"               \n[322] \"spatstat.data\"          \"spatstat.explore\"       \"spatstat.geom\"         \n[325] \"spatstat.random\"        \"spatstat.sparse\"        \"spatstat.univar\"       \n[328] \"spatstat.utils\"         \"splines\"                \"SQUAREM\"               \n[331] \"statmod\"                \"stats\"                  \"stats4\"                \n[334] \"stringi\"                \"stringr\"                \"SummarizedExperiment\"  \n[337] \"survival\"               \"sva\"                    \"swagger\"               \n[340] \"sys\"                    \"systemfonts\"            \"tagcloud\"              \n[343] \"TCGAbiolinks\"           \"TCGAbiolinksGUI.data\"   \"tcltk\"                 \n[346] \"tensor\"                 \"testthat\"               \"textshaping\"           \n[349] \"tibble\"                 \"tidymodels\"             \"tidyr\"                 \n[352] \"tidyselect\"             \"tidyverse\"              \"timechange\"            \n[355] \"timeDate\"               \"tinytex\"                \"tmod\"                  \n[358] \"tools\"                  \"tune\"                   \"tximport\"              \n[361] \"tzdb\"                   \"urlchecker\"             \"usethis\"               \n[364] \"utf8\"                   \"utils\"                  \"uuid\"                  \n[367] \"uwot\"                   \"vctrs\"                  \"viridis\"               \n[370] \"viridisLite\"            \"vroom\"                  \"waldo\"                 \n[373] \"warp\"                   \"webexercises\"           \"websocket\"             \n[376] \"webutils\"               \"whisker\"                \"withr\"                 \n[379] \"workflows\"              \"workflowsets\"           \"xfun\"                  \n[382] \"XML\"                    \"xml2\"                   \"xopen\"                 \n[385] \"xtable\"                 \"XVector\"                \"yaml\"                  \n[388] \"yardstick\"              \"zip\"                    \"zlibbioc\"              \n[391] \"zoo\"                   \n\n## type of information we have about each package\ncolnames(ip)\n\n [1] \"Package\"               \"LibPath\"               \"Version\"              \n [4] \"Priority\"              \"Depends\"               \"Imports\"              \n [7] \"LinkingTo\"             \"Suggests\"              \"Enhances\"             \n[10] \"License\"               \"License_is_FOSS\"       \"License_restricts_use\"\n[13] \"OS_type\"               \"MD5sum\"                \"NeedsCompilation\"     \n[16] \"Built\"                \n\n\n\n\n\nIt is often useful to create large random data matrices as test data. The exercise below asks you to create such a matrix with random data drawn from a normal distribution of mean 0 and standard deviation 1, which can be done with the rnorm() function.\n\n\n\n\n\n\nChallenge\n\n\n\nConstruct a matrix of dimension 1000 by 3 of normally distributed data (mean 0, standard deviation 1)\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nset.seed(123)\nm &lt;- matrix(rnorm(3000), ncol = 3)\ndim(m)\n\n[1] 1000    3\n\n\n\nhead(m)\n\n            [,1]        [,2]       [,3]\n[1,] -0.56047565 -0.99579872 -0.5116037\n[2,] -0.23017749 -1.03995504  0.2369379\n[3,]  1.55870831 -0.01798024 -0.5415892\n[4,]  0.07050839 -0.13217513  1.2192276\n[5,]  0.12928774 -2.54934277  0.1741359\n[6,]  1.71506499  1.04057346 -0.6152683\n\n\n\n\n\n\n\n\nOne of the most common issues that new (and experienced!) R users have is converting date and time information into a variable that is appropriate and usable during analyses.\n\n\n\nDates in spreadsheets are generally stored in a single column. While this seems the most natural way to record dates, it actually is not best practice. A spreadsheet application will display the dates in a seemingly correct way (to a human observer) but how it actually handles and stores the dates may be problematic. It is often much safer to store dates with YEAR, MONTH and DAY in separate columns or as YEAR and DAY-OF-YEAR in separate columns.\nSpreadsheet programs such as LibreOffice, Microsoft Excel, OpenOffice, Gnumeric, … have different (and often incompatible) ways of encoding dates (even for the same program between versions and operating systems). Additionally, Excel can turn things that aren’t dates into dates (@Zeeberg:2004), for example names or identifiers like MAR1, DEC1, OCT4. So if you’re avoiding the date format overall, it’s easier to identify these issues.\nThe Dates as data section of the Data Carpentry lesson provides additional insights about pitfalls of dates with spreadsheets.\nWe are going to use the ymd() function from the package lubridate (which belongs to the tidyverse; learn more here). . lubridate gets installed as part of the tidyverse installation. When you load the tidyverse (library(tidyverse)), the core packages (the packages used in most data analyses) get loaded. lubridate however does not belong to the core tidyverse, so you have to load it explicitly with library(lubridate).\nStart by loading the required package:\n\nlibrary(\"lubridate\")\n\n\nAttaching package: 'lubridate'\n\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n\n\nymd() takes a vector representing year, month, and day, and converts it to a Date vector. Date is a class of data recognized by R as being a date and can be manipulated as such. The argument that the function requires is flexible, but, as a best practice, is a character vector formatted as “YYYY-MM-DD”.\nLet’s create a date object and inspect the structure:\n\nmy_date &lt;- ymd(\"2015-01-01\")\nstr(my_date)\n\n Date[1:1], format: \"2015-01-01\"\n\n\nNow let’s paste the year, month, and day separately - we get the same result:\n\n# sep indicates the character to use to separate each component\nmy_date &lt;- ymd(paste(\"2015\", \"1\", \"1\", sep = \"-\"))\nstr(my_date)\n\n Date[1:1], format: \"2015-01-01\"\n\n\nLet’s now familiarise ourselves with a typical date manipulation pipeline. The small data below has stored dates in different year, month and day columns.\n\nx &lt;- data.frame(year = c(1996, 1992, 1987, 1986, 2000, 1990, 2002, 1994, 1997, 1985),\nmonth = c(2,  3,  3, 10,  1,  8,  3,  4,  5,  5),day = c(24,  8,  1,  5,  8, 17, 13, 10, 11, 24),\nvalue = c(4,  5,  1,  9,  3,  8, 10,  2,  6,  7))\nx\n\n   year month day value\n1  1996     2  24     4\n2  1992     3   8     5\n3  1987     3   1     1\n4  1986    10   5     9\n5  2000     1   8     3\n6  1990     8  17     8\n7  2002     3  13    10\n8  1994     4  10     2\n9  1997     5  11     6\n10 1985     5  24     7\n\n\nNow we apply this function to the x dataset. We first create a character vector from the year, month, and day columns of x using paste():\n\npaste(x$year, x$month, x$day, sep = \"-\")\n\n [1] \"1996-2-24\" \"1992-3-8\"  \"1987-3-1\"  \"1986-10-5\" \"2000-1-8\"  \"1990-8-17\"\n [7] \"2002-3-13\" \"1994-4-10\" \"1997-5-11\" \"1985-5-24\"\n\n\nThis character vector can be used as the argument for ymd():\n\nymd(paste(x$year, x$month, x$day, sep = \"-\"))\n\n [1] \"1996-02-24\" \"1992-03-08\" \"1987-03-01\" \"1986-10-05\" \"2000-01-08\"\n [6] \"1990-08-17\" \"2002-03-13\" \"1994-04-10\" \"1997-05-11\" \"1985-05-24\"\n\n\nThe resulting Date vector can be added to x as a new column called date:\n\nx$date &lt;- ymd(paste(x$year, x$month, x$day, sep = \"-\"))\nstr(x) # notice the new column, with 'date' as the class\n\n'data.frame':   10 obs. of  5 variables:\n $ year : num  1996 1992 1987 1986 2000 ...\n $ month: num  2 3 3 10 1 8 3 4 5 5\n $ day  : num  24 8 1 5 8 17 13 10 11 24\n $ value: num  4 5 1 9 3 8 10 2 6 7\n $ date : Date, format: \"1996-02-24\" \"1992-03-08\" ...\n\n\nLet’s make sure everything worked correctly. One way to inspect the new column is to use summary():\n\nsummary(x$date)\n\n        Min.      1st Qu.       Median         Mean      3rd Qu.         Max. \n\"1985-05-24\" \"1988-01-11\" \"1993-03-24\" \"1993-03-18\" \"1997-01-20\" \"2002-03-13\" \n\n\nNote that ymd() expects to have the year, month and day, in that order. If you have for instance day, month and year, you would need dmy().\n\ndmy(paste(x$day, x$month, x$year, sep = \"-\"))\n\n [1] \"1996-02-24\" \"1992-03-08\" \"1987-03-01\" \"1986-10-05\" \"2000-01-08\"\n [6] \"1990-08-17\" \"2002-03-13\" \"1994-04-10\" \"1997-05-11\" \"1985-05-24\"\n\n\nlubdridate has many functions to address all date variations.\n\n\n\n\n\n\nNote\n\n\n\nSummary of R objects\nSo far, we have seen several types of R object varying in the number of dimensions and whether they could store a single or multiple data types:\n\nvector: one dimension (they have a length), single type of data.\nmatrix: two dimensions, single type of data.\ndata.frame: two dimensions, one type per column.\n\n\n\n\n\n\nA data type that we haven’t seen yet, but that is useful to know, and follows from the summary that we have just seen are lists:\n\nlist: one dimension, every item can be of a different data type.\n\nBelow, let’s create a list containing a vector of numbers, characters, a matrix, a dataframe and another list:\n\nl &lt;- list(1:10, ## numeric\n          letters, ## character\n          installed.packages(), ## a matrix\n          cars, ## a data.frame\n          list(1, 2, 3)) ## a list\nlength(l)\n\n[1] 5\n\n\n\nstr(l)\n\nList of 5\n $ : int [1:10] 1 2 3 4 5 6 7 8 9 10\n $ : chr [1:26] \"a\" \"b\" \"c\" \"d\" ...\n $ : chr [1:391, 1:16] \"abind\" \"annotate\" \"AnnotationDbi\" \"AnnotationHub\" ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : chr [1:391] \"abind\" \"annotate\" \"AnnotationDbi\" \"AnnotationHub\" ...\n  .. ..$ : chr [1:16] \"Package\" \"LibPath\" \"Version\" \"Priority\" ...\n $ :'data.frame':   50 obs. of  2 variables:\n  ..$ speed: num [1:50] 4 4 7 7 8 9 10 10 10 11 ...\n  ..$ dist : num [1:50] 2 10 4 22 16 10 18 26 34 17 ...\n $ :List of 3\n  ..$ : num 1\n  ..$ : num 2\n  ..$ : num 3\n\n\nList subsetting is done using [] to subset a new sub-list or [[]] to extract a single element of that list (using indices or names, if the list is named).\n\nl[[1]] ## first element\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\nl[1:2] ## a list of length 2\n\n[[1]]\n [1]  1  2  3  4  5  6  7  8  9 10\n\n[[2]]\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\n\nl[1]   ## a list of length 1\n\n[[1]]\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\n\n\nWe have seen how to read a text-based spreadsheet into R using the read.table family of functions. To export a data.frame to a text-based spreadsheet, we can use the write.table set of functions (write.csv, write.delim, …). They all take the variable to be exported and the file to be exported to. For example, to export the rna data to the my_rna.csv file in the data_output directory, we would execute:\n\ndir.create(here(\"data_output\"))\n\nWarning in dir.create(here(\"data_output\")):\n'/Users/hediatnani/Documents/bioc_intro/data_output' already exists\n\nwrite.csv(rna, file = here(\"data_output/my_rna.csv\"))\n\nThis new csv file can now be shared with other collaborators who aren’t familiar with R. Note that even though there are commas in some of the fields in the data.frame (see for example the “product” column), R will by default surround each field with quotes, and thus we will be able to read it back into R correctly, despite also using commas as column separators."
  },
  {
    "objectID": "bioc_intro_dataVisualization_solutions.html",
    "href": "bioc_intro_dataVisualization_solutions.html",
    "title": "Data Visualization",
    "section": "",
    "text": "We start by loading the required packages. ggplot2 is included in the tidyverse package.\n\nlibrary(\"tidyverse\")\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nIf not still in the workspace, load the data we saved in the previous lesson.\n\nrna &lt;- read.csv(\"data/rnaseq.csv\")\n\nThe Data Visualization Cheat Sheet will cover the basics and more advanced features of ggplot2 and will help, in addition to serve as a reminder, getting an overview of the many data representations available in the package. The following video tutorials (part 1 and 2) by Thomas Lin Pedersen are also very instructive.\n\n\nggplot2 is a plotting package that makes it simple to create complex plots from data in a data frame. It provides a more programmatic interface for specifying what variables to plot, how they are displayed, and general visual properties. The theoretical foundation that supports the ggplot2 is the Grammar of Graphics (@Wilkinson:2005). Using this approach, we only need minimal changes if the underlying data change or if we decide to change from a bar plot to a scatterplot. This helps in creating publication quality plots with minimal amounts of adjustments and tweaking.\nThere is a book about ggplot2 (@ggplot2book) that provides a good overview, but it is outdated. The 3rd edition is in preparation and will be freely available online. The ggplot2 webpage (https://ggplot2.tidyverse.org) provides ample documentation.\nggplot2 functions like data in the ‘long’ format, i.e., a column for every dimension, and a row for every observation. Well-structured data will save you lots of time when making figures with ggplot2.\nggplot graphics are built step by step by adding new elements. Adding layers in this fashion allows for extensive flexibility and customization of plots.\nThe idea behind the Grammar of Graphics it is that you can build every graph from the same 3 components:\n(1) a data set, (2) a coordinate system, and (3) geoms — i.e. visual marks that represent data points 1.\nTo build a ggplot, we will use the following basic template that can be used for different types of plots:\n\nggplot(data = &lt;DATA&gt;, mapping = aes(&lt;MAPPINGS&gt;)) +  &lt;GEOM_FUNCTION&gt;()\n\n\nuse the ggplot() function and bind the plot to a specific data frame using the data argument\n\nggplot(data = rna)\n\n\n\n\n\n\n\n\ndefine a mapping (using the aesthetic (aes) function), by selecting the variables to be plotted and specifying how to present them in the graph, e.g. as x/y positions or characteristics such as size, shape, color, etc.\n\nggplot(data = rna, mapping = aes(x = expression))\n\n\n\n\n\n\n\n\nadd ‘geoms’ - geometries, or graphical representations of the data in the plot (points, lines, bars). ggplot2 offers many different geoms; we will use some common ones today, including:\n\n* `geom_point()` for scatter plots, dot plots, etc.\n* `geom_histogram()` for histograms\n* `geom_boxplot()` for, well, boxplots!\n* `geom_line()` for trend lines, time series, etc.\n\n\nTo add a geom(etry) to the plot use the + operator. Let’s use geom_histogram() first:\n\nggplot(data = rna, mapping = aes(x = expression)) +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nThe + in the ggplot2 package is particularly useful because it allows you to modify existing ggplot objects. This means you can easily set up plot templates and conveniently explore different types of plots, so the above plot can also be generated with code like this:\n\n# Assign plot to a variable\nrna_plot &lt;- ggplot(data = rna,\nmapping = aes(x = expression))\n\n# Draw the plot\nrna_plot + geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nYou have probably noticed an automatic message that appears when drawing the histogram:\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\nChange the arguments bins or binwidth of geom_histogram() to change the number or width of the bins.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# change bins\nggplot(rna, aes(x = expression)) +\n    geom_histogram(bins = 15) \n\n\n\n\n\n\n\n\n\n# change binwidth\nggplot(rna, aes(x = expression)) +\n    geom_histogram(binwidth = 2000)\n\n\n\n\n\n\n\n\n\n\n\nWe can observe here that the data are skewed to the right. We can apply log2 transformation to have a more symmetric distribution. Note that we add here a small constant value (+1) to avoid having -Inf values returned for expression values equal to 0.\n\nrna &lt;- rna %&gt;%\n  mutate(expression_log = log2(expression + 1))\n\nIf we now draw the histogram of the log2-transformed expressions, the distribution is indeed closer to a normal distribution.\n\nggplot(rna, aes(x = expression_log)) + geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nFrom now on we will work on the log-transformed expression values.\n\n\n\n\n\n\nChallenge\n\n\n\nAnother way to visualize this transformation is to consider the scale of the observations. For example, it may be worth changing the scale of the axis to better distribute the observations in the space of the plot. Changing the scale of the axes is done similarly to adding/modifying other components (i.e., by incrementally adding commands). Try making this modification:\n\nRepresent the un-transformed expression on the log10 scale; see scale_x_log10(). Compare it with the previous graph. Why do you now have warning messages appearing?\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nggplot(data = rna,mapping = aes(x = expression))+\n  geom_histogram() +\n  scale_x_log10()\n\nWarning in scale_x_log10(): log-10 transformation introduced infinite values.\n\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nWarning: Removed 507 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNotes\n\nAnything you put in the ggplot() function can be seen by any geom layers that you add (i.e., these are global plot settings). This includes the x- and y-axis mapping you set up in aes().\nYou can also specify mappings for a given geom independently of the mappings defined globally in the ggplot() function.\n\nThe + sign used to add new layers must be placed at the end of the line containing the previous layer. If, instead, the + sign is added at the beginning of the line containing the new layer, ggplot2 will not add the new layer and will return an error message.\n\n\n\n# This is the correct syntax for adding layers\nrna_plot +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n# This will not add the new layer and will return an error message\nrna_plot + \n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\n\n\nWe will now draw a scatter plot with two continuous variables and the geom_point() function. This graph will represent the log2 fold changes of expression comparing time 8 versus time 0, and time 4 versus time 0. To this end, we first need to compute the means of the log-transformed expression values by gene and time, then the log fold changes by subtracting the mean log expressions between time 8 and time 0 and between time 4 and time 0. Note that we also include here the gene biotype that we will use later on to represent the genes. We will save the fold changes in a new data frame called rna_fc.\n\nrna_fc &lt;- rna %&gt;% select(gene, time,\n                         gene_biotype, expression_log) %&gt;%\n  group_by(gene, time, gene_biotype) %&gt;%\n  summarize(mean_exp = mean(expression_log)) %&gt;%\n  pivot_wider(names_from = time,\n              values_from = mean_exp) %&gt;%\n  mutate(time_8_vs_0 = `8` - `0`, time_4_vs_0 = `4` - `0`)\n\n`summarise()` has grouped output by 'gene', 'time'. You can override using the\n`.groups` argument.\n\n\nWe can then build a ggplot with the newly created dataset rna_fc. Building plots with ggplot2 is typically an iterative process. We start by defining the dataset we’ll use, lay out the axes, and choose a geom:\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +\n  geom_point()\n\n\n\n\n\n\n\n\nThen, we start modifying this plot to extract more information from it. For instance, we can add transparency (alpha) to avoid overplotting:\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +\n  geom_point(alpha = 0.3)\n\n\n\n\n\n\n\n\nWe can also add colors for all the points:\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +\n  geom_point(alpha = 0.3, color = \"blue\")\n\n\n\n\n\n\n\n\nOr to color each gene in the plot differently, you could use a vector as an input to the argument color. ggplot2 will provide a different color corresponding to different values in the vector. Here is an example where we color with gene_biotype:\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +\n  geom_point(alpha = 0.3, aes(color = gene_biotype))\n\n\n\n\n\n\n\n\nWe can also specify the colors directly inside the mapping provided in the ggplot() function. This will be seen by any geom layers and the mapping will be determined by the x- and y-axis set up in aes().\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0,\n                                color = gene_biotype)) +\n  geom_point(alpha = 0.3)\n\n\n\n\n\n\n\n\nFinally, we could also add a diagonal line with the geom_abline() function:\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0,\n                                color = gene_biotype)) +\n  geom_point(alpha = 0.3) +\n  geom_abline(intercept = 0)\n\n\n\n\n\n\n\n\nNotice that we can change the geom layer from geom_point to geom_jitter and colors will still be determined by gene_biotype.\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0,\n                                color = gene_biotype)) +\n  geom_jitter(alpha = 0.3) +\n  geom_abline(intercept = 0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nScatter plots can be useful exploratory tools for small datasets. For data sets with large numbers of observations, such as the rna_fc data set, overplotting of points can be a limitation of scatter plots. One strategy for handling such settings is to use hexagonal binning of observations. The plot space is tessellated into hexagons. Each hexagon is assigned a color based on the number of observations that fall within its boundaries.\n\nTo use hexagonal binning in ggplot2, first install the R package hexbin from CRAN and load it.\nThen use the geom_hex() function to produce the hexbin figure.\nWhat are the relative strengths and weaknesses of a hexagonal bin plot compared to a scatter plot? Examine the above scatter plot and compare it with the hexagonal bin plot that you created.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ninstall.packages(\"hexbin\")\n\n\nThe downloaded binary packages are in\n    /var/folders/6v/qms_hkh14rqbc_q9c29yjk3m0000gn/T//RtmpnGCs3W/downloaded_packages\n\n\n\nlibrary(\"hexbin\")\n\nWarning: package 'hexbin' was built under R version 4.3.3\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +\n  geom_hex() +\n  geom_abline(intercept = 0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nUse what you just learned to create a scatter plot of expression_log over sample from the rna dataset with the time showing in different colors. Is this a good way to show this type of data?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nggplot(data = rna, mapping = aes(y = expression_log, x = sample)) +\n    geom_point(aes(color = time))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can use boxplots to visualize the distribution of gene expressions within each sample:\n\nggplot(data = rna,\n  mapping = aes(y = expression_log, x = sample)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nBy adding points to boxplot, we can have a better idea of the number of measurements and of their distribution:\n\nggplot(data = rna,\n  mapping = aes(y = expression_log, x = sample)) +\n  geom_jitter(alpha = 0.2, color = \"tomato\") +\n  geom_boxplot(alpha = 0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nNote how the boxplot layer is in front of the jitter layer? What do you need to change in the code to put the boxplot below the points?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nWe should switch the order of these two geoms:\n\nggplot(data = rna,\nmapping = aes(y = expression_log, x = sample)) +\n  geom_boxplot(alpha = 0) +\n  geom_jitter(alpha = 0.2, color = \"tomato\")\n\n\n\n\n\n\n\n\n\n\n\nYou may notice that the values on the x-axis are still not properly readable. Let’s change the orientation of the labels and adjust them vertically and horizontally so they don’t overlap. You can use a 90-degree angle, or experiment to find the appropriate angle for diagonally oriented labels:\n\nggplot(data = rna,\n    mapping = aes(y = expression_log, x = sample)) +\n  geom_jitter(alpha = 0.2, color = \"tomato\") +\n  geom_boxplot(alpha = 0) +\n  theme(axis.text.x = element_text(angle = 90,  hjust = 0.5, vjust = 0.5))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nAdd color to the data points on your boxplot according to the duration of the infection (time).\nHint: Check the class for time. Consider changing the class of time from integer to factor directly in the ggplot mapping. Why does this change how R makes the graph?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# time as integer\nggplot(data = rna,\nmapping = aes(y = expression_log,x = sample)) +\n  geom_jitter(alpha = 0.2, aes(color = time)) +\n  geom_boxplot(alpha = 0) +\n  theme(axis.text.x = element_text(angle = 90,  hjust = 0.5, vjust = 0.5))\n\n\n\n\n\n\n\n\n\n# time as factor\nggplot(data = rna,\nmapping = aes(y = expression_log,x = sample)) +\n  geom_jitter(alpha = 0.2, aes(color = as.factor(time))) +\n  geom_boxplot(alpha = 0) +\n  theme(axis.text.x = element_text(angle = 90,  hjust = 0.5, vjust = 0.5))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nBoxplots are useful summaries, but hide the shape of the distribution. For example, if the distribution is bimodal, we would not see it in a boxplot. An alternative to the boxplot is the violin plot, where the shape (of the density of points) is drawn.\n\nReplace the box plot with a violin plot; see geom_violin(). Fill in the violins according to the time with the argument fill.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nggplot(data = rna,\nmapping = aes(y = expression_log, x = sample)) +\n  geom_violin(aes(fill = as.factor(time))) +\n  theme(axis.text.x = element_text(angle = 90,  hjust = 0.5, vjust = 0.5))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nModify the violin plot to fill in the violins by sex.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nggplot(data = rna,\n         mapping = aes(y = expression_log, x = sample)) +\n  geom_violin(aes(fill = sex)) +\n  theme(axis.text.x = element_text(angle = 90,  hjust = 0.5, vjust = 0.5))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLet’s calculate the mean expression per duration of the infection for the 10 genes having the highest log fold changes comparing time 8 versus time 0. First, we need to select the genes and create a subset of rna called sub_rna containing the 10 selected genes, then we need to group the data and calculate the mean gene expression within each group:\n\nrna_fc &lt;- rna_fc %&gt;% arrange(desc(time_8_vs_0))\n\ngenes_selected &lt;- rna_fc$gene[1:10]\n\nsub_rna &lt;- rna %&gt;%\n    filter(gene %in% genes_selected)\n\nmean_exp_by_time &lt;- sub_rna %&gt;%\n  group_by(gene,time) %&gt;%\n    summarize(mean_exp = mean(expression_log))\n\n`summarise()` has grouped output by 'gene'. You can override using the\n`.groups` argument.\n\n\n\nmean_exp_by_time\n\n# A tibble: 30 × 3\n# Groups:   gene [10]\n   gene   time mean_exp\n   &lt;chr&gt; &lt;int&gt;    &lt;dbl&gt;\n 1 Acr       0     5.07\n 2 Acr       4     5.54\n 3 Acr       8     7.31\n 4 Aipl1     0     3.70\n 5 Aipl1     4     3.89\n 6 Aipl1     8     6.56\n 7 Bst1      0     3.20\n 8 Bst1      4     3.77\n 9 Bst1      8     5.22\n10 Chil3     0     4.00\n# ℹ 20 more rows\n\n\nWe can build the line plot with duration of the infection on the x-axis and the mean expression on the y-axis:\n\nggplot(data = mean_exp_by_time, mapping = aes(x = time, y = mean_exp)) +\n  geom_line()\n\n\n\n\n\n\n\n\nUnfortunately, this does not work because we plotted data for all the genes together. We need to tell ggplot to draw a line for each gene by modifying the aesthetic function to include group = gene:\n\nggplot(data = mean_exp_by_time,\n       mapping = aes(x = time, y = mean_exp, group = gene)) +\n  geom_line()\n\n\n\n\n\n\n\n\nWe will be able to distinguish genes in the plot if we add colors (using color also automatically groups the data):\n\nggplot(data = mean_exp_by_time,\n       mapping = aes(x = time, y = mean_exp, color = gene)) +\n  geom_line()\n\n\n\n\n\n\n\n\n\n\n\nggplot2 has a special technique called faceting that allows the user to split one plot into multiple (sub) plots based on a factor included in the dataset. These different subplots inherit the same properties (axes limits, ticks, …) to facilitate their direct comparison. We will use it to make a line plot across time for each gene:\n\nggplot(data = mean_exp_by_time,\n       mapping = aes(x = time, y = mean_exp)) + geom_line() +\n  facet_wrap(~ gene)\n\n\n\n\n\n\n\n\nHere both x- and y-axis have the same scale for all the subplots. You can change this default behavior by modifying scales in order to allow a free scale for the y-axis:\n\nggplot(data = mean_exp_by_time,\n       mapping = aes(x = time, y = mean_exp)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\")\n\n\n\n\n\n\n\n\nNow we would like to split the line in each plot by the sex of the mice. To do that we need to calculate the mean expression in the data frame grouped by gene, time, and sex:\n\nmean_exp_by_time_sex &lt;- sub_rna %&gt;%\n  group_by(gene, time, sex) %&gt;%\n    summarize(mean_exp = mean(expression_log))\n\n`summarise()` has grouped output by 'gene', 'time'. You can override using the\n`.groups` argument.\n\n\n\nmean_exp_by_time_sex\n\n# A tibble: 60 × 4\n# Groups:   gene, time [30]\n   gene   time sex    mean_exp\n   &lt;chr&gt; &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;\n 1 Acr       0 Female     5.13\n 2 Acr       0 Male       5.00\n 3 Acr       4 Female     5.93\n 4 Acr       4 Male       5.15\n 5 Acr       8 Female     7.27\n 6 Acr       8 Male       7.36\n 7 Aipl1     0 Female     3.67\n 8 Aipl1     0 Male       3.73\n 9 Aipl1     4 Female     4.07\n10 Aipl1     4 Male       3.72\n# ℹ 50 more rows\n\n\nWe can now make the faceted plot by splitting further by sex using color (within a single plot):\n\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\")\n\n\n\n\n\n\n\n\nUsually plots with white background look more readable when printed. We can set the background to white using the function theme_bw(). Additionally, we can remove the grid:\n\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nUse what you just learned to create a plot that depicts how the average expression of each chromosome changes through the duration of infection.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nmean_exp_by_chromosome &lt;- rna %&gt;%\n  group_by(chromosome_name, time) %&gt;%\n  summarize(mean_exp = mean(expression_log))\n\n`summarise()` has grouped output by 'chromosome_name'. You can override using\nthe `.groups` argument.\n\n\n\nggplot(data = mean_exp_by_chromosome, mapping = aes(x = time,\n                                y = mean_exp)) +\n  geom_line() +\n  facet_wrap(~ chromosome_name, scales = \"free_y\")\n\n\n\n\n\n\n\n\n\n\n\nThe facet_wrap geometry extracts plots into an arbitrary number of dimensions to allow them to cleanly fit on one page. On the other hand, the facet_grid geometry allows you to explicitly specify how you want your plots to be arranged via formula notation (rows ~ columns; a . can be used as a placeholder that indicates only one row or column).\nLet’s modify the previous plot to compare how the mean gene expression of males and females has changed through time:\n\n# One column, facet by rows\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = gene)) +\n  geom_line() +\n  facet_grid(sex ~ .)\n\n\n\n\n\n\n\n\n\n# One row, facet by column\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = gene)) +\n  geom_line() +\n  facet_grid(. ~ sex)\n\n\n\n\n\n\n\n\n\n\n\nIn addition to theme_bw(), which changes the plot background to white, ggplot2 comes with several other themes which can be useful to quickly change the look of your visualization. The complete list of themes is available at https://ggplot2.tidyverse.org/reference/ggtheme.html. theme_minimal() and theme_light() are popular, and theme_void() can be useful as a starting point to create a new hand-crafted theme.\nThe ggthemes package provides a wide variety of options (including an Excel 2003 theme). The ggplot2 extensions website provides a list of packages that extend the capabilities of ggplot2, including additional themes.\n\n\n\nLet’s come back to the faceted plot of mean expression by time and gene, colored by sex.\nTake a look at the ggplot2 cheat sheet, and think of ways you could improve the plot.\nNow, we can change names of axes to something more informative than ‘time’ and ‘mean_exp’, and add a title to the figure:\n\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank()) +\n  labs(title = \"Mean gene expression by duration of the infection\",\n       x = \"Duration of the infection (in days)\",\n       y = \"Mean gene expression\")\n\n\n\n\n\n\n\n\nThe axes have more informative names, but their readability can be improved by increasing the font size:\n\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank()) +\n  labs(title = \"Mean gene expression by duration of the infection\",\n       x = \"Duration of the infection (in days)\",\n       y = \"Mean gene expression\")  +\n  theme(text = element_text(size = 16))\n\n\n\n\n\n\n\n\nNote that it is also possible to change the fonts of your plots. If you are on Windows, you may have to install the extrafont package.\nWe can further customize the color of x- and y-axis text, the color of the grid, etc. We can also for example move the legend to the top by setting legend.position to \"top\".\n\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank()) +\n  labs(title = \"Mean gene expression by duration of the infection\",\n       x = \"Duration of the infection (in days)\",\n       y = \"Mean gene expression\")  +\n  theme(text = element_text(size = 16),\n        axis.text.x = element_text(colour = \"royalblue4\", size = 12),\n        axis.text.y = element_text(colour = \"royalblue4\", size = 12),\n        panel.grid = element_line(colour=\"lightsteelblue1\"),\n        legend.position = \"top\")\n\n\n\n\n\n\n\n\nIf you like the changes you created better than the default theme, you can save them as an object to be able to easily apply them to other plots you may create. Here is an example with the histogram we have previously created.\n\nblue_theme &lt;- theme(axis.text.x = element_text(colour = \"royalblue4\",\n                                               size = 12),\n                    axis.text.y = element_text(colour = \"royalblue4\",\n                                               size = 12),\n                    text = element_text(size = 16),\n                    panel.grid = element_line(colour=\"lightsteelblue1\"))\n\nggplot(rna, aes(x = expression_log)) +\n  geom_histogram(bins = 20) +\n    blue_theme\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWith all of this information in hand, please take another five minutes to either improve one of the plots generated in this exercise or create a beautiful graph of your own. Use the RStudio ggplot2 cheat sheet for inspiration. Here are some ideas:\n\nSee if you can change the thickness of the lines.\nCan you find a way to change the name of the legend? What about its labels? (hint: look for a ggplot function starting with scale_)\nTry using a different color palette or manually specifying the colors for the lines (see http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/).\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nFor example, based on this plot:\n\nggplot(data = mean_exp_by_time_sex,\nmapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank())\n\n\n\n\n\n\n\n\nWe can customize it the following ways:\n\n# change the thickness of the lines\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line(size=1.5) +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank())\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\n\n# change the name of the legend and the labels\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank()) +\n  scale_color_discrete(name = \"Gender\", labels = c(\"F\", \"M\"))\n\n\n\n\n\n\n\n\n\n# using a different color palette\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank()) +\n  scale_color_brewer(name = \"Gender\", labels = c(\"F\", \"M\"), palette = \"Dark2\")\n\n\n\n\n\n\n\n\n\n\n\n\n# manually specifying the colors\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank()) +\n  scale_color_manual(name = \"Gender\",  labels = c(\"F\", \"M\"),values = c(\"royalblue\", \"deeppink\"))\n\n\n\n\n\n\n\n\n\n\n\nFaceting is a great tool for splitting one plot into multiple subplots, but sometimes you may want to produce a single figure that contains multiple independent plots, i.e. plots that are based on different variables or even different data frames.\nLet’s start by creating the two plots that we want to arrange next to each other:\nThe first graph counts the number of unique genes per chromosome. We first need to reorder the levels of chromosome_name and filter the unique genes per chromosome. We also change the scale of the y-axis to a log10 scale for better readability.\n\nrna$chromosome_name &lt;- factor(rna$chromosome_name,\n                               levels = c(1:19,\"X\",\"Y\"))\n\ncount_gene_chromosome &lt;- rna %&gt;% select(chromosome_name, gene) %&gt;%\n  distinct() %&gt;% ggplot() +\n  geom_bar(aes(x = chromosome_name), fill = \"seagreen\",\n           position = \"dodge\", stat = \"count\") +\n  labs(y = \"log10(n genes)\", x = \"chromosome\") +\n  scale_y_log10()\n\ncount_gene_chromosome\n\n\n\n\n\n\n\n\nBelow, we also remove the legend altogether by setting the legend.position to \"none\".\n\nexp_boxplot_sex &lt;- ggplot(rna, aes(y=expression_log, x = as.factor(time),\n                 color=sex)) +\n   geom_boxplot(alpha = 0) +\n  labs(y = \"Mean gene exp\",\n       x = \"time\") + theme(legend.position = \"none\")\n\nexp_boxplot_sex\n\n\n\n\n\n\n\n\nThe patchwork package provides an elegant approach to combining figures using the + to arrange figures (typically side by side). More specifically the | explicitly arranges them side by side and / stacks them on top of each other.\n\ninstall.packages(\"patchwork\")\n\n\nThe downloaded binary packages are in\n    /var/folders/6v/qms_hkh14rqbc_q9c29yjk3m0000gn/T//RtmpnGCs3W/downloaded_packages\n\n\n\nlibrary(\"patchwork\")\n\nWarning: package 'patchwork' was built under R version 4.3.3\n\ncount_gene_chromosome + exp_boxplot_sex\n\n\n\n\n\n\n\n\n\n## or count_gene_chromosome | exp_boxplot_sex\n\n\ncount_gene_chromosome / exp_boxplot_sex\n\n\n\n\n\n\n\n\nWe can combine further control the layout of the final composition with plot_layout to create more complex layouts:\n\ncount_gene_chromosome + exp_boxplot_sex + plot_layout(ncol = 1)\n\n\n\n\n\n\n\n\n\ncount_gene_chromosome +\n (count_gene_chromosome + exp_boxplot_sex) +\n exp_boxplot_sex +\n plot_layout(ncol = 1)\n\n\n\n\n\n\n\n\nThe last plot can also be created using the | and / composers:\n\ncount_gene_chromosome /\n (count_gene_chromosome | exp_boxplot_sex) /\n exp_boxplot_sex\n\n\n\n\n\n\n\n\nLearn more about patchwork on its webpage or in this video.\nAnother option is the gridExtra package that allows to combine separate ggplots into a single figure using grid.arrange():\n\ninstall.packages(\"gridExtra\")\n\n\nThe downloaded binary packages are in\n    /var/folders/6v/qms_hkh14rqbc_q9c29yjk3m0000gn/T//RtmpnGCs3W/downloaded_packages\n\n\n\nlibrary(\"gridExtra\")\n\n\nAttaching package: 'gridExtra'\n\n\nThe following object is masked from 'package:dplyr':\n\n    combine\n\ngrid.arrange(count_gene_chromosome, exp_boxplot_sex, ncol = 2)\n\n\n\n\n\n\n\n\nIn addition to the ncol and nrow arguments, used to make simple arrangements, there are tools for constructing more complex layouts.\n\n\n\nAfter creating your plot, you can save it to a file in your favorite format. The Export tab in the Plot pane in RStudio will save your plots at low resolution, which will not be accepted by many journals and will not scale well for posters.\nInstead, use the ggsave() function, which allows you easily change the dimension and resolution of your plot by adjusting the appropriate arguments (width, height and dpi).\nMake sure you have the fig_output/ folder in your working directory.\n\nmy_plot &lt;- ggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  labs(title = \"Mean gene expression by duration of the infection\",\n         x = \"Duration of the infection (in days)\",\n         y = \"Mean gene expression\") +\n  guides(color=guide_legend(title=\"Gender\")) +\n  theme_bw() +\n  theme(axis.text.x = element_text(colour = \"royalblue4\", size = 12),\n        axis.text.y = element_text(colour = \"royalblue4\", size = 12),\n        text = element_text(size = 16),\n        panel.grid = element_line(colour=\"lightsteelblue1\"),\n        legend.position = \"top\")\nggsave(\"fig_output/mean_exp_by_time_sex.png\", my_plot, width = 15,\n       height = 10,create.dir = TRUE)\n\n# This also works for grid.arrange() plots\ncombo_plot &lt;- grid.arrange(count_gene_chromosome, exp_boxplot_sex,\n                           ncol = 2, widths = c(4, 6))\n\n\n\n\n\n\n\nggsave(\"fig_output/combo_plot_chromosome_sex.png\", combo_plot,width = 10, dpi = 300,create.dir = TRUE)\n\nSaving 10 x 5 in image\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote: The parameters width and height also determine the font size in the saved plot.\n\n\n\n\n\nggplot2 is a very powerful package that fits very nicely in our tidy data and tidy tools pipeline. There are other visualization packages in R that shouldn’t be ignored.\n\n\nThe default graphics system that comes with R, often called base R graphics is simple and fast. It is based on the painter’s or canvas model, where different output are directly overlaid on top of each other (see figure @ref(fig:paintermodel)). This is a fundamental difference with ggplot2 (and with lattice, described below), that returns dedicated objects, that are rendered on screen or in a file, and that can even be updated.\n\npar(mfrow = c(1, 3))\nplot(1:20, main = \"First layer, produced with plot(1:20)\")\n\nplot(1:20, main = \"A horizontal red line, added with abline(h = 10)\")\nabline(h = 10, col = \"red\")\n\nplot(1:20, main = \"A rectangle, added with rect(5, 5, 15, 15)\")\nabline(h = 10, col = \"red\")\nrect(5, 5, 15, 15, lwd = 3)\n\n\n\n\n\n\n\n\nAnother main difference is that base graphics’ plotting function try to do the right thing based on their input type, i.e. they will adapt their behaviour based on the class of their input. This is again very different from what we have in ggplot2, that only accepts dataframes as input, and that requires plots to be constructed bit by bit.\n\npar(mfrow = c(2, 2))\nboxplot(rnorm(100),\n        main = \"Boxplot of rnorm(100)\")\nboxplot(matrix(rnorm(100), ncol = 10),\n        main = \"Boxplot of matrix(rnorm(100), ncol = 10)\")\nhist(rnorm(100))\nhist(matrix(rnorm(100), ncol = 10))\n\n\n\n\n\n\n\n\nThe out-of-the-box approach in base graphics can be very efficient for simple, standard figures, that can be produced very quickly with a single line of code and a single function such as plot, or hist, or boxplot, … The defaults are however not always the most appealing and tuning of figures, especially when they become more complex (for example to produce facets), can become lengthy and cumbersome.\n\n\n\nThe lattice package is similar to ggplot2 in that is uses dataframes as input, returns graphical objects and supports faceting. lattice however isn’t based on the grammar of graphics and has a more convoluted interface.\nA good reference for the lattice package is @latticebook."
  },
  {
    "objectID": "bioc_intro_dataVisualization_solutions.html#data-visualization",
    "href": "bioc_intro_dataVisualization_solutions.html#data-visualization",
    "title": "Data Visualization",
    "section": "",
    "text": "We start by loading the required packages. ggplot2 is included in the tidyverse package.\n\nlibrary(\"tidyverse\")\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nIf not still in the workspace, load the data we saved in the previous lesson.\n\nrna &lt;- read.csv(\"data/rnaseq.csv\")\n\nThe Data Visualization Cheat Sheet will cover the basics and more advanced features of ggplot2 and will help, in addition to serve as a reminder, getting an overview of the many data representations available in the package. The following video tutorials (part 1 and 2) by Thomas Lin Pedersen are also very instructive.\n\n\nggplot2 is a plotting package that makes it simple to create complex plots from data in a data frame. It provides a more programmatic interface for specifying what variables to plot, how they are displayed, and general visual properties. The theoretical foundation that supports the ggplot2 is the Grammar of Graphics (@Wilkinson:2005). Using this approach, we only need minimal changes if the underlying data change or if we decide to change from a bar plot to a scatterplot. This helps in creating publication quality plots with minimal amounts of adjustments and tweaking.\nThere is a book about ggplot2 (@ggplot2book) that provides a good overview, but it is outdated. The 3rd edition is in preparation and will be freely available online. The ggplot2 webpage (https://ggplot2.tidyverse.org) provides ample documentation.\nggplot2 functions like data in the ‘long’ format, i.e., a column for every dimension, and a row for every observation. Well-structured data will save you lots of time when making figures with ggplot2.\nggplot graphics are built step by step by adding new elements. Adding layers in this fashion allows for extensive flexibility and customization of plots.\nThe idea behind the Grammar of Graphics it is that you can build every graph from the same 3 components:\n(1) a data set, (2) a coordinate system, and (3) geoms — i.e. visual marks that represent data points 1.\nTo build a ggplot, we will use the following basic template that can be used for different types of plots:\n\nggplot(data = &lt;DATA&gt;, mapping = aes(&lt;MAPPINGS&gt;)) +  &lt;GEOM_FUNCTION&gt;()\n\n\nuse the ggplot() function and bind the plot to a specific data frame using the data argument\n\nggplot(data = rna)\n\n\n\n\n\n\n\n\ndefine a mapping (using the aesthetic (aes) function), by selecting the variables to be plotted and specifying how to present them in the graph, e.g. as x/y positions or characteristics such as size, shape, color, etc.\n\nggplot(data = rna, mapping = aes(x = expression))\n\n\n\n\n\n\n\n\nadd ‘geoms’ - geometries, or graphical representations of the data in the plot (points, lines, bars). ggplot2 offers many different geoms; we will use some common ones today, including:\n\n* `geom_point()` for scatter plots, dot plots, etc.\n* `geom_histogram()` for histograms\n* `geom_boxplot()` for, well, boxplots!\n* `geom_line()` for trend lines, time series, etc.\n\n\nTo add a geom(etry) to the plot use the + operator. Let’s use geom_histogram() first:\n\nggplot(data = rna, mapping = aes(x = expression)) +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nThe + in the ggplot2 package is particularly useful because it allows you to modify existing ggplot objects. This means you can easily set up plot templates and conveniently explore different types of plots, so the above plot can also be generated with code like this:\n\n# Assign plot to a variable\nrna_plot &lt;- ggplot(data = rna,\nmapping = aes(x = expression))\n\n# Draw the plot\nrna_plot + geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nYou have probably noticed an automatic message that appears when drawing the histogram:\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\nChange the arguments bins or binwidth of geom_histogram() to change the number or width of the bins.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# change bins\nggplot(rna, aes(x = expression)) +\n    geom_histogram(bins = 15) \n\n\n\n\n\n\n\n\n\n# change binwidth\nggplot(rna, aes(x = expression)) +\n    geom_histogram(binwidth = 2000)\n\n\n\n\n\n\n\n\n\n\n\nWe can observe here that the data are skewed to the right. We can apply log2 transformation to have a more symmetric distribution. Note that we add here a small constant value (+1) to avoid having -Inf values returned for expression values equal to 0.\n\nrna &lt;- rna %&gt;%\n  mutate(expression_log = log2(expression + 1))\n\nIf we now draw the histogram of the log2-transformed expressions, the distribution is indeed closer to a normal distribution.\n\nggplot(rna, aes(x = expression_log)) + geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nFrom now on we will work on the log-transformed expression values.\n\n\n\n\n\n\nChallenge\n\n\n\nAnother way to visualize this transformation is to consider the scale of the observations. For example, it may be worth changing the scale of the axis to better distribute the observations in the space of the plot. Changing the scale of the axes is done similarly to adding/modifying other components (i.e., by incrementally adding commands). Try making this modification:\n\nRepresent the un-transformed expression on the log10 scale; see scale_x_log10(). Compare it with the previous graph. Why do you now have warning messages appearing?\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nggplot(data = rna,mapping = aes(x = expression))+\n  geom_histogram() +\n  scale_x_log10()\n\nWarning in scale_x_log10(): log-10 transformation introduced infinite values.\n\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\nWarning: Removed 507 rows containing non-finite outside the scale range\n(`stat_bin()`).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNotes\n\nAnything you put in the ggplot() function can be seen by any geom layers that you add (i.e., these are global plot settings). This includes the x- and y-axis mapping you set up in aes().\nYou can also specify mappings for a given geom independently of the mappings defined globally in the ggplot() function.\n\nThe + sign used to add new layers must be placed at the end of the line containing the previous layer. If, instead, the + sign is added at the beginning of the line containing the new layer, ggplot2 will not add the new layer and will return an error message.\n\n\n\n# This is the correct syntax for adding layers\nrna_plot +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n# This will not add the new layer and will return an error message\nrna_plot + \n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\n\n\nWe will now draw a scatter plot with two continuous variables and the geom_point() function. This graph will represent the log2 fold changes of expression comparing time 8 versus time 0, and time 4 versus time 0. To this end, we first need to compute the means of the log-transformed expression values by gene and time, then the log fold changes by subtracting the mean log expressions between time 8 and time 0 and between time 4 and time 0. Note that we also include here the gene biotype that we will use later on to represent the genes. We will save the fold changes in a new data frame called rna_fc.\n\nrna_fc &lt;- rna %&gt;% select(gene, time,\n                         gene_biotype, expression_log) %&gt;%\n  group_by(gene, time, gene_biotype) %&gt;%\n  summarize(mean_exp = mean(expression_log)) %&gt;%\n  pivot_wider(names_from = time,\n              values_from = mean_exp) %&gt;%\n  mutate(time_8_vs_0 = `8` - `0`, time_4_vs_0 = `4` - `0`)\n\n`summarise()` has grouped output by 'gene', 'time'. You can override using the\n`.groups` argument.\n\n\nWe can then build a ggplot with the newly created dataset rna_fc. Building plots with ggplot2 is typically an iterative process. We start by defining the dataset we’ll use, lay out the axes, and choose a geom:\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +\n  geom_point()\n\n\n\n\n\n\n\n\nThen, we start modifying this plot to extract more information from it. For instance, we can add transparency (alpha) to avoid overplotting:\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +\n  geom_point(alpha = 0.3)\n\n\n\n\n\n\n\n\nWe can also add colors for all the points:\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +\n  geom_point(alpha = 0.3, color = \"blue\")\n\n\n\n\n\n\n\n\nOr to color each gene in the plot differently, you could use a vector as an input to the argument color. ggplot2 will provide a different color corresponding to different values in the vector. Here is an example where we color with gene_biotype:\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +\n  geom_point(alpha = 0.3, aes(color = gene_biotype))\n\n\n\n\n\n\n\n\nWe can also specify the colors directly inside the mapping provided in the ggplot() function. This will be seen by any geom layers and the mapping will be determined by the x- and y-axis set up in aes().\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0,\n                                color = gene_biotype)) +\n  geom_point(alpha = 0.3)\n\n\n\n\n\n\n\n\nFinally, we could also add a diagonal line with the geom_abline() function:\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0,\n                                color = gene_biotype)) +\n  geom_point(alpha = 0.3) +\n  geom_abline(intercept = 0)\n\n\n\n\n\n\n\n\nNotice that we can change the geom layer from geom_point to geom_jitter and colors will still be determined by gene_biotype.\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0,\n                                color = gene_biotype)) +\n  geom_jitter(alpha = 0.3) +\n  geom_abline(intercept = 0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nScatter plots can be useful exploratory tools for small datasets. For data sets with large numbers of observations, such as the rna_fc data set, overplotting of points can be a limitation of scatter plots. One strategy for handling such settings is to use hexagonal binning of observations. The plot space is tessellated into hexagons. Each hexagon is assigned a color based on the number of observations that fall within its boundaries.\n\nTo use hexagonal binning in ggplot2, first install the R package hexbin from CRAN and load it.\nThen use the geom_hex() function to produce the hexbin figure.\nWhat are the relative strengths and weaknesses of a hexagonal bin plot compared to a scatter plot? Examine the above scatter plot and compare it with the hexagonal bin plot that you created.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ninstall.packages(\"hexbin\")\n\n\nThe downloaded binary packages are in\n    /var/folders/6v/qms_hkh14rqbc_q9c29yjk3m0000gn/T//RtmpnGCs3W/downloaded_packages\n\n\n\nlibrary(\"hexbin\")\n\nWarning: package 'hexbin' was built under R version 4.3.3\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +\n  geom_hex() +\n  geom_abline(intercept = 0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nUse what you just learned to create a scatter plot of expression_log over sample from the rna dataset with the time showing in different colors. Is this a good way to show this type of data?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nggplot(data = rna, mapping = aes(y = expression_log, x = sample)) +\n    geom_point(aes(color = time))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWe can use boxplots to visualize the distribution of gene expressions within each sample:\n\nggplot(data = rna,\n  mapping = aes(y = expression_log, x = sample)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nBy adding points to boxplot, we can have a better idea of the number of measurements and of their distribution:\n\nggplot(data = rna,\n  mapping = aes(y = expression_log, x = sample)) +\n  geom_jitter(alpha = 0.2, color = \"tomato\") +\n  geom_boxplot(alpha = 0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nNote how the boxplot layer is in front of the jitter layer? What do you need to change in the code to put the boxplot below the points?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nWe should switch the order of these two geoms:\n\nggplot(data = rna,\nmapping = aes(y = expression_log, x = sample)) +\n  geom_boxplot(alpha = 0) +\n  geom_jitter(alpha = 0.2, color = \"tomato\")\n\n\n\n\n\n\n\n\n\n\n\nYou may notice that the values on the x-axis are still not properly readable. Let’s change the orientation of the labels and adjust them vertically and horizontally so they don’t overlap. You can use a 90-degree angle, or experiment to find the appropriate angle for diagonally oriented labels:\n\nggplot(data = rna,\n    mapping = aes(y = expression_log, x = sample)) +\n  geom_jitter(alpha = 0.2, color = \"tomato\") +\n  geom_boxplot(alpha = 0) +\n  theme(axis.text.x = element_text(angle = 90,  hjust = 0.5, vjust = 0.5))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nAdd color to the data points on your boxplot according to the duration of the infection (time).\nHint: Check the class for time. Consider changing the class of time from integer to factor directly in the ggplot mapping. Why does this change how R makes the graph?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# time as integer\nggplot(data = rna,\nmapping = aes(y = expression_log,x = sample)) +\n  geom_jitter(alpha = 0.2, aes(color = time)) +\n  geom_boxplot(alpha = 0) +\n  theme(axis.text.x = element_text(angle = 90,  hjust = 0.5, vjust = 0.5))\n\n\n\n\n\n\n\n\n\n# time as factor\nggplot(data = rna,\nmapping = aes(y = expression_log,x = sample)) +\n  geom_jitter(alpha = 0.2, aes(color = as.factor(time))) +\n  geom_boxplot(alpha = 0) +\n  theme(axis.text.x = element_text(angle = 90,  hjust = 0.5, vjust = 0.5))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nBoxplots are useful summaries, but hide the shape of the distribution. For example, if the distribution is bimodal, we would not see it in a boxplot. An alternative to the boxplot is the violin plot, where the shape (of the density of points) is drawn.\n\nReplace the box plot with a violin plot; see geom_violin(). Fill in the violins according to the time with the argument fill.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nggplot(data = rna,\nmapping = aes(y = expression_log, x = sample)) +\n  geom_violin(aes(fill = as.factor(time))) +\n  theme(axis.text.x = element_text(angle = 90,  hjust = 0.5, vjust = 0.5))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nModify the violin plot to fill in the violins by sex.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nggplot(data = rna,\n         mapping = aes(y = expression_log, x = sample)) +\n  geom_violin(aes(fill = sex)) +\n  theme(axis.text.x = element_text(angle = 90,  hjust = 0.5, vjust = 0.5))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLet’s calculate the mean expression per duration of the infection for the 10 genes having the highest log fold changes comparing time 8 versus time 0. First, we need to select the genes and create a subset of rna called sub_rna containing the 10 selected genes, then we need to group the data and calculate the mean gene expression within each group:\n\nrna_fc &lt;- rna_fc %&gt;% arrange(desc(time_8_vs_0))\n\ngenes_selected &lt;- rna_fc$gene[1:10]\n\nsub_rna &lt;- rna %&gt;%\n    filter(gene %in% genes_selected)\n\nmean_exp_by_time &lt;- sub_rna %&gt;%\n  group_by(gene,time) %&gt;%\n    summarize(mean_exp = mean(expression_log))\n\n`summarise()` has grouped output by 'gene'. You can override using the\n`.groups` argument.\n\n\n\nmean_exp_by_time\n\n# A tibble: 30 × 3\n# Groups:   gene [10]\n   gene   time mean_exp\n   &lt;chr&gt; &lt;int&gt;    &lt;dbl&gt;\n 1 Acr       0     5.07\n 2 Acr       4     5.54\n 3 Acr       8     7.31\n 4 Aipl1     0     3.70\n 5 Aipl1     4     3.89\n 6 Aipl1     8     6.56\n 7 Bst1      0     3.20\n 8 Bst1      4     3.77\n 9 Bst1      8     5.22\n10 Chil3     0     4.00\n# ℹ 20 more rows\n\n\nWe can build the line plot with duration of the infection on the x-axis and the mean expression on the y-axis:\n\nggplot(data = mean_exp_by_time, mapping = aes(x = time, y = mean_exp)) +\n  geom_line()\n\n\n\n\n\n\n\n\nUnfortunately, this does not work because we plotted data for all the genes together. We need to tell ggplot to draw a line for each gene by modifying the aesthetic function to include group = gene:\n\nggplot(data = mean_exp_by_time,\n       mapping = aes(x = time, y = mean_exp, group = gene)) +\n  geom_line()\n\n\n\n\n\n\n\n\nWe will be able to distinguish genes in the plot if we add colors (using color also automatically groups the data):\n\nggplot(data = mean_exp_by_time,\n       mapping = aes(x = time, y = mean_exp, color = gene)) +\n  geom_line()\n\n\n\n\n\n\n\n\n\n\n\nggplot2 has a special technique called faceting that allows the user to split one plot into multiple (sub) plots based on a factor included in the dataset. These different subplots inherit the same properties (axes limits, ticks, …) to facilitate their direct comparison. We will use it to make a line plot across time for each gene:\n\nggplot(data = mean_exp_by_time,\n       mapping = aes(x = time, y = mean_exp)) + geom_line() +\n  facet_wrap(~ gene)\n\n\n\n\n\n\n\n\nHere both x- and y-axis have the same scale for all the subplots. You can change this default behavior by modifying scales in order to allow a free scale for the y-axis:\n\nggplot(data = mean_exp_by_time,\n       mapping = aes(x = time, y = mean_exp)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\")\n\n\n\n\n\n\n\n\nNow we would like to split the line in each plot by the sex of the mice. To do that we need to calculate the mean expression in the data frame grouped by gene, time, and sex:\n\nmean_exp_by_time_sex &lt;- sub_rna %&gt;%\n  group_by(gene, time, sex) %&gt;%\n    summarize(mean_exp = mean(expression_log))\n\n`summarise()` has grouped output by 'gene', 'time'. You can override using the\n`.groups` argument.\n\n\n\nmean_exp_by_time_sex\n\n# A tibble: 60 × 4\n# Groups:   gene, time [30]\n   gene   time sex    mean_exp\n   &lt;chr&gt; &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;\n 1 Acr       0 Female     5.13\n 2 Acr       0 Male       5.00\n 3 Acr       4 Female     5.93\n 4 Acr       4 Male       5.15\n 5 Acr       8 Female     7.27\n 6 Acr       8 Male       7.36\n 7 Aipl1     0 Female     3.67\n 8 Aipl1     0 Male       3.73\n 9 Aipl1     4 Female     4.07\n10 Aipl1     4 Male       3.72\n# ℹ 50 more rows\n\n\nWe can now make the faceted plot by splitting further by sex using color (within a single plot):\n\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\")\n\n\n\n\n\n\n\n\nUsually plots with white background look more readable when printed. We can set the background to white using the function theme_bw(). Additionally, we can remove the grid:\n\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nUse what you just learned to create a plot that depicts how the average expression of each chromosome changes through the duration of infection.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nmean_exp_by_chromosome &lt;- rna %&gt;%\n  group_by(chromosome_name, time) %&gt;%\n  summarize(mean_exp = mean(expression_log))\n\n`summarise()` has grouped output by 'chromosome_name'. You can override using\nthe `.groups` argument.\n\n\n\nggplot(data = mean_exp_by_chromosome, mapping = aes(x = time,\n                                y = mean_exp)) +\n  geom_line() +\n  facet_wrap(~ chromosome_name, scales = \"free_y\")\n\n\n\n\n\n\n\n\n\n\n\nThe facet_wrap geometry extracts plots into an arbitrary number of dimensions to allow them to cleanly fit on one page. On the other hand, the facet_grid geometry allows you to explicitly specify how you want your plots to be arranged via formula notation (rows ~ columns; a . can be used as a placeholder that indicates only one row or column).\nLet’s modify the previous plot to compare how the mean gene expression of males and females has changed through time:\n\n# One column, facet by rows\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = gene)) +\n  geom_line() +\n  facet_grid(sex ~ .)\n\n\n\n\n\n\n\n\n\n# One row, facet by column\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = gene)) +\n  geom_line() +\n  facet_grid(. ~ sex)\n\n\n\n\n\n\n\n\n\n\n\nIn addition to theme_bw(), which changes the plot background to white, ggplot2 comes with several other themes which can be useful to quickly change the look of your visualization. The complete list of themes is available at https://ggplot2.tidyverse.org/reference/ggtheme.html. theme_minimal() and theme_light() are popular, and theme_void() can be useful as a starting point to create a new hand-crafted theme.\nThe ggthemes package provides a wide variety of options (including an Excel 2003 theme). The ggplot2 extensions website provides a list of packages that extend the capabilities of ggplot2, including additional themes.\n\n\n\nLet’s come back to the faceted plot of mean expression by time and gene, colored by sex.\nTake a look at the ggplot2 cheat sheet, and think of ways you could improve the plot.\nNow, we can change names of axes to something more informative than ‘time’ and ‘mean_exp’, and add a title to the figure:\n\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank()) +\n  labs(title = \"Mean gene expression by duration of the infection\",\n       x = \"Duration of the infection (in days)\",\n       y = \"Mean gene expression\")\n\n\n\n\n\n\n\n\nThe axes have more informative names, but their readability can be improved by increasing the font size:\n\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank()) +\n  labs(title = \"Mean gene expression by duration of the infection\",\n       x = \"Duration of the infection (in days)\",\n       y = \"Mean gene expression\")  +\n  theme(text = element_text(size = 16))\n\n\n\n\n\n\n\n\nNote that it is also possible to change the fonts of your plots. If you are on Windows, you may have to install the extrafont package.\nWe can further customize the color of x- and y-axis text, the color of the grid, etc. We can also for example move the legend to the top by setting legend.position to \"top\".\n\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank()) +\n  labs(title = \"Mean gene expression by duration of the infection\",\n       x = \"Duration of the infection (in days)\",\n       y = \"Mean gene expression\")  +\n  theme(text = element_text(size = 16),\n        axis.text.x = element_text(colour = \"royalblue4\", size = 12),\n        axis.text.y = element_text(colour = \"royalblue4\", size = 12),\n        panel.grid = element_line(colour=\"lightsteelblue1\"),\n        legend.position = \"top\")\n\n\n\n\n\n\n\n\nIf you like the changes you created better than the default theme, you can save them as an object to be able to easily apply them to other plots you may create. Here is an example with the histogram we have previously created.\n\nblue_theme &lt;- theme(axis.text.x = element_text(colour = \"royalblue4\",\n                                               size = 12),\n                    axis.text.y = element_text(colour = \"royalblue4\",\n                                               size = 12),\n                    text = element_text(size = 16),\n                    panel.grid = element_line(colour=\"lightsteelblue1\"))\n\nggplot(rna, aes(x = expression_log)) +\n  geom_histogram(bins = 20) +\n    blue_theme\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWith all of this information in hand, please take another five minutes to either improve one of the plots generated in this exercise or create a beautiful graph of your own. Use the RStudio ggplot2 cheat sheet for inspiration. Here are some ideas:\n\nSee if you can change the thickness of the lines.\nCan you find a way to change the name of the legend? What about its labels? (hint: look for a ggplot function starting with scale_)\nTry using a different color palette or manually specifying the colors for the lines (see http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/).\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nFor example, based on this plot:\n\nggplot(data = mean_exp_by_time_sex,\nmapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank())\n\n\n\n\n\n\n\n\nWe can customize it the following ways:\n\n# change the thickness of the lines\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line(size=1.5) +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank())\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\n\n# change the name of the legend and the labels\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank()) +\n  scale_color_discrete(name = \"Gender\", labels = c(\"F\", \"M\"))\n\n\n\n\n\n\n\n\n\n# using a different color palette\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank()) +\n  scale_color_brewer(name = \"Gender\", labels = c(\"F\", \"M\"), palette = \"Dark2\")\n\n\n\n\n\n\n\n\n\n\n\n\n# manually specifying the colors\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank()) +\n  scale_color_manual(name = \"Gender\",  labels = c(\"F\", \"M\"),values = c(\"royalblue\", \"deeppink\"))\n\n\n\n\n\n\n\n\n\n\n\nFaceting is a great tool for splitting one plot into multiple subplots, but sometimes you may want to produce a single figure that contains multiple independent plots, i.e. plots that are based on different variables or even different data frames.\nLet’s start by creating the two plots that we want to arrange next to each other:\nThe first graph counts the number of unique genes per chromosome. We first need to reorder the levels of chromosome_name and filter the unique genes per chromosome. We also change the scale of the y-axis to a log10 scale for better readability.\n\nrna$chromosome_name &lt;- factor(rna$chromosome_name,\n                               levels = c(1:19,\"X\",\"Y\"))\n\ncount_gene_chromosome &lt;- rna %&gt;% select(chromosome_name, gene) %&gt;%\n  distinct() %&gt;% ggplot() +\n  geom_bar(aes(x = chromosome_name), fill = \"seagreen\",\n           position = \"dodge\", stat = \"count\") +\n  labs(y = \"log10(n genes)\", x = \"chromosome\") +\n  scale_y_log10()\n\ncount_gene_chromosome\n\n\n\n\n\n\n\n\nBelow, we also remove the legend altogether by setting the legend.position to \"none\".\n\nexp_boxplot_sex &lt;- ggplot(rna, aes(y=expression_log, x = as.factor(time),\n                 color=sex)) +\n   geom_boxplot(alpha = 0) +\n  labs(y = \"Mean gene exp\",\n       x = \"time\") + theme(legend.position = \"none\")\n\nexp_boxplot_sex\n\n\n\n\n\n\n\n\nThe patchwork package provides an elegant approach to combining figures using the + to arrange figures (typically side by side). More specifically the | explicitly arranges them side by side and / stacks them on top of each other.\n\ninstall.packages(\"patchwork\")\n\n\nThe downloaded binary packages are in\n    /var/folders/6v/qms_hkh14rqbc_q9c29yjk3m0000gn/T//RtmpnGCs3W/downloaded_packages\n\n\n\nlibrary(\"patchwork\")\n\nWarning: package 'patchwork' was built under R version 4.3.3\n\ncount_gene_chromosome + exp_boxplot_sex\n\n\n\n\n\n\n\n\n\n## or count_gene_chromosome | exp_boxplot_sex\n\n\ncount_gene_chromosome / exp_boxplot_sex\n\n\n\n\n\n\n\n\nWe can combine further control the layout of the final composition with plot_layout to create more complex layouts:\n\ncount_gene_chromosome + exp_boxplot_sex + plot_layout(ncol = 1)\n\n\n\n\n\n\n\n\n\ncount_gene_chromosome +\n (count_gene_chromosome + exp_boxplot_sex) +\n exp_boxplot_sex +\n plot_layout(ncol = 1)\n\n\n\n\n\n\n\n\nThe last plot can also be created using the | and / composers:\n\ncount_gene_chromosome /\n (count_gene_chromosome | exp_boxplot_sex) /\n exp_boxplot_sex\n\n\n\n\n\n\n\n\nLearn more about patchwork on its webpage or in this video.\nAnother option is the gridExtra package that allows to combine separate ggplots into a single figure using grid.arrange():\n\ninstall.packages(\"gridExtra\")\n\n\nThe downloaded binary packages are in\n    /var/folders/6v/qms_hkh14rqbc_q9c29yjk3m0000gn/T//RtmpnGCs3W/downloaded_packages\n\n\n\nlibrary(\"gridExtra\")\n\n\nAttaching package: 'gridExtra'\n\n\nThe following object is masked from 'package:dplyr':\n\n    combine\n\ngrid.arrange(count_gene_chromosome, exp_boxplot_sex, ncol = 2)\n\n\n\n\n\n\n\n\nIn addition to the ncol and nrow arguments, used to make simple arrangements, there are tools for constructing more complex layouts.\n\n\n\nAfter creating your plot, you can save it to a file in your favorite format. The Export tab in the Plot pane in RStudio will save your plots at low resolution, which will not be accepted by many journals and will not scale well for posters.\nInstead, use the ggsave() function, which allows you easily change the dimension and resolution of your plot by adjusting the appropriate arguments (width, height and dpi).\nMake sure you have the fig_output/ folder in your working directory.\n\nmy_plot &lt;- ggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  labs(title = \"Mean gene expression by duration of the infection\",\n         x = \"Duration of the infection (in days)\",\n         y = \"Mean gene expression\") +\n  guides(color=guide_legend(title=\"Gender\")) +\n  theme_bw() +\n  theme(axis.text.x = element_text(colour = \"royalblue4\", size = 12),\n        axis.text.y = element_text(colour = \"royalblue4\", size = 12),\n        text = element_text(size = 16),\n        panel.grid = element_line(colour=\"lightsteelblue1\"),\n        legend.position = \"top\")\nggsave(\"fig_output/mean_exp_by_time_sex.png\", my_plot, width = 15,\n       height = 10,create.dir = TRUE)\n\n# This also works for grid.arrange() plots\ncombo_plot &lt;- grid.arrange(count_gene_chromosome, exp_boxplot_sex,\n                           ncol = 2, widths = c(4, 6))\n\n\n\n\n\n\n\nggsave(\"fig_output/combo_plot_chromosome_sex.png\", combo_plot,width = 10, dpi = 300,create.dir = TRUE)\n\nSaving 10 x 5 in image\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote: The parameters width and height also determine the font size in the saved plot.\n\n\n\n\n\nggplot2 is a very powerful package that fits very nicely in our tidy data and tidy tools pipeline. There are other visualization packages in R that shouldn’t be ignored.\n\n\nThe default graphics system that comes with R, often called base R graphics is simple and fast. It is based on the painter’s or canvas model, where different output are directly overlaid on top of each other (see figure @ref(fig:paintermodel)). This is a fundamental difference with ggplot2 (and with lattice, described below), that returns dedicated objects, that are rendered on screen or in a file, and that can even be updated.\n\npar(mfrow = c(1, 3))\nplot(1:20, main = \"First layer, produced with plot(1:20)\")\n\nplot(1:20, main = \"A horizontal red line, added with abline(h = 10)\")\nabline(h = 10, col = \"red\")\n\nplot(1:20, main = \"A rectangle, added with rect(5, 5, 15, 15)\")\nabline(h = 10, col = \"red\")\nrect(5, 5, 15, 15, lwd = 3)\n\n\n\n\n\n\n\n\nAnother main difference is that base graphics’ plotting function try to do the right thing based on their input type, i.e. they will adapt their behaviour based on the class of their input. This is again very different from what we have in ggplot2, that only accepts dataframes as input, and that requires plots to be constructed bit by bit.\n\npar(mfrow = c(2, 2))\nboxplot(rnorm(100),\n        main = \"Boxplot of rnorm(100)\")\nboxplot(matrix(rnorm(100), ncol = 10),\n        main = \"Boxplot of matrix(rnorm(100), ncol = 10)\")\nhist(rnorm(100))\nhist(matrix(rnorm(100), ncol = 10))\n\n\n\n\n\n\n\n\nThe out-of-the-box approach in base graphics can be very efficient for simple, standard figures, that can be produced very quickly with a single line of code and a single function such as plot, or hist, or boxplot, … The defaults are however not always the most appealing and tuning of figures, especially when they become more complex (for example to produce facets), can become lengthy and cumbersome.\n\n\n\nThe lattice package is similar to ggplot2 in that is uses dataframes as input, returns graphical objects and supports faceting. lattice however isn’t based on the grammar of graphics and has a more convoluted interface.\nA good reference for the lattice package is @latticebook."
  },
  {
    "objectID": "bioc_intro_dataManipulation.html",
    "href": "bioc_intro_dataManipulation.html",
    "title": "Manipulating and analysing data with dplyr",
    "section": "",
    "text": "Bracket subsetting is handy, but it can be cumbersome and difficult to read, especially for complicated operations.\nSome packages can greatly facilitate our task when we manipulate data. Packages in R are basically sets of additional functions that let you do more stuff. The functions we’ve been using so far, like str() or data.frame(), come built into R; Loading packages can give you access to other specific functions. Before you use a package for the first time you need to install it on your machine, and then you should import it in every subsequent R session when you need it.\n\nThe package dplyr provides powerful tools for data manipulation tasks. It is built to work directly with data frames, with many manipulation tasks optimised.\nAs we will see latter on, sometimes we want a data frame to be reshaped to be able to do some specific analyses or for visualisation. The package tidyr addresses this common problem of reshaping data and provides tools for manipulating data in a tidy way.\n\nTo learn more about dplyr and tidyr after the workshop, you may want to check out this handy data transformation with dplyr cheatsheet and this one about tidyr.\n\nThe tidyverse package is an “umbrella-package” that installs several useful packages for data analysis which work well together, such as tidyr, dplyr, ggplot2, tibble, etc. These packages help us to work and interact with the data. They allow us to do many things with your data, such as subsetting, transforming, visualising, etc.\n\nIf you did the set up, you should have already installed the tidyverse package. Check to see if you have it by trying to load in from the library:\n\n## load the tidyverse packages, incl. dplyr\nlibrary(\"tidyverse\")\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nIf you got an error message there is no package called ‘tidyverse’ then you have not installed the package yet for this version of R. To install the tidyverse package type:\n\nBiocManager::install(\"tidyverse\")\n\nIf you had to install the tidyverse package, do not forget to load it in this R session by using the library() command above!\n\n\nInstead of read.csv(), we will read in our data using the read_csv() function (notice the _ instead of the .), from the tidyverse package readr.\n\nrna &lt;- read_csv(\"data/rnaseq.csv\")\n\nRows: 32428 Columns: 19\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (14): gene, sample, organism, sex, infection, strain, tissue, product, e...\ndbl  (5): expression, age, time, mouse, ENTREZID\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n## view the data\nrna\n\n# A tibble: 32,428 × 19\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…       1170 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 Apod    GSM254…      36194 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 3 Cyp2d22 GSM254…       4060 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 4 Klk6    GSM254…        287 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 5 Fcrls   GSM254…         85 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 6 Slc2a4  GSM254…        782 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 7 Exd2    GSM254…       1619 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 Gjc2    GSM254…        288 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 9 Plp1    GSM254…      43217 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n10 Gnb4    GSM254…       1071 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\n\n\n\n\n\n\nImportant\n\n\n\nNotice that the class of the data is now referred to as a “tibble”.\n\n\nTibbles tweak some of the behaviors of the data frame objects we introduced in the previously. The data structure is very similar to a data frame. For our purposes the only differences are that:\n\nIt displays the data type of each column under its name. Note that &lt;dbl&gt; is a data type defined to hold numeric values with decimal points.\nIt only prints the first few rows of data and only as many columns as fit on one screen.\n\nWe are now going to learn some of the most common dplyr functions:\n\nselect(): subset columns\nfilter(): subset rows on conditions\nmutate(): create new columns by using information from other columns\ngroup_by() and summarise(): create summary statistics on grouped data\narrange(): sort results\ncount(): count discrete values\n\n\n\n\nTo select columns of a data frame, use select(). The first argument to this function is the data frame (rna), and the subsequent arguments are the columns to keep.\n\nselect(rna, gene, sample, tissue, expression)\n\n# A tibble: 32,428 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545336 Cerebellum       1170\n 2 Apod    GSM2545336 Cerebellum      36194\n 3 Cyp2d22 GSM2545336 Cerebellum       4060\n 4 Klk6    GSM2545336 Cerebellum        287\n 5 Fcrls   GSM2545336 Cerebellum         85\n 6 Slc2a4  GSM2545336 Cerebellum        782\n 7 Exd2    GSM2545336 Cerebellum       1619\n 8 Gjc2    GSM2545336 Cerebellum        288\n 9 Plp1    GSM2545336 Cerebellum      43217\n10 Gnb4    GSM2545336 Cerebellum       1071\n# ℹ 32,418 more rows\n\n\nTo select all columns except certain ones, put a “-” in front of the variable to exclude it.\n\nselect(rna, -tissue, -organism)\n\n# A tibble: 32,428 × 17\n   gene    sample   expression   age sex   infection strain  time mouse ENTREZID\n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 Asl     GSM2545…       1170     8 Fema… Influenz… C57BL…     8    14   109900\n 2 Apod    GSM2545…      36194     8 Fema… Influenz… C57BL…     8    14    11815\n 3 Cyp2d22 GSM2545…       4060     8 Fema… Influenz… C57BL…     8    14    56448\n 4 Klk6    GSM2545…        287     8 Fema… Influenz… C57BL…     8    14    19144\n 5 Fcrls   GSM2545…         85     8 Fema… Influenz… C57BL…     8    14    80891\n 6 Slc2a4  GSM2545…        782     8 Fema… Influenz… C57BL…     8    14    20528\n 7 Exd2    GSM2545…       1619     8 Fema… Influenz… C57BL…     8    14    97827\n 8 Gjc2    GSM2545…        288     8 Fema… Influenz… C57BL…     8    14   118454\n 9 Plp1    GSM2545…      43217     8 Fema… Influenz… C57BL…     8    14    18823\n10 Gnb4    GSM2545…       1071     8 Fema… Influenz… C57BL…     8    14    14696\n# ℹ 32,418 more rows\n# ℹ 7 more variables: product &lt;chr&gt;, ensembl_gene_id &lt;chr&gt;,\n#   external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;, gene_biotype &lt;chr&gt;,\n#   phenotype_description &lt;chr&gt;, hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nThis will select all the variables in rna except tissue and organism.\nTo choose rows based on a specific criteria, use filter():\n\nfilter(rna, sex == \"Male\")\n\n# A tibble: 14,740 × 19\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…        626 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 2 Apod    GSM254…      13021 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 3 Cyp2d22 GSM254…       2171 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 4 Klk6    GSM254…        448 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 5 Fcrls   GSM254…        180 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 6 Slc2a4  GSM254…        313 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 7 Exd2    GSM254…       2366 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 8 Gjc2    GSM254…        310 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 9 Plp1    GSM254…      53126 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n10 Gnb4    GSM254…       1355 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n# ℹ 14,730 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\n\nfilter(rna, sex == \"Male\" & infection == \"NonInfected\")\n\n# A tibble: 4,422 × 19\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…        535 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 2 Apod    GSM254…      13668 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 3 Cyp2d22 GSM254…       2008 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 4 Klk6    GSM254…       1101 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 5 Fcrls   GSM254…        375 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 6 Slc2a4  GSM254…        249 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 7 Exd2    GSM254…       3126 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 8 Gjc2    GSM254…        791 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 9 Plp1    GSM254…      98658 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n10 Gnb4    GSM254…       2437 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n# ℹ 4,412 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nNow let’s imagine we are interested in the human homologs of the mouse genes analysed in this dataset. This information can be found in the last column of the rna tibble, named hsapiens_homolog_associated_gene_name. To visualise it easily, we will create a new table containing just the 2 columns gene and hsapiens_homolog_associated_gene_name.\n\ngenes &lt;- select(rna, gene, hsapiens_homolog_associated_gene_name)\ngenes\n\n# A tibble: 32,428 × 2\n   gene    hsapiens_homolog_associated_gene_name\n   &lt;chr&gt;   &lt;chr&gt;                                \n 1 Asl     ASL                                  \n 2 Apod    APOD                                 \n 3 Cyp2d22 CYP2D6                               \n 4 Klk6    KLK6                                 \n 5 Fcrls   FCRL2                                \n 6 Slc2a4  SLC2A4                               \n 7 Exd2    EXD2                                 \n 8 Gjc2    GJC2                                 \n 9 Plp1    PLP1                                 \n10 Gnb4    GNB4                                 \n# ℹ 32,418 more rows\n\n\nSome mouse genes have no human homologs. These can be retrieved using filter() and the is.na() function, that determines whether something is an NA.\n\nfilter(genes, is.na(hsapiens_homolog_associated_gene_name))\n\n# A tibble: 4,290 × 2\n   gene     hsapiens_homolog_associated_gene_name\n   &lt;chr&gt;    &lt;chr&gt;                                \n 1 Prodh    &lt;NA&gt;                                 \n 2 Tssk5    &lt;NA&gt;                                 \n 3 Vmn2r1   &lt;NA&gt;                                 \n 4 Gm10654  &lt;NA&gt;                                 \n 5 Hexa     &lt;NA&gt;                                 \n 6 Sult1a1  &lt;NA&gt;                                 \n 7 Gm6277   &lt;NA&gt;                                 \n 8 Tmem198b &lt;NA&gt;                                 \n 9 Adam1a   &lt;NA&gt;                                 \n10 Ebp      &lt;NA&gt;                                 \n# ℹ 4,280 more rows\n\n\nIf we want to keep only mouse genes that have a human homolog, we can insert a “!” symbol that negates the result, so we’re asking for every row where hsapiens_homolog_associated_gene_name is not an NA.\n\nfilter(genes, !is.na(hsapiens_homolog_associated_gene_name))\n\n# A tibble: 28,138 × 2\n   gene    hsapiens_homolog_associated_gene_name\n   &lt;chr&gt;   &lt;chr&gt;                                \n 1 Asl     ASL                                  \n 2 Apod    APOD                                 \n 3 Cyp2d22 CYP2D6                               \n 4 Klk6    KLK6                                 \n 5 Fcrls   FCRL2                                \n 6 Slc2a4  SLC2A4                               \n 7 Exd2    EXD2                                 \n 8 Gjc2    GJC2                                 \n 9 Plp1    PLP1                                 \n10 Gnb4    GNB4                                 \n# ℹ 28,128 more rows\n\n\n\n\n\nWhat if you want to select and filter at the same time? There are three ways to do this: use intermediate steps, nested functions, or pipes.\nWith intermediate steps, you create a temporary data frame and use that as input to the next function, like this:\n\nrna2 &lt;- filter(rna, sex == \"Male\")\nrna3 &lt;- select(rna2, gene, sample, tissue, expression)\nrna3\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\nThis is readable, but can clutter up your workspace with lots of intermediate objects that you have to name individually. With multiple steps, that can be hard to keep track of.\nYou can also nest functions (i.e. one function inside of another), like this:\n\nrna3 &lt;- select(filter(rna, sex == \"Male\"), gene, sample, tissue, expression)\nrna3\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\nThis is handy, but can be difficult to read if too many functions are nested, as R evaluates the expression from the inside out (in this case, filtering, then selecting).\nThe last option, pipes, are a recent addition to R. Pipes let you take the output of one function and send it directly to the next, which is useful when you need to do many things to the same dataset.\nPipes in R look like %&gt;% (made available via the magrittr package) or |&gt; (through base R). If you use RStudio, you can type the pipe with Ctrl + Shift + M if you have a PC or Cmd + Shift + M if you have a Mac.\nIn the above code, we use the pipe to send the rna dataset first through filter() to keep rows where sex is Male, then through select() to keep only the gene, sample, tissue, and expressioncolumns.\nThe pipe %&gt;% takes the object on its left and passes it directly as the first argument to the function on its right, we don’t need to explicitly include the data frame as an argument to the filter() and select() functions any more.\n\nrna %&gt;%\n  filter(sex == \"Male\") %&gt;%\n  select(gene, sample, tissue, expression)\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\nSome may find it helpful to read the pipe like the word “then”. For instance, in the above example, we took the data frame rna, then we filtered for rows with sex == \"Male\", then we selected columns gene, sample, tissue, and expression.\nThe dplyr functions by themselves are somewhat simple, but by combining them into linear workflows with the pipe, we can accomplish more complex manipulations of data frames.\nIf we want to create a new object with this smaller version of the data, we can assign it a new name:\n\nrna3 &lt;- rna %&gt;%\n  filter(sex == \"Male\") %&gt;%\n  select(gene, sample, tissue, expression)\n\nrna3\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nUsing pipes, subset the rna data to keep observations in female mice at time 0, where the gene has an expression higher than 50000, and retain only the columns gene, sample, time, expression and age.\n\n\n\n\n\nFrequently you’ll want to create new columns based on the values of existing columns, for example to do unit conversions, or to find the ratio of values in two columns. For this we’ll use mutate().\nTo create a new column of time in hours:\n\nrna %&gt;%\n  mutate(time_hours = time * 24) %&gt;%\n  select(time, time_hours)\n\n# A tibble: 32,428 × 2\n    time time_hours\n   &lt;dbl&gt;      &lt;dbl&gt;\n 1     8        192\n 2     8        192\n 3     8        192\n 4     8        192\n 5     8        192\n 6     8        192\n 7     8        192\n 8     8        192\n 9     8        192\n10     8        192\n# ℹ 32,418 more rows\n\n\nYou can also create a second new column based on the first new column within the same call of mutate():\n\nrna %&gt;%\n  mutate(time_hours = time * 24,\n         time_mn = time_hours * 60) %&gt;%\n  select(time, time_hours, time_mn)\n\n# A tibble: 32,428 × 3\n    time time_hours time_mn\n   &lt;dbl&gt;      &lt;dbl&gt;   &lt;dbl&gt;\n 1     8        192   11520\n 2     8        192   11520\n 3     8        192   11520\n 4     8        192   11520\n 5     8        192   11520\n 6     8        192   11520\n 7     8        192   11520\n 8     8        192   11520\n 9     8        192   11520\n10     8        192   11520\n# ℹ 32,418 more rows\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nCreate a new data frame from the rna data that meets the following criteria: contains only the gene, chromosome_name, phenotype_description, sample, and expression columns. The expression values should be log-transformed. This data frame must only contain genes located on sex chromosomes, associated with a phenotype_description, and with a log expression higher than 5.\nHint: think about how the commands should be ordered to produce this data frame!\n\n\n\n\n\nMany data analysis tasks can be approached using the split-apply-combine paradigm: split the data into groups, apply some analysis to each group, and then combine the results. dplyr makes this very easy through the use of the group_by() function.\n\nrna %&gt;%\n  group_by(gene)\n\n# A tibble: 32,428 × 19\n# Groups:   gene [1,474]\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…       1170 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 Apod    GSM254…      36194 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 3 Cyp2d22 GSM254…       4060 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 4 Klk6    GSM254…        287 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 5 Fcrls   GSM254…         85 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 6 Slc2a4  GSM254…        782 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 7 Exd2    GSM254…       1619 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 Gjc2    GSM254…        288 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 9 Plp1    GSM254…      43217 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n10 Gnb4    GSM254…       1071 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nThe group_by() function doesn’t perform any data processing, it groups the data into subsets: in the example above, our initial tibble of 32428 observations is split into 1474 groups based on the gene variable.\nWe could similarly decide to group the tibble by the samples:\n\nrna %&gt;%\n  group_by(sample)\n\n# A tibble: 32,428 × 19\n# Groups:   sample [22]\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…       1170 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 Apod    GSM254…      36194 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 3 Cyp2d22 GSM254…       4060 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 4 Klk6    GSM254…        287 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 5 Fcrls   GSM254…         85 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 6 Slc2a4  GSM254…        782 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 7 Exd2    GSM254…       1619 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 Gjc2    GSM254…        288 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 9 Plp1    GSM254…      43217 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n10 Gnb4    GSM254…       1071 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nHere our initial tibble of 32428 observations is split into 22 groups based on the sample variable.\nOnce the data has been grouped, subsequent operations will be applied on each group independently.\n\n\n\ngroup_by() is often used together with summarise(), which collapses each group into a single-row summary of that group.\ngroup_by() takes as arguments the column names that contain the categorical variables for which you want to calculate the summary statistics. So to compute the mean expression by gene:\n\nrna %&gt;%\n  group_by(gene) %&gt;%\n  summarise(mean_expression = mean(expression))\n\n# A tibble: 1,474 × 2\n   gene     mean_expression\n   &lt;chr&gt;              &lt;dbl&gt;\n 1 AI504432         1053.  \n 2 AW046200          131.  \n 3 AW551984          295.  \n 4 Aamp             4751.  \n 5 Abca12              4.55\n 6 Abcc8            2498.  \n 7 Abhd14a           525.  \n 8 Abi2             4909.  \n 9 Abi3bp           1002.  \n10 Abl2             2124.  \n# ℹ 1,464 more rows\n\n\nWe could also want to calculate the mean expression levels of all genes in each sample:\n\nrna %&gt;%\n  group_by(sample) %&gt;%\n  summarise(mean_expression = mean(expression))\n\n# A tibble: 22 × 2\n   sample     mean_expression\n   &lt;chr&gt;                &lt;dbl&gt;\n 1 GSM2545336           2062.\n 2 GSM2545337           1766.\n 3 GSM2545338           1668.\n 4 GSM2545339           1696.\n 5 GSM2545340           1682.\n 6 GSM2545341           1638.\n 7 GSM2545342           1594.\n 8 GSM2545343           2107.\n 9 GSM2545344           1712.\n10 GSM2545345           1700.\n# ℹ 12 more rows\n\n\nBut we can can also group by multiple columns:\n\nrna %&gt;%\n  group_by(gene, infection, time) %&gt;%\n  summarise(mean_expression = mean(expression))\n\n`summarise()` has grouped output by 'gene', 'infection'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 4,422 × 4\n# Groups:   gene, infection [2,948]\n   gene     infection    time mean_expression\n   &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;           &lt;dbl&gt;\n 1 AI504432 InfluenzaA      4           1104.\n 2 AI504432 InfluenzaA      8           1014 \n 3 AI504432 NonInfected     0           1034.\n 4 AW046200 InfluenzaA      4            152.\n 5 AW046200 InfluenzaA      8             81 \n 6 AW046200 NonInfected     0            155.\n 7 AW551984 InfluenzaA      4            302.\n 8 AW551984 InfluenzaA      8            342.\n 9 AW551984 NonInfected     0            238 \n10 Aamp     InfluenzaA      4           4870 \n# ℹ 4,412 more rows\n\n\nOnce the data is grouped, you can also summarise multiple variables at the same time (and not necessarily on the same variable). For instance, we could add a column indicating the median expression by gene and by condition:\n\nrna %&gt;%\n  group_by(gene, infection, time) %&gt;%\n  summarise(mean_expression = mean(expression),\n            median_expression = median(expression))\n\n`summarise()` has grouped output by 'gene', 'infection'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 4,422 × 5\n# Groups:   gene, infection [2,948]\n   gene     infection    time mean_expression median_expression\n   &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;           &lt;dbl&gt;             &lt;dbl&gt;\n 1 AI504432 InfluenzaA      4           1104.             1094.\n 2 AI504432 InfluenzaA      8           1014               985 \n 3 AI504432 NonInfected     0           1034.             1016 \n 4 AW046200 InfluenzaA      4            152.              144.\n 5 AW046200 InfluenzaA      8             81                82 \n 6 AW046200 NonInfected     0            155.              163 \n 7 AW551984 InfluenzaA      4            302.              245 \n 8 AW551984 InfluenzaA      8            342.              287 \n 9 AW551984 NonInfected     0            238               265 \n10 Aamp     InfluenzaA      4           4870              4708 \n# ℹ 4,412 more rows\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nCalculate the mean expression level of gene “Dok3” by timepoints.\n\n\n\n\n\nWhen working with data, we often want to know the number of observations found for each factor or combination of factors. For this task, dplyr provides count(). For example, if we wanted to count the number of rows of data for each infected and non-infected samples, we would do:\n\nrna %&gt;%\n    count(infection)\n\n# A tibble: 2 × 2\n  infection       n\n  &lt;chr&gt;       &lt;int&gt;\n1 InfluenzaA  22110\n2 NonInfected 10318\n\n\nThe count() function is shorthand for something we’ve already seen: grouping by a variable, and summarising it by counting the number of observations in that group. In other words, rna %&gt;% count(infection) is equivalent to:\n\nrna %&gt;%\n    group_by(infection) %&gt;%\n    summarise(n = n())\n\n# A tibble: 2 × 2\n  infection       n\n  &lt;chr&gt;       &lt;int&gt;\n1 InfluenzaA  22110\n2 NonInfected 10318\n\n\nThe previous example shows the use of count() to count the number of rows/observations for one factor (i.e., infection). If we wanted to count a combination of factors, such as infection and time, we would specify the first and the second factor as the arguments of count():\n\nrna %&gt;%\n    count(infection, time)\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      4 11792\n2 InfluenzaA      8 10318\n3 NonInfected     0 10318\n\n\nwhich is equivalent to this:\n\nrna %&gt;%\n  group_by(infection, time) %&gt;%\n  summarise(n = n())\n\n`summarise()` has grouped output by 'infection'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 3 × 3\n# Groups:   infection [2]\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      4 11792\n2 InfluenzaA      8 10318\n3 NonInfected     0 10318\n\n\nIt is sometimes useful to sort the result to facilitate the comparisons. We can use arrange() to sort the table. For instance, we might want to arrange the table above by time:\n\nrna %&gt;%\n  count(infection, time) %&gt;%\n  arrange(time)\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 NonInfected     0 10318\n2 InfluenzaA      4 11792\n3 InfluenzaA      8 10318\n\n\nor by counts:\n\nrna %&gt;%\n  count(infection, time) %&gt;%\n  arrange(n)\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      8 10318\n2 NonInfected     0 10318\n3 InfluenzaA      4 11792\n\n\nTo sort in descending order, we need to add the desc() function:\n\nrna %&gt;%\n  count(infection, time) %&gt;%\n  arrange(desc(n))\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      4 11792\n2 InfluenzaA      8 10318\n3 NonInfected     0 10318\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nHow many genes were analysed in each sample?\n\nUse group_by() and summarise() to evaluate the sequencing depth (the sum of all counts) in each sample. Which sample has the highest sequencing depth?\nPick one sample and evaluate the number of genes by biotype.\nIdentify genes associated with the “abnormal DNA methylation” phenotype description, and calculate their mean expression (in log) at time 0, time 4 and time 8.\n\n\n\n\n\n\nIn the rna tibble, the rows contain expression values (the unit) that are associated with a combination of 2 other variables: gene and sample.\nAll the other columns correspond to variables describing either the sample (organism, age, sex, …) or the gene (gene_biotype, ENTREZ_ID, product, …). The variables that don’t change with genes or with samples will have the same value in all the rows.\n\nrna %&gt;%\n  arrange(gene)\n\n# A tibble: 32,428 × 19\n   gene     sample expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 AI504432 GSM25…       1230 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 AI504432 GSM25…       1085 Mus mus…     8 Fema… NonInfec… C57BL…     0 Cereb…\n 3 AI504432 GSM25…        969 Mus mus…     8 Fema… NonInfec… C57BL…     0 Cereb…\n 4 AI504432 GSM25…       1284 Mus mus…     8 Fema… Influenz… C57BL…     4 Cereb…\n 5 AI504432 GSM25…        966 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 6 AI504432 GSM25…        918 Mus mus…     8 Male  Influenz… C57BL…     8 Cereb…\n 7 AI504432 GSM25…        985 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 AI504432 GSM25…        972 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 9 AI504432 GSM25…       1000 Mus mus…     8 Fema… Influenz… C57BL…     4 Cereb…\n10 AI504432 GSM25…        816 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nThis structure is called a long-format, as one column contains all the values, and other column(s) list(s) the context of the value.\nIn certain cases, the long-format is not really “human-readable”, and another format, a wide-format is preferred, as a more compact way of representing the data. This is typically the case with gene expression values that scientists are used to look as matrices, were rows represent genes and columns represent samples.\nIn this format, it would therefore become straightforward to explore the relationship between the gene expression levels within, and between, the samples.\nTo convert the gene expression values from rna into a wide-format, we need to create a new table where the values of the sample column would become the names of column variables.\nThe key point here is that we are still following a tidy data structure, but we have reshaped the data according to the observations of interest: expression levels per gene instead of recording them per gene and per sample.\nThe opposite transformation would be to transform column names into values of a new variable.\nWe can do both these of transformations with two tidyr functions, pivot_longer() and pivot_wider() (see here for details).\n\n\n\nLet’s select the first 3 columns of rna and use pivot_wider() to transform the data into a wide-format.\n\nrna_exp &lt;- rna %&gt;%\n  select(gene, sample, expression)\nrna_exp\n\n# A tibble: 32,428 × 3\n   gene    sample     expression\n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545336       1170\n 2 Apod    GSM2545336      36194\n 3 Cyp2d22 GSM2545336       4060\n 4 Klk6    GSM2545336        287\n 5 Fcrls   GSM2545336         85\n 6 Slc2a4  GSM2545336        782\n 7 Exd2    GSM2545336       1619\n 8 Gjc2    GSM2545336        288\n 9 Plp1    GSM2545336      43217\n10 Gnb4    GSM2545336       1071\n# ℹ 32,418 more rows\n\n\n\n\n\n\n\n\nNote\n\n\n\npivot_wider takes three main arguments:\n\nthe data to be transformed;\nthe names_from : the column whose values will become new column names;\nthe values_from: the column whose values will fill the new columns.\n\n\n\n\n\nrna_wide &lt;- rna_exp %&gt;%\n  pivot_wider(names_from = sample,\n              values_from = expression)\nrna_wide\n\n# A tibble: 1,474 × 23\n   gene    GSM2545336 GSM2545337 GSM2545338 GSM2545339 GSM2545340 GSM2545341\n   &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n 1 Asl           1170        361        400        586        626        988\n 2 Apod         36194      10347       9173      10620      13021      29594\n 3 Cyp2d22       4060       1616       1603       1901       2171       3349\n 4 Klk6           287        629        641        578        448        195\n 5 Fcrls           85        233        244        237        180         38\n 6 Slc2a4         782        231        248        265        313        786\n 7 Exd2          1619       2288       2235       2513       2366       1359\n 8 Gjc2           288        595        568        551        310        146\n 9 Plp1         43217     101241      96534      58354      53126      27173\n10 Gnb4          1071       1791       1867       1430       1355        798\n# ℹ 1,464 more rows\n# ℹ 16 more variables: GSM2545342 &lt;dbl&gt;, GSM2545343 &lt;dbl&gt;, GSM2545344 &lt;dbl&gt;,\n#   GSM2545345 &lt;dbl&gt;, GSM2545346 &lt;dbl&gt;, GSM2545347 &lt;dbl&gt;, GSM2545348 &lt;dbl&gt;,\n#   GSM2545349 &lt;dbl&gt;, GSM2545350 &lt;dbl&gt;, GSM2545351 &lt;dbl&gt;, GSM2545352 &lt;dbl&gt;,\n#   GSM2545353 &lt;dbl&gt;, GSM2545354 &lt;dbl&gt;, GSM2545362 &lt;dbl&gt;, GSM2545363 &lt;dbl&gt;,\n#   GSM2545380 &lt;dbl&gt;\n\n\nNote that by default, the pivot_wider() function will add NA for missing values.\nLet’s imagine that for some reason, we had some missing expression values for some genes in certain samples. In the following fictive example, the gene Cyp2d22 has only one expression value, in GSM2545338 sample.\n\nrna_with_missing_values &lt;- rna %&gt;%\n  select(gene, sample, expression) %&gt;%\n  filter(gene %in% c(\"Asl\", \"Apod\", \"Cyp2d22\")) %&gt;%\n  filter(sample %in% c(\"GSM2545336\", \"GSM2545337\", \"GSM2545338\")) %&gt;%\n  arrange(sample) %&gt;%\n  filter(!(gene == \"Cyp2d22\" & sample != \"GSM2545338\"))\nrna_with_missing_values\n\n# A tibble: 7 × 3\n  gene    sample     expression\n  &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n1 Asl     GSM2545336       1170\n2 Apod    GSM2545336      36194\n3 Asl     GSM2545337        361\n4 Apod    GSM2545337      10347\n5 Asl     GSM2545338        400\n6 Apod    GSM2545338       9173\n7 Cyp2d22 GSM2545338       1603\n\n\nBy default, the pivot_wider() function will add NA for missing values. This can be parameterised with the values_fill argument of the pivot_wider() function.\n\nrna_with_missing_values %&gt;%\n  pivot_wider(names_from = sample,values_from = expression)\n\n# A tibble: 3 × 4\n  gene    GSM2545336 GSM2545337 GSM2545338\n  &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 Asl           1170        361        400\n2 Apod         36194      10347       9173\n3 Cyp2d22         NA         NA       1603\n\n\n\nrna_with_missing_values %&gt;%\n  pivot_wider(names_from = sample,values_from = expression,values_fill = 0)\n\n# A tibble: 3 × 4\n  gene    GSM2545336 GSM2545337 GSM2545338\n  &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 Asl           1170        361        400\n2 Apod         36194      10347       9173\n3 Cyp2d22          0          0       1603\n\n\n\n\n\nIn the opposite situation we are using the column names and turning them into a pair of new variables. One variable represents the column names as values, and the other variable contains the values previously associated with the column names.\n\n\n\n\n\n\nNote\n\n\n\npivot_longer() takes four main arguments:\n\nthe data to be transformed;\nthe names_to: the new column name we wish to create and populate with the current column names;\nthe values_to: the new column name we wish to create and populate with current values;\nthe names of the columns to be used to populate the names_to and values_to variables (or to drop).\n\n\n\n\nTo recreate rna_long from rna_wide we would create a key called sample and value called expression and use all columns except gene for the key variable. Here we drop gene column with a minus sign.\n\n\n\n\n\n\nImportant\n\n\n\nNotice how the new variable names are to be quoted here.\n\n\n\nrna_long &lt;- rna_wide %&gt;%\n    pivot_longer(names_to = \"sample\",\n                 values_to = \"expression\",\n                 -gene)\nrna_long\n\n# A tibble: 32,428 × 3\n   gene  sample     expression\n   &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl   GSM2545336       1170\n 2 Asl   GSM2545337        361\n 3 Asl   GSM2545338        400\n 4 Asl   GSM2545339        586\n 5 Asl   GSM2545340        626\n 6 Asl   GSM2545341        988\n 7 Asl   GSM2545342        836\n 8 Asl   GSM2545343        535\n 9 Asl   GSM2545344        586\n10 Asl   GSM2545345        597\n# ℹ 32,418 more rows\n\n\nWe could also have used a specification for what columns to include. This can be useful if you have a large number of identifying columns, and it’s easier to specify what to gather than what to leave alone. Here the starts_with() function can help to retrieve sample names without having to list them all! Another possibility would be to use the : operator!\n\nrna_wide %&gt;%\n    pivot_longer(names_to = \"sample\",\n                 values_to = \"expression\",\n                 cols = starts_with(\"GSM\"))\n\n# A tibble: 32,428 × 3\n   gene  sample     expression\n   &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl   GSM2545336       1170\n 2 Asl   GSM2545337        361\n 3 Asl   GSM2545338        400\n 4 Asl   GSM2545339        586\n 5 Asl   GSM2545340        626\n 6 Asl   GSM2545341        988\n 7 Asl   GSM2545342        836\n 8 Asl   GSM2545343        535\n 9 Asl   GSM2545344        586\n10 Asl   GSM2545345        597\n# ℹ 32,418 more rows\n\n\n\nrna_wide %&gt;%\n    pivot_longer(names_to = \"sample\",\n                 values_to = \"expression\",\n                 GSM2545336:GSM2545380)\n\n# A tibble: 32,428 × 3\n   gene  sample     expression\n   &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl   GSM2545336       1170\n 2 Asl   GSM2545337        361\n 3 Asl   GSM2545338        400\n 4 Asl   GSM2545339        586\n 5 Asl   GSM2545340        626\n 6 Asl   GSM2545341        988\n 7 Asl   GSM2545342        836\n 8 Asl   GSM2545343        535\n 9 Asl   GSM2545344        586\n10 Asl   GSM2545345        597\n# ℹ 32,418 more rows\n\n\n\n\n\n\n\n\nImportant\n\n\n\nNote that if we had missing values in the wide-format, the NA would be included in the new long format.\n\n\nRemember our previous fictive tibble containing missing values:\n\nrna_with_missing_values\n\n# A tibble: 7 × 3\n  gene    sample     expression\n  &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n1 Asl     GSM2545336       1170\n2 Apod    GSM2545336      36194\n3 Asl     GSM2545337        361\n4 Apod    GSM2545337      10347\n5 Asl     GSM2545338        400\n6 Apod    GSM2545338       9173\n7 Cyp2d22 GSM2545338       1603\n\n\n\nwide_with_NA &lt;- rna_with_missing_values %&gt;%\n  pivot_wider(names_from = sample,\n              values_from = expression)\nwide_with_NA\n\n# A tibble: 3 × 4\n  gene    GSM2545336 GSM2545337 GSM2545338\n  &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 Asl           1170        361        400\n2 Apod         36194      10347       9173\n3 Cyp2d22         NA         NA       1603\n\n\n\nwide_with_NA %&gt;%\n    pivot_longer(names_to = \"sample\",\n                 values_to = \"expression\",\n                 -gene)\n\n# A tibble: 9 × 3\n  gene    sample     expression\n  &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n1 Asl     GSM2545336       1170\n2 Asl     GSM2545337        361\n3 Asl     GSM2545338        400\n4 Apod    GSM2545336      36194\n5 Apod    GSM2545337      10347\n6 Apod    GSM2545338       9173\n7 Cyp2d22 GSM2545336         NA\n8 Cyp2d22 GSM2545337         NA\n9 Cyp2d22 GSM2545338       1603\n\n\nPivoting to wider and longer formats can be a useful way to balance out a dataset so every replicate has the same composition.\n\n\n\n\n\n\nQuestion\n\n\n\nStarting from the rna table, use the pivot_wider() function to create a wide-format table giving the gene expression levels in each mouse. Then use the pivot_longer() function to restore a long-format table.\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nSubset genes located on X and Y chromosomes from the rna data frame and spread the data frame with sex as columns, chromosome_name as rows, and the mean expression of genes located in each chromosome as the values, as in the following tibble:\n\nYou will need to summarise before reshaping!\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nUse the rna dataset to create an expression matrix where each row represents the mean expression levels of genes and columns represent the different timepoints.\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nUse the previous data frame containing mean expression levels per timepoint and create a new column containing fold-changes between timepoint 8 and timepoint 0, and fold-changes between timepoint 8 and timepoint 4. Convert this table into a long-format table gathering the fold-changes calculated.\n\n\n\n\n\nIn many real life situations, data are spread across multiple tables. Usually this occurs because different types of information are collected from different sources.\nIt may be desirable for some analyses to combine data from two or more tables into a single data frame based on a column that would be common to all the tables.\nThe dplyr package provides a set of join functions for combining two data frames based on matches within specified columns. Here, we provide a short introduction to joins. For further reading, please refer to the chapter about table joins. The Data Transformation Cheat Sheet also provides a short overview on table joins.\nWe are going to illustrate join using a small table, rna_mini that we will create by subsetting the original rna table, keeping only 3 columns and 10 lines.\n\nrna_mini &lt;- rna %&gt;%\n   select(gene, sample, expression) %&gt;%\n   head(10)\nrna_mini\n\n# A tibble: 10 × 3\n   gene    sample     expression\n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545336       1170\n 2 Apod    GSM2545336      36194\n 3 Cyp2d22 GSM2545336       4060\n 4 Klk6    GSM2545336        287\n 5 Fcrls   GSM2545336         85\n 6 Slc2a4  GSM2545336        782\n 7 Exd2    GSM2545336       1619\n 8 Gjc2    GSM2545336        288\n 9 Plp1    GSM2545336      43217\n10 Gnb4    GSM2545336       1071\n\n\nThe second table, annot1, contains 2 columns, gene and gene_description. You can either download annot1.csv by clicking on the link and then moving it to the data/ folder, or you can use the R code below to download it directly to the folder.\n\ndownload.file(url = \"https://carpentries-incubator.github.io/bioc-intro/data/annot1.csv\",\n              destfile = \"data/annot1.csv\")\nannot1 &lt;- read_csv(file = \"data/annot1.csv\")\n\nRows: 10 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): gene, gene_description\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nannot1\n\n# A tibble: 10 × 2\n   gene    gene_description                                                     \n   &lt;chr&gt;   &lt;chr&gt;                                                                \n 1 Cyp2d22 cytochrome P450, family 2, subfamily d, polypeptide 22 [Source:MGI S…\n 2 Klk6    kallikrein related-peptidase 6 [Source:MGI Symbol;Acc:MGI:1343166]   \n 3 Fcrls   Fc receptor-like S, scavenger receptor [Source:MGI Symbol;Acc:MGI:19…\n 4 Plp1    proteolipid protein (myelin) 1 [Source:MGI Symbol;Acc:MGI:97623]     \n 5 Exd2    exonuclease 3'-5' domain containing 2 [Source:MGI Symbol;Acc:MGI:192…\n 6 Apod    apolipoprotein D [Source:MGI Symbol;Acc:MGI:88056]                   \n 7 Gnb4    guanine nucleotide binding protein (G protein), beta 4 [Source:MGI S…\n 8 Slc2a4  solute carrier family 2 (facilitated glucose transporter), member 4 …\n 9 Asl     argininosuccinate lyase [Source:MGI Symbol;Acc:MGI:88084]            \n10 Gjc2    gap junction protein, gamma 2 [Source:MGI Symbol;Acc:MGI:2153060]    \n\n\nWe now want to join these two tables into a single one containing all variables using the full_join() function from the dplyr package. The function will automatically find the common variable to match columns from the first and second table. In this case, gene is the common variable. Such variables are called keys. Keys are used to match observations across different tables.\n\nfull_join(rna_mini, annot1)\n\nJoining with `by = join_by(gene)`\n\n\n# A tibble: 10 × 4\n   gene    sample     expression gene_description                               \n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;                                          \n 1 Asl     GSM2545336       1170 argininosuccinate lyase [Source:MGI Symbol;Acc…\n 2 Apod    GSM2545336      36194 apolipoprotein D [Source:MGI Symbol;Acc:MGI:88…\n 3 Cyp2d22 GSM2545336       4060 cytochrome P450, family 2, subfamily d, polype…\n 4 Klk6    GSM2545336        287 kallikrein related-peptidase 6 [Source:MGI Sym…\n 5 Fcrls   GSM2545336         85 Fc receptor-like S, scavenger receptor [Source…\n 6 Slc2a4  GSM2545336        782 solute carrier family 2 (facilitated glucose t…\n 7 Exd2    GSM2545336       1619 exonuclease 3'-5' domain containing 2 [Source:…\n 8 Gjc2    GSM2545336        288 gap junction protein, gamma 2 [Source:MGI Symb…\n 9 Plp1    GSM2545336      43217 proteolipid protein (myelin) 1 [Source:MGI Sym…\n10 Gnb4    GSM2545336       1071 guanine nucleotide binding protein (G protein)…\n\n\nIn real life, gene annotations are sometimes labelled differently.\nThe annot2 table is exactly the same than annot1 except that the variable containing gene names is labelled differently. Again, either download annot2.csv yourself and move it to data/ or use the R code below.\n\ndownload.file(url = \"https://carpentries-incubator.github.io/bioc-intro/data/annot2.csv\",\n              destfile = \"data/annot2.csv\")\nannot2 &lt;- read_csv(file = \"data/annot2.csv\")\n\nRows: 10 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): external_gene_name, description\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nannot2\n\n# A tibble: 10 × 2\n   external_gene_name description                                               \n   &lt;chr&gt;              &lt;chr&gt;                                                     \n 1 Cyp2d22            cytochrome P450, family 2, subfamily d, polypeptide 22 [S…\n 2 Klk6               kallikrein related-peptidase 6 [Source:MGI Symbol;Acc:MGI…\n 3 Fcrls              Fc receptor-like S, scavenger receptor [Source:MGI Symbol…\n 4 Plp1               proteolipid protein (myelin) 1 [Source:MGI Symbol;Acc:MGI…\n 5 Exd2               exonuclease 3'-5' domain containing 2 [Source:MGI Symbol;…\n 6 Apod               apolipoprotein D [Source:MGI Symbol;Acc:MGI:88056]        \n 7 Gnb4               guanine nucleotide binding protein (G protein), beta 4 [S…\n 8 Slc2a4             solute carrier family 2 (facilitated glucose transporter)…\n 9 Asl                argininosuccinate lyase [Source:MGI Symbol;Acc:MGI:88084] \n10 Gjc2               gap junction protein, gamma 2 [Source:MGI Symbol;Acc:MGI:…\n\n\nIn case none of the variable names match, we can set manually the variables to use for the matching. These variables can be set using the by argument, as shown below with rna_mini and annot2 tables.\n\nfull_join(rna_mini, annot2, by = c(\"gene\" = \"external_gene_name\"))\n\n# A tibble: 10 × 4\n   gene    sample     expression description                                    \n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;                                          \n 1 Asl     GSM2545336       1170 argininosuccinate lyase [Source:MGI Symbol;Acc…\n 2 Apod    GSM2545336      36194 apolipoprotein D [Source:MGI Symbol;Acc:MGI:88…\n 3 Cyp2d22 GSM2545336       4060 cytochrome P450, family 2, subfamily d, polype…\n 4 Klk6    GSM2545336        287 kallikrein related-peptidase 6 [Source:MGI Sym…\n 5 Fcrls   GSM2545336         85 Fc receptor-like S, scavenger receptor [Source…\n 6 Slc2a4  GSM2545336        782 solute carrier family 2 (facilitated glucose t…\n 7 Exd2    GSM2545336       1619 exonuclease 3'-5' domain containing 2 [Source:…\n 8 Gjc2    GSM2545336        288 gap junction protein, gamma 2 [Source:MGI Symb…\n 9 Plp1    GSM2545336      43217 proteolipid protein (myelin) 1 [Source:MGI Sym…\n10 Gnb4    GSM2545336       1071 guanine nucleotide binding protein (G protein)…\n\n\nAs can be seen above, the variable name of the first table is retained in the joined one.\n\n\n\n\n\n\nQuestion\n\n\n\nDownload the annot3 table by clicking here and put the table in your data/ repository. Using the full_join() function, join tables rna_mini and annot3. What has happened for genes Klk6, mt-Tf, mt-Rnr1, mt-Tv, mt-Rnr2, and mt-Tl1 ?\n\n\n\n\n\nNow that you have learned how to use dplyr to extract information from or summarise your raw data, you may want to export these new data sets to share them with your collaborators or for archival.\nSimilar to the read_csv() function used for reading CSV files into R, there is a write_csv() function that generates CSV files from data frames.\nBefore using write_csv(), we are going to create a new folder, data_output, in our working directory that will store this generated dataset. We don’t want to write generated datasets in the same directory as our raw data. It’s good practice to keep them separate. The data folder should only contain the raw, unaltered data, and should be left alone to make sure we don’t delete or modify it. In contrast, our script will generate the contents of the data_output directory, so even if the files it contains are deleted, we can always re-generate them.\nLet’s use write_csv() to save the rna_wide table that we have created previously.\n\nwrite_csv(rna_wide, file = \"data_output/rna_wide.csv\")"
  },
  {
    "objectID": "bioc_intro_dataManipulation.html#data-manipulation-using-dplyr-and-tidyr",
    "href": "bioc_intro_dataManipulation.html#data-manipulation-using-dplyr-and-tidyr",
    "title": "Manipulating and analysing data with dplyr",
    "section": "",
    "text": "Bracket subsetting is handy, but it can be cumbersome and difficult to read, especially for complicated operations.\nSome packages can greatly facilitate our task when we manipulate data. Packages in R are basically sets of additional functions that let you do more stuff. The functions we’ve been using so far, like str() or data.frame(), come built into R; Loading packages can give you access to other specific functions. Before you use a package for the first time you need to install it on your machine, and then you should import it in every subsequent R session when you need it.\n\nThe package dplyr provides powerful tools for data manipulation tasks. It is built to work directly with data frames, with many manipulation tasks optimised.\nAs we will see latter on, sometimes we want a data frame to be reshaped to be able to do some specific analyses or for visualisation. The package tidyr addresses this common problem of reshaping data and provides tools for manipulating data in a tidy way.\n\nTo learn more about dplyr and tidyr after the workshop, you may want to check out this handy data transformation with dplyr cheatsheet and this one about tidyr.\n\nThe tidyverse package is an “umbrella-package” that installs several useful packages for data analysis which work well together, such as tidyr, dplyr, ggplot2, tibble, etc. These packages help us to work and interact with the data. They allow us to do many things with your data, such as subsetting, transforming, visualising, etc.\n\nIf you did the set up, you should have already installed the tidyverse package. Check to see if you have it by trying to load in from the library:\n\n## load the tidyverse packages, incl. dplyr\nlibrary(\"tidyverse\")\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nIf you got an error message there is no package called ‘tidyverse’ then you have not installed the package yet for this version of R. To install the tidyverse package type:\n\nBiocManager::install(\"tidyverse\")\n\nIf you had to install the tidyverse package, do not forget to load it in this R session by using the library() command above!\n\n\nInstead of read.csv(), we will read in our data using the read_csv() function (notice the _ instead of the .), from the tidyverse package readr.\n\nrna &lt;- read_csv(\"data/rnaseq.csv\")\n\nRows: 32428 Columns: 19\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (14): gene, sample, organism, sex, infection, strain, tissue, product, e...\ndbl  (5): expression, age, time, mouse, ENTREZID\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n## view the data\nrna\n\n# A tibble: 32,428 × 19\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…       1170 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 Apod    GSM254…      36194 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 3 Cyp2d22 GSM254…       4060 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 4 Klk6    GSM254…        287 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 5 Fcrls   GSM254…         85 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 6 Slc2a4  GSM254…        782 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 7 Exd2    GSM254…       1619 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 Gjc2    GSM254…        288 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 9 Plp1    GSM254…      43217 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n10 Gnb4    GSM254…       1071 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\n\n\n\n\n\n\nImportant\n\n\n\nNotice that the class of the data is now referred to as a “tibble”.\n\n\nTibbles tweak some of the behaviors of the data frame objects we introduced in the previously. The data structure is very similar to a data frame. For our purposes the only differences are that:\n\nIt displays the data type of each column under its name. Note that &lt;dbl&gt; is a data type defined to hold numeric values with decimal points.\nIt only prints the first few rows of data and only as many columns as fit on one screen.\n\nWe are now going to learn some of the most common dplyr functions:\n\nselect(): subset columns\nfilter(): subset rows on conditions\nmutate(): create new columns by using information from other columns\ngroup_by() and summarise(): create summary statistics on grouped data\narrange(): sort results\ncount(): count discrete values\n\n\n\n\nTo select columns of a data frame, use select(). The first argument to this function is the data frame (rna), and the subsequent arguments are the columns to keep.\n\nselect(rna, gene, sample, tissue, expression)\n\n# A tibble: 32,428 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545336 Cerebellum       1170\n 2 Apod    GSM2545336 Cerebellum      36194\n 3 Cyp2d22 GSM2545336 Cerebellum       4060\n 4 Klk6    GSM2545336 Cerebellum        287\n 5 Fcrls   GSM2545336 Cerebellum         85\n 6 Slc2a4  GSM2545336 Cerebellum        782\n 7 Exd2    GSM2545336 Cerebellum       1619\n 8 Gjc2    GSM2545336 Cerebellum        288\n 9 Plp1    GSM2545336 Cerebellum      43217\n10 Gnb4    GSM2545336 Cerebellum       1071\n# ℹ 32,418 more rows\n\n\nTo select all columns except certain ones, put a “-” in front of the variable to exclude it.\n\nselect(rna, -tissue, -organism)\n\n# A tibble: 32,428 × 17\n   gene    sample   expression   age sex   infection strain  time mouse ENTREZID\n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 Asl     GSM2545…       1170     8 Fema… Influenz… C57BL…     8    14   109900\n 2 Apod    GSM2545…      36194     8 Fema… Influenz… C57BL…     8    14    11815\n 3 Cyp2d22 GSM2545…       4060     8 Fema… Influenz… C57BL…     8    14    56448\n 4 Klk6    GSM2545…        287     8 Fema… Influenz… C57BL…     8    14    19144\n 5 Fcrls   GSM2545…         85     8 Fema… Influenz… C57BL…     8    14    80891\n 6 Slc2a4  GSM2545…        782     8 Fema… Influenz… C57BL…     8    14    20528\n 7 Exd2    GSM2545…       1619     8 Fema… Influenz… C57BL…     8    14    97827\n 8 Gjc2    GSM2545…        288     8 Fema… Influenz… C57BL…     8    14   118454\n 9 Plp1    GSM2545…      43217     8 Fema… Influenz… C57BL…     8    14    18823\n10 Gnb4    GSM2545…       1071     8 Fema… Influenz… C57BL…     8    14    14696\n# ℹ 32,418 more rows\n# ℹ 7 more variables: product &lt;chr&gt;, ensembl_gene_id &lt;chr&gt;,\n#   external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;, gene_biotype &lt;chr&gt;,\n#   phenotype_description &lt;chr&gt;, hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nThis will select all the variables in rna except tissue and organism.\nTo choose rows based on a specific criteria, use filter():\n\nfilter(rna, sex == \"Male\")\n\n# A tibble: 14,740 × 19\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…        626 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 2 Apod    GSM254…      13021 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 3 Cyp2d22 GSM254…       2171 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 4 Klk6    GSM254…        448 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 5 Fcrls   GSM254…        180 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 6 Slc2a4  GSM254…        313 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 7 Exd2    GSM254…       2366 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 8 Gjc2    GSM254…        310 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 9 Plp1    GSM254…      53126 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n10 Gnb4    GSM254…       1355 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n# ℹ 14,730 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\n\nfilter(rna, sex == \"Male\" & infection == \"NonInfected\")\n\n# A tibble: 4,422 × 19\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…        535 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 2 Apod    GSM254…      13668 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 3 Cyp2d22 GSM254…       2008 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 4 Klk6    GSM254…       1101 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 5 Fcrls   GSM254…        375 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 6 Slc2a4  GSM254…        249 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 7 Exd2    GSM254…       3126 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 8 Gjc2    GSM254…        791 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 9 Plp1    GSM254…      98658 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n10 Gnb4    GSM254…       2437 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n# ℹ 4,412 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nNow let’s imagine we are interested in the human homologs of the mouse genes analysed in this dataset. This information can be found in the last column of the rna tibble, named hsapiens_homolog_associated_gene_name. To visualise it easily, we will create a new table containing just the 2 columns gene and hsapiens_homolog_associated_gene_name.\n\ngenes &lt;- select(rna, gene, hsapiens_homolog_associated_gene_name)\ngenes\n\n# A tibble: 32,428 × 2\n   gene    hsapiens_homolog_associated_gene_name\n   &lt;chr&gt;   &lt;chr&gt;                                \n 1 Asl     ASL                                  \n 2 Apod    APOD                                 \n 3 Cyp2d22 CYP2D6                               \n 4 Klk6    KLK6                                 \n 5 Fcrls   FCRL2                                \n 6 Slc2a4  SLC2A4                               \n 7 Exd2    EXD2                                 \n 8 Gjc2    GJC2                                 \n 9 Plp1    PLP1                                 \n10 Gnb4    GNB4                                 \n# ℹ 32,418 more rows\n\n\nSome mouse genes have no human homologs. These can be retrieved using filter() and the is.na() function, that determines whether something is an NA.\n\nfilter(genes, is.na(hsapiens_homolog_associated_gene_name))\n\n# A tibble: 4,290 × 2\n   gene     hsapiens_homolog_associated_gene_name\n   &lt;chr&gt;    &lt;chr&gt;                                \n 1 Prodh    &lt;NA&gt;                                 \n 2 Tssk5    &lt;NA&gt;                                 \n 3 Vmn2r1   &lt;NA&gt;                                 \n 4 Gm10654  &lt;NA&gt;                                 \n 5 Hexa     &lt;NA&gt;                                 \n 6 Sult1a1  &lt;NA&gt;                                 \n 7 Gm6277   &lt;NA&gt;                                 \n 8 Tmem198b &lt;NA&gt;                                 \n 9 Adam1a   &lt;NA&gt;                                 \n10 Ebp      &lt;NA&gt;                                 \n# ℹ 4,280 more rows\n\n\nIf we want to keep only mouse genes that have a human homolog, we can insert a “!” symbol that negates the result, so we’re asking for every row where hsapiens_homolog_associated_gene_name is not an NA.\n\nfilter(genes, !is.na(hsapiens_homolog_associated_gene_name))\n\n# A tibble: 28,138 × 2\n   gene    hsapiens_homolog_associated_gene_name\n   &lt;chr&gt;   &lt;chr&gt;                                \n 1 Asl     ASL                                  \n 2 Apod    APOD                                 \n 3 Cyp2d22 CYP2D6                               \n 4 Klk6    KLK6                                 \n 5 Fcrls   FCRL2                                \n 6 Slc2a4  SLC2A4                               \n 7 Exd2    EXD2                                 \n 8 Gjc2    GJC2                                 \n 9 Plp1    PLP1                                 \n10 Gnb4    GNB4                                 \n# ℹ 28,128 more rows\n\n\n\n\n\nWhat if you want to select and filter at the same time? There are three ways to do this: use intermediate steps, nested functions, or pipes.\nWith intermediate steps, you create a temporary data frame and use that as input to the next function, like this:\n\nrna2 &lt;- filter(rna, sex == \"Male\")\nrna3 &lt;- select(rna2, gene, sample, tissue, expression)\nrna3\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\nThis is readable, but can clutter up your workspace with lots of intermediate objects that you have to name individually. With multiple steps, that can be hard to keep track of.\nYou can also nest functions (i.e. one function inside of another), like this:\n\nrna3 &lt;- select(filter(rna, sex == \"Male\"), gene, sample, tissue, expression)\nrna3\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\nThis is handy, but can be difficult to read if too many functions are nested, as R evaluates the expression from the inside out (in this case, filtering, then selecting).\nThe last option, pipes, are a recent addition to R. Pipes let you take the output of one function and send it directly to the next, which is useful when you need to do many things to the same dataset.\nPipes in R look like %&gt;% (made available via the magrittr package) or |&gt; (through base R). If you use RStudio, you can type the pipe with Ctrl + Shift + M if you have a PC or Cmd + Shift + M if you have a Mac.\nIn the above code, we use the pipe to send the rna dataset first through filter() to keep rows where sex is Male, then through select() to keep only the gene, sample, tissue, and expressioncolumns.\nThe pipe %&gt;% takes the object on its left and passes it directly as the first argument to the function on its right, we don’t need to explicitly include the data frame as an argument to the filter() and select() functions any more.\n\nrna %&gt;%\n  filter(sex == \"Male\") %&gt;%\n  select(gene, sample, tissue, expression)\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\nSome may find it helpful to read the pipe like the word “then”. For instance, in the above example, we took the data frame rna, then we filtered for rows with sex == \"Male\", then we selected columns gene, sample, tissue, and expression.\nThe dplyr functions by themselves are somewhat simple, but by combining them into linear workflows with the pipe, we can accomplish more complex manipulations of data frames.\nIf we want to create a new object with this smaller version of the data, we can assign it a new name:\n\nrna3 &lt;- rna %&gt;%\n  filter(sex == \"Male\") %&gt;%\n  select(gene, sample, tissue, expression)\n\nrna3\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nUsing pipes, subset the rna data to keep observations in female mice at time 0, where the gene has an expression higher than 50000, and retain only the columns gene, sample, time, expression and age.\n\n\n\n\n\nFrequently you’ll want to create new columns based on the values of existing columns, for example to do unit conversions, or to find the ratio of values in two columns. For this we’ll use mutate().\nTo create a new column of time in hours:\n\nrna %&gt;%\n  mutate(time_hours = time * 24) %&gt;%\n  select(time, time_hours)\n\n# A tibble: 32,428 × 2\n    time time_hours\n   &lt;dbl&gt;      &lt;dbl&gt;\n 1     8        192\n 2     8        192\n 3     8        192\n 4     8        192\n 5     8        192\n 6     8        192\n 7     8        192\n 8     8        192\n 9     8        192\n10     8        192\n# ℹ 32,418 more rows\n\n\nYou can also create a second new column based on the first new column within the same call of mutate():\n\nrna %&gt;%\n  mutate(time_hours = time * 24,\n         time_mn = time_hours * 60) %&gt;%\n  select(time, time_hours, time_mn)\n\n# A tibble: 32,428 × 3\n    time time_hours time_mn\n   &lt;dbl&gt;      &lt;dbl&gt;   &lt;dbl&gt;\n 1     8        192   11520\n 2     8        192   11520\n 3     8        192   11520\n 4     8        192   11520\n 5     8        192   11520\n 6     8        192   11520\n 7     8        192   11520\n 8     8        192   11520\n 9     8        192   11520\n10     8        192   11520\n# ℹ 32,418 more rows\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nCreate a new data frame from the rna data that meets the following criteria: contains only the gene, chromosome_name, phenotype_description, sample, and expression columns. The expression values should be log-transformed. This data frame must only contain genes located on sex chromosomes, associated with a phenotype_description, and with a log expression higher than 5.\nHint: think about how the commands should be ordered to produce this data frame!\n\n\n\n\n\nMany data analysis tasks can be approached using the split-apply-combine paradigm: split the data into groups, apply some analysis to each group, and then combine the results. dplyr makes this very easy through the use of the group_by() function.\n\nrna %&gt;%\n  group_by(gene)\n\n# A tibble: 32,428 × 19\n# Groups:   gene [1,474]\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…       1170 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 Apod    GSM254…      36194 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 3 Cyp2d22 GSM254…       4060 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 4 Klk6    GSM254…        287 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 5 Fcrls   GSM254…         85 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 6 Slc2a4  GSM254…        782 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 7 Exd2    GSM254…       1619 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 Gjc2    GSM254…        288 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 9 Plp1    GSM254…      43217 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n10 Gnb4    GSM254…       1071 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nThe group_by() function doesn’t perform any data processing, it groups the data into subsets: in the example above, our initial tibble of 32428 observations is split into 1474 groups based on the gene variable.\nWe could similarly decide to group the tibble by the samples:\n\nrna %&gt;%\n  group_by(sample)\n\n# A tibble: 32,428 × 19\n# Groups:   sample [22]\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…       1170 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 Apod    GSM254…      36194 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 3 Cyp2d22 GSM254…       4060 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 4 Klk6    GSM254…        287 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 5 Fcrls   GSM254…         85 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 6 Slc2a4  GSM254…        782 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 7 Exd2    GSM254…       1619 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 Gjc2    GSM254…        288 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 9 Plp1    GSM254…      43217 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n10 Gnb4    GSM254…       1071 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nHere our initial tibble of 32428 observations is split into 22 groups based on the sample variable.\nOnce the data has been grouped, subsequent operations will be applied on each group independently.\n\n\n\ngroup_by() is often used together with summarise(), which collapses each group into a single-row summary of that group.\ngroup_by() takes as arguments the column names that contain the categorical variables for which you want to calculate the summary statistics. So to compute the mean expression by gene:\n\nrna %&gt;%\n  group_by(gene) %&gt;%\n  summarise(mean_expression = mean(expression))\n\n# A tibble: 1,474 × 2\n   gene     mean_expression\n   &lt;chr&gt;              &lt;dbl&gt;\n 1 AI504432         1053.  \n 2 AW046200          131.  \n 3 AW551984          295.  \n 4 Aamp             4751.  \n 5 Abca12              4.55\n 6 Abcc8            2498.  \n 7 Abhd14a           525.  \n 8 Abi2             4909.  \n 9 Abi3bp           1002.  \n10 Abl2             2124.  \n# ℹ 1,464 more rows\n\n\nWe could also want to calculate the mean expression levels of all genes in each sample:\n\nrna %&gt;%\n  group_by(sample) %&gt;%\n  summarise(mean_expression = mean(expression))\n\n# A tibble: 22 × 2\n   sample     mean_expression\n   &lt;chr&gt;                &lt;dbl&gt;\n 1 GSM2545336           2062.\n 2 GSM2545337           1766.\n 3 GSM2545338           1668.\n 4 GSM2545339           1696.\n 5 GSM2545340           1682.\n 6 GSM2545341           1638.\n 7 GSM2545342           1594.\n 8 GSM2545343           2107.\n 9 GSM2545344           1712.\n10 GSM2545345           1700.\n# ℹ 12 more rows\n\n\nBut we can can also group by multiple columns:\n\nrna %&gt;%\n  group_by(gene, infection, time) %&gt;%\n  summarise(mean_expression = mean(expression))\n\n`summarise()` has grouped output by 'gene', 'infection'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 4,422 × 4\n# Groups:   gene, infection [2,948]\n   gene     infection    time mean_expression\n   &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;           &lt;dbl&gt;\n 1 AI504432 InfluenzaA      4           1104.\n 2 AI504432 InfluenzaA      8           1014 \n 3 AI504432 NonInfected     0           1034.\n 4 AW046200 InfluenzaA      4            152.\n 5 AW046200 InfluenzaA      8             81 \n 6 AW046200 NonInfected     0            155.\n 7 AW551984 InfluenzaA      4            302.\n 8 AW551984 InfluenzaA      8            342.\n 9 AW551984 NonInfected     0            238 \n10 Aamp     InfluenzaA      4           4870 \n# ℹ 4,412 more rows\n\n\nOnce the data is grouped, you can also summarise multiple variables at the same time (and not necessarily on the same variable). For instance, we could add a column indicating the median expression by gene and by condition:\n\nrna %&gt;%\n  group_by(gene, infection, time) %&gt;%\n  summarise(mean_expression = mean(expression),\n            median_expression = median(expression))\n\n`summarise()` has grouped output by 'gene', 'infection'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 4,422 × 5\n# Groups:   gene, infection [2,948]\n   gene     infection    time mean_expression median_expression\n   &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;           &lt;dbl&gt;             &lt;dbl&gt;\n 1 AI504432 InfluenzaA      4           1104.             1094.\n 2 AI504432 InfluenzaA      8           1014               985 \n 3 AI504432 NonInfected     0           1034.             1016 \n 4 AW046200 InfluenzaA      4            152.              144.\n 5 AW046200 InfluenzaA      8             81                82 \n 6 AW046200 NonInfected     0            155.              163 \n 7 AW551984 InfluenzaA      4            302.              245 \n 8 AW551984 InfluenzaA      8            342.              287 \n 9 AW551984 NonInfected     0            238               265 \n10 Aamp     InfluenzaA      4           4870              4708 \n# ℹ 4,412 more rows\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nCalculate the mean expression level of gene “Dok3” by timepoints.\n\n\n\n\n\nWhen working with data, we often want to know the number of observations found for each factor or combination of factors. For this task, dplyr provides count(). For example, if we wanted to count the number of rows of data for each infected and non-infected samples, we would do:\n\nrna %&gt;%\n    count(infection)\n\n# A tibble: 2 × 2\n  infection       n\n  &lt;chr&gt;       &lt;int&gt;\n1 InfluenzaA  22110\n2 NonInfected 10318\n\n\nThe count() function is shorthand for something we’ve already seen: grouping by a variable, and summarising it by counting the number of observations in that group. In other words, rna %&gt;% count(infection) is equivalent to:\n\nrna %&gt;%\n    group_by(infection) %&gt;%\n    summarise(n = n())\n\n# A tibble: 2 × 2\n  infection       n\n  &lt;chr&gt;       &lt;int&gt;\n1 InfluenzaA  22110\n2 NonInfected 10318\n\n\nThe previous example shows the use of count() to count the number of rows/observations for one factor (i.e., infection). If we wanted to count a combination of factors, such as infection and time, we would specify the first and the second factor as the arguments of count():\n\nrna %&gt;%\n    count(infection, time)\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      4 11792\n2 InfluenzaA      8 10318\n3 NonInfected     0 10318\n\n\nwhich is equivalent to this:\n\nrna %&gt;%\n  group_by(infection, time) %&gt;%\n  summarise(n = n())\n\n`summarise()` has grouped output by 'infection'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 3 × 3\n# Groups:   infection [2]\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      4 11792\n2 InfluenzaA      8 10318\n3 NonInfected     0 10318\n\n\nIt is sometimes useful to sort the result to facilitate the comparisons. We can use arrange() to sort the table. For instance, we might want to arrange the table above by time:\n\nrna %&gt;%\n  count(infection, time) %&gt;%\n  arrange(time)\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 NonInfected     0 10318\n2 InfluenzaA      4 11792\n3 InfluenzaA      8 10318\n\n\nor by counts:\n\nrna %&gt;%\n  count(infection, time) %&gt;%\n  arrange(n)\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      8 10318\n2 NonInfected     0 10318\n3 InfluenzaA      4 11792\n\n\nTo sort in descending order, we need to add the desc() function:\n\nrna %&gt;%\n  count(infection, time) %&gt;%\n  arrange(desc(n))\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      4 11792\n2 InfluenzaA      8 10318\n3 NonInfected     0 10318\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nHow many genes were analysed in each sample?\n\nUse group_by() and summarise() to evaluate the sequencing depth (the sum of all counts) in each sample. Which sample has the highest sequencing depth?\nPick one sample and evaluate the number of genes by biotype.\nIdentify genes associated with the “abnormal DNA methylation” phenotype description, and calculate their mean expression (in log) at time 0, time 4 and time 8.\n\n\n\n\n\n\nIn the rna tibble, the rows contain expression values (the unit) that are associated with a combination of 2 other variables: gene and sample.\nAll the other columns correspond to variables describing either the sample (organism, age, sex, …) or the gene (gene_biotype, ENTREZ_ID, product, …). The variables that don’t change with genes or with samples will have the same value in all the rows.\n\nrna %&gt;%\n  arrange(gene)\n\n# A tibble: 32,428 × 19\n   gene     sample expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 AI504432 GSM25…       1230 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 AI504432 GSM25…       1085 Mus mus…     8 Fema… NonInfec… C57BL…     0 Cereb…\n 3 AI504432 GSM25…        969 Mus mus…     8 Fema… NonInfec… C57BL…     0 Cereb…\n 4 AI504432 GSM25…       1284 Mus mus…     8 Fema… Influenz… C57BL…     4 Cereb…\n 5 AI504432 GSM25…        966 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 6 AI504432 GSM25…        918 Mus mus…     8 Male  Influenz… C57BL…     8 Cereb…\n 7 AI504432 GSM25…        985 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 AI504432 GSM25…        972 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 9 AI504432 GSM25…       1000 Mus mus…     8 Fema… Influenz… C57BL…     4 Cereb…\n10 AI504432 GSM25…        816 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nThis structure is called a long-format, as one column contains all the values, and other column(s) list(s) the context of the value.\nIn certain cases, the long-format is not really “human-readable”, and another format, a wide-format is preferred, as a more compact way of representing the data. This is typically the case with gene expression values that scientists are used to look as matrices, were rows represent genes and columns represent samples.\nIn this format, it would therefore become straightforward to explore the relationship between the gene expression levels within, and between, the samples.\nTo convert the gene expression values from rna into a wide-format, we need to create a new table where the values of the sample column would become the names of column variables.\nThe key point here is that we are still following a tidy data structure, but we have reshaped the data according to the observations of interest: expression levels per gene instead of recording them per gene and per sample.\nThe opposite transformation would be to transform column names into values of a new variable.\nWe can do both these of transformations with two tidyr functions, pivot_longer() and pivot_wider() (see here for details).\n\n\n\nLet’s select the first 3 columns of rna and use pivot_wider() to transform the data into a wide-format.\n\nrna_exp &lt;- rna %&gt;%\n  select(gene, sample, expression)\nrna_exp\n\n# A tibble: 32,428 × 3\n   gene    sample     expression\n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545336       1170\n 2 Apod    GSM2545336      36194\n 3 Cyp2d22 GSM2545336       4060\n 4 Klk6    GSM2545336        287\n 5 Fcrls   GSM2545336         85\n 6 Slc2a4  GSM2545336        782\n 7 Exd2    GSM2545336       1619\n 8 Gjc2    GSM2545336        288\n 9 Plp1    GSM2545336      43217\n10 Gnb4    GSM2545336       1071\n# ℹ 32,418 more rows\n\n\n\n\n\n\n\n\nNote\n\n\n\npivot_wider takes three main arguments:\n\nthe data to be transformed;\nthe names_from : the column whose values will become new column names;\nthe values_from: the column whose values will fill the new columns.\n\n\n\n\n\nrna_wide &lt;- rna_exp %&gt;%\n  pivot_wider(names_from = sample,\n              values_from = expression)\nrna_wide\n\n# A tibble: 1,474 × 23\n   gene    GSM2545336 GSM2545337 GSM2545338 GSM2545339 GSM2545340 GSM2545341\n   &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n 1 Asl           1170        361        400        586        626        988\n 2 Apod         36194      10347       9173      10620      13021      29594\n 3 Cyp2d22       4060       1616       1603       1901       2171       3349\n 4 Klk6           287        629        641        578        448        195\n 5 Fcrls           85        233        244        237        180         38\n 6 Slc2a4         782        231        248        265        313        786\n 7 Exd2          1619       2288       2235       2513       2366       1359\n 8 Gjc2           288        595        568        551        310        146\n 9 Plp1         43217     101241      96534      58354      53126      27173\n10 Gnb4          1071       1791       1867       1430       1355        798\n# ℹ 1,464 more rows\n# ℹ 16 more variables: GSM2545342 &lt;dbl&gt;, GSM2545343 &lt;dbl&gt;, GSM2545344 &lt;dbl&gt;,\n#   GSM2545345 &lt;dbl&gt;, GSM2545346 &lt;dbl&gt;, GSM2545347 &lt;dbl&gt;, GSM2545348 &lt;dbl&gt;,\n#   GSM2545349 &lt;dbl&gt;, GSM2545350 &lt;dbl&gt;, GSM2545351 &lt;dbl&gt;, GSM2545352 &lt;dbl&gt;,\n#   GSM2545353 &lt;dbl&gt;, GSM2545354 &lt;dbl&gt;, GSM2545362 &lt;dbl&gt;, GSM2545363 &lt;dbl&gt;,\n#   GSM2545380 &lt;dbl&gt;\n\n\nNote that by default, the pivot_wider() function will add NA for missing values.\nLet’s imagine that for some reason, we had some missing expression values for some genes in certain samples. In the following fictive example, the gene Cyp2d22 has only one expression value, in GSM2545338 sample.\n\nrna_with_missing_values &lt;- rna %&gt;%\n  select(gene, sample, expression) %&gt;%\n  filter(gene %in% c(\"Asl\", \"Apod\", \"Cyp2d22\")) %&gt;%\n  filter(sample %in% c(\"GSM2545336\", \"GSM2545337\", \"GSM2545338\")) %&gt;%\n  arrange(sample) %&gt;%\n  filter(!(gene == \"Cyp2d22\" & sample != \"GSM2545338\"))\nrna_with_missing_values\n\n# A tibble: 7 × 3\n  gene    sample     expression\n  &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n1 Asl     GSM2545336       1170\n2 Apod    GSM2545336      36194\n3 Asl     GSM2545337        361\n4 Apod    GSM2545337      10347\n5 Asl     GSM2545338        400\n6 Apod    GSM2545338       9173\n7 Cyp2d22 GSM2545338       1603\n\n\nBy default, the pivot_wider() function will add NA for missing values. This can be parameterised with the values_fill argument of the pivot_wider() function.\n\nrna_with_missing_values %&gt;%\n  pivot_wider(names_from = sample,values_from = expression)\n\n# A tibble: 3 × 4\n  gene    GSM2545336 GSM2545337 GSM2545338\n  &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 Asl           1170        361        400\n2 Apod         36194      10347       9173\n3 Cyp2d22         NA         NA       1603\n\n\n\nrna_with_missing_values %&gt;%\n  pivot_wider(names_from = sample,values_from = expression,values_fill = 0)\n\n# A tibble: 3 × 4\n  gene    GSM2545336 GSM2545337 GSM2545338\n  &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 Asl           1170        361        400\n2 Apod         36194      10347       9173\n3 Cyp2d22          0          0       1603\n\n\n\n\n\nIn the opposite situation we are using the column names and turning them into a pair of new variables. One variable represents the column names as values, and the other variable contains the values previously associated with the column names.\n\n\n\n\n\n\nNote\n\n\n\npivot_longer() takes four main arguments:\n\nthe data to be transformed;\nthe names_to: the new column name we wish to create and populate with the current column names;\nthe values_to: the new column name we wish to create and populate with current values;\nthe names of the columns to be used to populate the names_to and values_to variables (or to drop).\n\n\n\n\nTo recreate rna_long from rna_wide we would create a key called sample and value called expression and use all columns except gene for the key variable. Here we drop gene column with a minus sign.\n\n\n\n\n\n\nImportant\n\n\n\nNotice how the new variable names are to be quoted here.\n\n\n\nrna_long &lt;- rna_wide %&gt;%\n    pivot_longer(names_to = \"sample\",\n                 values_to = \"expression\",\n                 -gene)\nrna_long\n\n# A tibble: 32,428 × 3\n   gene  sample     expression\n   &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl   GSM2545336       1170\n 2 Asl   GSM2545337        361\n 3 Asl   GSM2545338        400\n 4 Asl   GSM2545339        586\n 5 Asl   GSM2545340        626\n 6 Asl   GSM2545341        988\n 7 Asl   GSM2545342        836\n 8 Asl   GSM2545343        535\n 9 Asl   GSM2545344        586\n10 Asl   GSM2545345        597\n# ℹ 32,418 more rows\n\n\nWe could also have used a specification for what columns to include. This can be useful if you have a large number of identifying columns, and it’s easier to specify what to gather than what to leave alone. Here the starts_with() function can help to retrieve sample names without having to list them all! Another possibility would be to use the : operator!\n\nrna_wide %&gt;%\n    pivot_longer(names_to = \"sample\",\n                 values_to = \"expression\",\n                 cols = starts_with(\"GSM\"))\n\n# A tibble: 32,428 × 3\n   gene  sample     expression\n   &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl   GSM2545336       1170\n 2 Asl   GSM2545337        361\n 3 Asl   GSM2545338        400\n 4 Asl   GSM2545339        586\n 5 Asl   GSM2545340        626\n 6 Asl   GSM2545341        988\n 7 Asl   GSM2545342        836\n 8 Asl   GSM2545343        535\n 9 Asl   GSM2545344        586\n10 Asl   GSM2545345        597\n# ℹ 32,418 more rows\n\n\n\nrna_wide %&gt;%\n    pivot_longer(names_to = \"sample\",\n                 values_to = \"expression\",\n                 GSM2545336:GSM2545380)\n\n# A tibble: 32,428 × 3\n   gene  sample     expression\n   &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl   GSM2545336       1170\n 2 Asl   GSM2545337        361\n 3 Asl   GSM2545338        400\n 4 Asl   GSM2545339        586\n 5 Asl   GSM2545340        626\n 6 Asl   GSM2545341        988\n 7 Asl   GSM2545342        836\n 8 Asl   GSM2545343        535\n 9 Asl   GSM2545344        586\n10 Asl   GSM2545345        597\n# ℹ 32,418 more rows\n\n\n\n\n\n\n\n\nImportant\n\n\n\nNote that if we had missing values in the wide-format, the NA would be included in the new long format.\n\n\nRemember our previous fictive tibble containing missing values:\n\nrna_with_missing_values\n\n# A tibble: 7 × 3\n  gene    sample     expression\n  &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n1 Asl     GSM2545336       1170\n2 Apod    GSM2545336      36194\n3 Asl     GSM2545337        361\n4 Apod    GSM2545337      10347\n5 Asl     GSM2545338        400\n6 Apod    GSM2545338       9173\n7 Cyp2d22 GSM2545338       1603\n\n\n\nwide_with_NA &lt;- rna_with_missing_values %&gt;%\n  pivot_wider(names_from = sample,\n              values_from = expression)\nwide_with_NA\n\n# A tibble: 3 × 4\n  gene    GSM2545336 GSM2545337 GSM2545338\n  &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 Asl           1170        361        400\n2 Apod         36194      10347       9173\n3 Cyp2d22         NA         NA       1603\n\n\n\nwide_with_NA %&gt;%\n    pivot_longer(names_to = \"sample\",\n                 values_to = \"expression\",\n                 -gene)\n\n# A tibble: 9 × 3\n  gene    sample     expression\n  &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n1 Asl     GSM2545336       1170\n2 Asl     GSM2545337        361\n3 Asl     GSM2545338        400\n4 Apod    GSM2545336      36194\n5 Apod    GSM2545337      10347\n6 Apod    GSM2545338       9173\n7 Cyp2d22 GSM2545336         NA\n8 Cyp2d22 GSM2545337         NA\n9 Cyp2d22 GSM2545338       1603\n\n\nPivoting to wider and longer formats can be a useful way to balance out a dataset so every replicate has the same composition.\n\n\n\n\n\n\nQuestion\n\n\n\nStarting from the rna table, use the pivot_wider() function to create a wide-format table giving the gene expression levels in each mouse. Then use the pivot_longer() function to restore a long-format table.\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nSubset genes located on X and Y chromosomes from the rna data frame and spread the data frame with sex as columns, chromosome_name as rows, and the mean expression of genes located in each chromosome as the values, as in the following tibble:\n\nYou will need to summarise before reshaping!\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nUse the rna dataset to create an expression matrix where each row represents the mean expression levels of genes and columns represent the different timepoints.\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nUse the previous data frame containing mean expression levels per timepoint and create a new column containing fold-changes between timepoint 8 and timepoint 0, and fold-changes between timepoint 8 and timepoint 4. Convert this table into a long-format table gathering the fold-changes calculated.\n\n\n\n\n\nIn many real life situations, data are spread across multiple tables. Usually this occurs because different types of information are collected from different sources.\nIt may be desirable for some analyses to combine data from two or more tables into a single data frame based on a column that would be common to all the tables.\nThe dplyr package provides a set of join functions for combining two data frames based on matches within specified columns. Here, we provide a short introduction to joins. For further reading, please refer to the chapter about table joins. The Data Transformation Cheat Sheet also provides a short overview on table joins.\nWe are going to illustrate join using a small table, rna_mini that we will create by subsetting the original rna table, keeping only 3 columns and 10 lines.\n\nrna_mini &lt;- rna %&gt;%\n   select(gene, sample, expression) %&gt;%\n   head(10)\nrna_mini\n\n# A tibble: 10 × 3\n   gene    sample     expression\n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545336       1170\n 2 Apod    GSM2545336      36194\n 3 Cyp2d22 GSM2545336       4060\n 4 Klk6    GSM2545336        287\n 5 Fcrls   GSM2545336         85\n 6 Slc2a4  GSM2545336        782\n 7 Exd2    GSM2545336       1619\n 8 Gjc2    GSM2545336        288\n 9 Plp1    GSM2545336      43217\n10 Gnb4    GSM2545336       1071\n\n\nThe second table, annot1, contains 2 columns, gene and gene_description. You can either download annot1.csv by clicking on the link and then moving it to the data/ folder, or you can use the R code below to download it directly to the folder.\n\ndownload.file(url = \"https://carpentries-incubator.github.io/bioc-intro/data/annot1.csv\",\n              destfile = \"data/annot1.csv\")\nannot1 &lt;- read_csv(file = \"data/annot1.csv\")\n\nRows: 10 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): gene, gene_description\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nannot1\n\n# A tibble: 10 × 2\n   gene    gene_description                                                     \n   &lt;chr&gt;   &lt;chr&gt;                                                                \n 1 Cyp2d22 cytochrome P450, family 2, subfamily d, polypeptide 22 [Source:MGI S…\n 2 Klk6    kallikrein related-peptidase 6 [Source:MGI Symbol;Acc:MGI:1343166]   \n 3 Fcrls   Fc receptor-like S, scavenger receptor [Source:MGI Symbol;Acc:MGI:19…\n 4 Plp1    proteolipid protein (myelin) 1 [Source:MGI Symbol;Acc:MGI:97623]     \n 5 Exd2    exonuclease 3'-5' domain containing 2 [Source:MGI Symbol;Acc:MGI:192…\n 6 Apod    apolipoprotein D [Source:MGI Symbol;Acc:MGI:88056]                   \n 7 Gnb4    guanine nucleotide binding protein (G protein), beta 4 [Source:MGI S…\n 8 Slc2a4  solute carrier family 2 (facilitated glucose transporter), member 4 …\n 9 Asl     argininosuccinate lyase [Source:MGI Symbol;Acc:MGI:88084]            \n10 Gjc2    gap junction protein, gamma 2 [Source:MGI Symbol;Acc:MGI:2153060]    \n\n\nWe now want to join these two tables into a single one containing all variables using the full_join() function from the dplyr package. The function will automatically find the common variable to match columns from the first and second table. In this case, gene is the common variable. Such variables are called keys. Keys are used to match observations across different tables.\n\nfull_join(rna_mini, annot1)\n\nJoining with `by = join_by(gene)`\n\n\n# A tibble: 10 × 4\n   gene    sample     expression gene_description                               \n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;                                          \n 1 Asl     GSM2545336       1170 argininosuccinate lyase [Source:MGI Symbol;Acc…\n 2 Apod    GSM2545336      36194 apolipoprotein D [Source:MGI Symbol;Acc:MGI:88…\n 3 Cyp2d22 GSM2545336       4060 cytochrome P450, family 2, subfamily d, polype…\n 4 Klk6    GSM2545336        287 kallikrein related-peptidase 6 [Source:MGI Sym…\n 5 Fcrls   GSM2545336         85 Fc receptor-like S, scavenger receptor [Source…\n 6 Slc2a4  GSM2545336        782 solute carrier family 2 (facilitated glucose t…\n 7 Exd2    GSM2545336       1619 exonuclease 3'-5' domain containing 2 [Source:…\n 8 Gjc2    GSM2545336        288 gap junction protein, gamma 2 [Source:MGI Symb…\n 9 Plp1    GSM2545336      43217 proteolipid protein (myelin) 1 [Source:MGI Sym…\n10 Gnb4    GSM2545336       1071 guanine nucleotide binding protein (G protein)…\n\n\nIn real life, gene annotations are sometimes labelled differently.\nThe annot2 table is exactly the same than annot1 except that the variable containing gene names is labelled differently. Again, either download annot2.csv yourself and move it to data/ or use the R code below.\n\ndownload.file(url = \"https://carpentries-incubator.github.io/bioc-intro/data/annot2.csv\",\n              destfile = \"data/annot2.csv\")\nannot2 &lt;- read_csv(file = \"data/annot2.csv\")\n\nRows: 10 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): external_gene_name, description\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nannot2\n\n# A tibble: 10 × 2\n   external_gene_name description                                               \n   &lt;chr&gt;              &lt;chr&gt;                                                     \n 1 Cyp2d22            cytochrome P450, family 2, subfamily d, polypeptide 22 [S…\n 2 Klk6               kallikrein related-peptidase 6 [Source:MGI Symbol;Acc:MGI…\n 3 Fcrls              Fc receptor-like S, scavenger receptor [Source:MGI Symbol…\n 4 Plp1               proteolipid protein (myelin) 1 [Source:MGI Symbol;Acc:MGI…\n 5 Exd2               exonuclease 3'-5' domain containing 2 [Source:MGI Symbol;…\n 6 Apod               apolipoprotein D [Source:MGI Symbol;Acc:MGI:88056]        \n 7 Gnb4               guanine nucleotide binding protein (G protein), beta 4 [S…\n 8 Slc2a4             solute carrier family 2 (facilitated glucose transporter)…\n 9 Asl                argininosuccinate lyase [Source:MGI Symbol;Acc:MGI:88084] \n10 Gjc2               gap junction protein, gamma 2 [Source:MGI Symbol;Acc:MGI:…\n\n\nIn case none of the variable names match, we can set manually the variables to use for the matching. These variables can be set using the by argument, as shown below with rna_mini and annot2 tables.\n\nfull_join(rna_mini, annot2, by = c(\"gene\" = \"external_gene_name\"))\n\n# A tibble: 10 × 4\n   gene    sample     expression description                                    \n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;                                          \n 1 Asl     GSM2545336       1170 argininosuccinate lyase [Source:MGI Symbol;Acc…\n 2 Apod    GSM2545336      36194 apolipoprotein D [Source:MGI Symbol;Acc:MGI:88…\n 3 Cyp2d22 GSM2545336       4060 cytochrome P450, family 2, subfamily d, polype…\n 4 Klk6    GSM2545336        287 kallikrein related-peptidase 6 [Source:MGI Sym…\n 5 Fcrls   GSM2545336         85 Fc receptor-like S, scavenger receptor [Source…\n 6 Slc2a4  GSM2545336        782 solute carrier family 2 (facilitated glucose t…\n 7 Exd2    GSM2545336       1619 exonuclease 3'-5' domain containing 2 [Source:…\n 8 Gjc2    GSM2545336        288 gap junction protein, gamma 2 [Source:MGI Symb…\n 9 Plp1    GSM2545336      43217 proteolipid protein (myelin) 1 [Source:MGI Sym…\n10 Gnb4    GSM2545336       1071 guanine nucleotide binding protein (G protein)…\n\n\nAs can be seen above, the variable name of the first table is retained in the joined one.\n\n\n\n\n\n\nQuestion\n\n\n\nDownload the annot3 table by clicking here and put the table in your data/ repository. Using the full_join() function, join tables rna_mini and annot3. What has happened for genes Klk6, mt-Tf, mt-Rnr1, mt-Tv, mt-Rnr2, and mt-Tl1 ?\n\n\n\n\n\nNow that you have learned how to use dplyr to extract information from or summarise your raw data, you may want to export these new data sets to share them with your collaborators or for archival.\nSimilar to the read_csv() function used for reading CSV files into R, there is a write_csv() function that generates CSV files from data frames.\nBefore using write_csv(), we are going to create a new folder, data_output, in our working directory that will store this generated dataset. We don’t want to write generated datasets in the same directory as our raw data. It’s good practice to keep them separate. The data folder should only contain the raw, unaltered data, and should be left alone to make sure we don’t delete or modify it. In contrast, our script will generate the contents of the data_output directory, so even if the files it contains are deleted, we can always re-generate them.\nLet’s use write_csv() to save the rna_wide table that we have created previously.\n\nwrite_csv(rna_wide, file = \"data_output/rna_wide.csv\")"
  },
  {
    "objectID": "bioc_intro_dataManipulation_solutions.html",
    "href": "bioc_intro_dataManipulation_solutions.html",
    "title": "Manipulating and analysing data with dplyr",
    "section": "",
    "text": "Bracket subsetting is handy, but it can be cumbersome and difficult to read, especially for complicated operations.\nSome packages can greatly facilitate our task when we manipulate data. Packages in R are basically sets of additional functions that let you do more stuff. The functions we’ve been using so far, like str() or data.frame(), come built into R; Loading packages can give you access to other specific functions. Before you use a package for the first time you need to install it on your machine, and then you should import it in every subsequent R session when you need it.\n\nThe package dplyr provides powerful tools for data manipulation tasks. It is built to work directly with data frames, with many manipulation tasks optimised.\nAs we will see latter on, sometimes we want a data frame to be reshaped to be able to do some specific analyses or for visualisation. The package tidyr addresses this common problem of reshaping data and provides tools for manipulating data in a tidy way.\n\nTo learn more about dplyr and tidyr after the workshop, you may want to check out this handy data transformation with dplyr cheatsheet and this one about tidyr.\n\nThe tidyverse package is an “umbrella-package” that installs several useful packages for data analysis which work well together, such as tidyr, dplyr, ggplot2, tibble, etc. These packages help us to work and interact with the data. They allow us to do many things with your data, such as subsetting, transforming, visualising, etc.\n\nIf you did the set up, you should have already installed the tidyverse package. Check to see if you have it by trying to load in from the library:\n\n## load the tidyverse packages, incl. dplyr\nlibrary(\"tidyverse\")\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nIf you got an error message there is no package called ‘tidyverse’ then you have not installed the package yet for this version of R. To install the tidyverse package type:\n\nBiocManager::install(\"tidyverse\")\n\nIf you had to install the tidyverse package, do not forget to load it in this R session by using the library() command above!\n\n\nInstead of read.csv(), we will read in our data using the read_csv() function (notice the _ instead of the .), from the tidyverse package readr.\n\nrna &lt;- read_csv(\"data/rnaseq.csv\")\n\nRows: 32428 Columns: 19\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (14): gene, sample, organism, sex, infection, strain, tissue, product, e...\ndbl  (5): expression, age, time, mouse, ENTREZID\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n## view the data\nrna\n\n# A tibble: 32,428 × 19\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…       1170 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 Apod    GSM254…      36194 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 3 Cyp2d22 GSM254…       4060 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 4 Klk6    GSM254…        287 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 5 Fcrls   GSM254…         85 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 6 Slc2a4  GSM254…        782 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 7 Exd2    GSM254…       1619 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 Gjc2    GSM254…        288 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 9 Plp1    GSM254…      43217 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n10 Gnb4    GSM254…       1071 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\n\n\n\n\n\n\nImportant\n\n\n\nNotice that the class of the data is now referred to as a “tibble”.\n\n\nTibbles tweak some of the behaviors of the data frame objects we introduced in the previously. The data structure is very similar to a data frame. For our purposes the only differences are that:\n\nIt displays the data type of each column under its name. Note that &lt;dbl&gt; is a data type defined to hold numeric values with decimal points.\nIt only prints the first few rows of data and only as many columns as fit on one screen.\n\nWe are now going to learn some of the most common dplyr functions:\n\nselect(): subset columns\nfilter(): subset rows on conditions\nmutate(): create new columns by using information from other columns\ngroup_by() and summarise(): create summary statistics on grouped data\narrange(): sort results\ncount(): count discrete values\n\n\n\n\nTo select columns of a data frame, use select(). The first argument to this function is the data frame (rna), and the subsequent arguments are the columns to keep.\n\nselect(rna, gene, sample, tissue, expression)\n\n# A tibble: 32,428 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545336 Cerebellum       1170\n 2 Apod    GSM2545336 Cerebellum      36194\n 3 Cyp2d22 GSM2545336 Cerebellum       4060\n 4 Klk6    GSM2545336 Cerebellum        287\n 5 Fcrls   GSM2545336 Cerebellum         85\n 6 Slc2a4  GSM2545336 Cerebellum        782\n 7 Exd2    GSM2545336 Cerebellum       1619\n 8 Gjc2    GSM2545336 Cerebellum        288\n 9 Plp1    GSM2545336 Cerebellum      43217\n10 Gnb4    GSM2545336 Cerebellum       1071\n# ℹ 32,418 more rows\n\n\nTo select all columns except certain ones, put a “-” in front of the variable to exclude it.\n\nselect(rna, -tissue, -organism)\n\n# A tibble: 32,428 × 17\n   gene    sample   expression   age sex   infection strain  time mouse ENTREZID\n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 Asl     GSM2545…       1170     8 Fema… Influenz… C57BL…     8    14   109900\n 2 Apod    GSM2545…      36194     8 Fema… Influenz… C57BL…     8    14    11815\n 3 Cyp2d22 GSM2545…       4060     8 Fema… Influenz… C57BL…     8    14    56448\n 4 Klk6    GSM2545…        287     8 Fema… Influenz… C57BL…     8    14    19144\n 5 Fcrls   GSM2545…         85     8 Fema… Influenz… C57BL…     8    14    80891\n 6 Slc2a4  GSM2545…        782     8 Fema… Influenz… C57BL…     8    14    20528\n 7 Exd2    GSM2545…       1619     8 Fema… Influenz… C57BL…     8    14    97827\n 8 Gjc2    GSM2545…        288     8 Fema… Influenz… C57BL…     8    14   118454\n 9 Plp1    GSM2545…      43217     8 Fema… Influenz… C57BL…     8    14    18823\n10 Gnb4    GSM2545…       1071     8 Fema… Influenz… C57BL…     8    14    14696\n# ℹ 32,418 more rows\n# ℹ 7 more variables: product &lt;chr&gt;, ensembl_gene_id &lt;chr&gt;,\n#   external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;, gene_biotype &lt;chr&gt;,\n#   phenotype_description &lt;chr&gt;, hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nThis will select all the variables in rna except tissue and organism.\nTo choose rows based on a specific criteria, use filter():\n\nfilter(rna, sex == \"Male\")\n\n# A tibble: 14,740 × 19\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…        626 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 2 Apod    GSM254…      13021 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 3 Cyp2d22 GSM254…       2171 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 4 Klk6    GSM254…        448 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 5 Fcrls   GSM254…        180 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 6 Slc2a4  GSM254…        313 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 7 Exd2    GSM254…       2366 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 8 Gjc2    GSM254…        310 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 9 Plp1    GSM254…      53126 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n10 Gnb4    GSM254…       1355 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n# ℹ 14,730 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\n\nfilter(rna, sex == \"Male\" & infection == \"NonInfected\")\n\n# A tibble: 4,422 × 19\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…        535 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 2 Apod    GSM254…      13668 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 3 Cyp2d22 GSM254…       2008 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 4 Klk6    GSM254…       1101 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 5 Fcrls   GSM254…        375 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 6 Slc2a4  GSM254…        249 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 7 Exd2    GSM254…       3126 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 8 Gjc2    GSM254…        791 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 9 Plp1    GSM254…      98658 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n10 Gnb4    GSM254…       2437 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n# ℹ 4,412 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nNow let’s imagine we are interested in the human homologs of the mouse genes analysed in this dataset. This information can be found in the last column of the rna tibble, named hsapiens_homolog_associated_gene_name. To visualise it easily, we will create a new table containing just the 2 columns gene and hsapiens_homolog_associated_gene_name.\n\ngenes &lt;- select(rna, gene, hsapiens_homolog_associated_gene_name)\ngenes\n\n# A tibble: 32,428 × 2\n   gene    hsapiens_homolog_associated_gene_name\n   &lt;chr&gt;   &lt;chr&gt;                                \n 1 Asl     ASL                                  \n 2 Apod    APOD                                 \n 3 Cyp2d22 CYP2D6                               \n 4 Klk6    KLK6                                 \n 5 Fcrls   FCRL2                                \n 6 Slc2a4  SLC2A4                               \n 7 Exd2    EXD2                                 \n 8 Gjc2    GJC2                                 \n 9 Plp1    PLP1                                 \n10 Gnb4    GNB4                                 \n# ℹ 32,418 more rows\n\n\nSome mouse genes have no human homologs. These can be retrieved using filter() and the is.na() function, that determines whether something is an NA.\n\nfilter(genes, is.na(hsapiens_homolog_associated_gene_name))\n\n# A tibble: 4,290 × 2\n   gene     hsapiens_homolog_associated_gene_name\n   &lt;chr&gt;    &lt;chr&gt;                                \n 1 Prodh    &lt;NA&gt;                                 \n 2 Tssk5    &lt;NA&gt;                                 \n 3 Vmn2r1   &lt;NA&gt;                                 \n 4 Gm10654  &lt;NA&gt;                                 \n 5 Hexa     &lt;NA&gt;                                 \n 6 Sult1a1  &lt;NA&gt;                                 \n 7 Gm6277   &lt;NA&gt;                                 \n 8 Tmem198b &lt;NA&gt;                                 \n 9 Adam1a   &lt;NA&gt;                                 \n10 Ebp      &lt;NA&gt;                                 \n# ℹ 4,280 more rows\n\n\nIf we want to keep only mouse genes that have a human homolog, we can insert a “!” symbol that negates the result, so we’re asking for every row where hsapiens_homolog_associated_gene_name is not an NA.\n\nfilter(genes, !is.na(hsapiens_homolog_associated_gene_name))\n\n# A tibble: 28,138 × 2\n   gene    hsapiens_homolog_associated_gene_name\n   &lt;chr&gt;   &lt;chr&gt;                                \n 1 Asl     ASL                                  \n 2 Apod    APOD                                 \n 3 Cyp2d22 CYP2D6                               \n 4 Klk6    KLK6                                 \n 5 Fcrls   FCRL2                                \n 6 Slc2a4  SLC2A4                               \n 7 Exd2    EXD2                                 \n 8 Gjc2    GJC2                                 \n 9 Plp1    PLP1                                 \n10 Gnb4    GNB4                                 \n# ℹ 28,128 more rows\n\n\n\n\n\nWhat if you want to select and filter at the same time? There are three ways to do this: use intermediate steps, nested functions, or pipes.\nWith intermediate steps, you create a temporary data frame and use that as input to the next function, like this:\n\nrna2 &lt;- filter(rna, sex == \"Male\")\nrna3 &lt;- select(rna2, gene, sample, tissue, expression)\nrna3\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\nThis is readable, but can clutter up your workspace with lots of intermediate objects that you have to name individually. With multiple steps, that can be hard to keep track of.\nYou can also nest functions (i.e. one function inside of another), like this:\n\nrna3 &lt;- select(filter(rna, sex == \"Male\"), gene, sample, tissue, expression)\nrna3\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\nThis is handy, but can be difficult to read if too many functions are nested, as R evaluates the expression from the inside out (in this case, filtering, then selecting).\nThe last option, pipes, are a recent addition to R. Pipes let you take the output of one function and send it directly to the next, which is useful when you need to do many things to the same dataset.\nPipes in R look like %&gt;% (made available via the magrittr package) or |&gt; (through base R). If you use RStudio, you can type the pipe with Ctrl + Shift + M if you have a PC or Cmd + Shift + M if you have a Mac.\nIn the above code, we use the pipe to send the rna dataset first through filter() to keep rows where sex is Male, then through select() to keep only the gene, sample, tissue, and expressioncolumns.\nThe pipe %&gt;% takes the object on its left and passes it directly as the first argument to the function on its right, we don’t need to explicitly include the data frame as an argument to the filter() and select() functions any more.\n\nrna %&gt;%\n  filter(sex == \"Male\") %&gt;%\n  select(gene, sample, tissue, expression)\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\nSome may find it helpful to read the pipe like the word “then”. For instance, in the above example, we took the data frame rna, then we filtered for rows with sex == \"Male\", then we selected columns gene, sample, tissue, and expression.\nThe dplyr functions by themselves are somewhat simple, but by combining them into linear workflows with the pipe, we can accomplish more complex manipulations of data frames.\nIf we want to create a new object with this smaller version of the data, we can assign it a new name:\n\nrna3 &lt;- rna %&gt;%\n  filter(sex == \"Male\") %&gt;%\n  select(gene, sample, tissue, expression)\n\nrna3\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nUsing pipes, subset the rna data to keep observations in female mice at time 0, where the gene has an expression higher than 50000, and retain only the columns gene, sample, time, expression and age.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nrna %&gt;%\n  filter(expression &gt; 50000,\n         sex == \"Female\",\n         time == 0 ) %&gt;%\n  select(gene, sample, time, expression, age)\n\n# A tibble: 9 × 5\n  gene   sample      time expression   age\n  &lt;chr&gt;  &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n1 Plp1   GSM2545337     0     101241     8\n2 Atp1b1 GSM2545337     0      53260     8\n3 Plp1   GSM2545338     0      96534     8\n4 Atp1b1 GSM2545338     0      50614     8\n5 Plp1   GSM2545348     0     102790     8\n6 Atp1b1 GSM2545348     0      59544     8\n7 Plp1   GSM2545353     0      71237     8\n8 Glul   GSM2545353     0      52451     8\n9 Atp1b1 GSM2545353     0      61451     8\n\n\n\n\n\n\n\n\nFrequently you’ll want to create new columns based on the values of existing columns, for example to do unit conversions, or to find the ratio of values in two columns. For this we’ll use mutate().\nTo create a new column of time in hours:\n\nrna %&gt;%\n  mutate(time_hours = time * 24) %&gt;%\n  select(time, time_hours)\n\n# A tibble: 32,428 × 2\n    time time_hours\n   &lt;dbl&gt;      &lt;dbl&gt;\n 1     8        192\n 2     8        192\n 3     8        192\n 4     8        192\n 5     8        192\n 6     8        192\n 7     8        192\n 8     8        192\n 9     8        192\n10     8        192\n# ℹ 32,418 more rows\n\n\nYou can also create a second new column based on the first new column within the same call of mutate():\n\nrna %&gt;%\n  mutate(time_hours = time * 24,\n         time_mn = time_hours * 60) %&gt;%\n  select(time, time_hours, time_mn)\n\n# A tibble: 32,428 × 3\n    time time_hours time_mn\n   &lt;dbl&gt;      &lt;dbl&gt;   &lt;dbl&gt;\n 1     8        192   11520\n 2     8        192   11520\n 3     8        192   11520\n 4     8        192   11520\n 5     8        192   11520\n 6     8        192   11520\n 7     8        192   11520\n 8     8        192   11520\n 9     8        192   11520\n10     8        192   11520\n# ℹ 32,418 more rows\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nCreate a new data frame from the rna data that meets the following criteria: contains only the gene, chromosome_name, phenotype_description, sample, and expression columns. The expression values should be log-transformed. This data frame must only contain genes located on sex chromosomes, associated with a phenotype_description, and with a log expression higher than 5.\nHint: think about how the commands should be ordered to produce this data frame!\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nrna %&gt;%\n  mutate(expression = log(expression)) %&gt;%\n  select(gene, chromosome_name, phenotype_description, sample, expression) %&gt;%\n  filter(chromosome_name == \"X\" | chromosome_name == \"Y\") %&gt;%\n  filter(!is.na(phenotype_description)) %&gt;%\n  filter(expression &gt; 5)\n\n# A tibble: 649 × 5\n   gene   chromosome_name phenotype_description                sample expression\n   &lt;chr&gt;  &lt;chr&gt;           &lt;chr&gt;                                &lt;chr&gt;       &lt;dbl&gt;\n 1 Plp1   X               abnormal CNS glial cell morphology   GSM25…      10.7 \n 2 Slc7a3 X               decreased body length                GSM25…       5.46\n 3 Plxnb3 X               abnormal coat appearance             GSM25…       6.58\n 4 Rbm3   X               abnormal liver morphology            GSM25…       9.32\n 5 Cfp    X               abnormal cardiovascular system phys… GSM25…       6.18\n 6 Ebp    X               abnormal embryonic erythrocyte morp… GSM25…       6.68\n 7 Cd99l2 X               abnormal cellular extravasation      GSM25…       8.04\n 8 Piga   X               abnormal brain development           GSM25…       6.06\n 9 Pim2   X               decreased T cell proliferation       GSM25…       7.11\n10 Itm2a  X               no abnormal phenotype detected       GSM25…       7.48\n# ℹ 639 more rows\n\n\n\n\n\n\n\n\nMany data analysis tasks can be approached using the split-apply-combine paradigm: split the data into groups, apply some analysis to each group, and then combine the results. dplyr makes this very easy through the use of the group_by() function.\n\nrna %&gt;%\n  group_by(gene)\n\n# A tibble: 32,428 × 19\n# Groups:   gene [1,474]\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…       1170 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 Apod    GSM254…      36194 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 3 Cyp2d22 GSM254…       4060 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 4 Klk6    GSM254…        287 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 5 Fcrls   GSM254…         85 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 6 Slc2a4  GSM254…        782 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 7 Exd2    GSM254…       1619 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 Gjc2    GSM254…        288 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 9 Plp1    GSM254…      43217 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n10 Gnb4    GSM254…       1071 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nThe group_by() function doesn’t perform any data processing, it groups the data into subsets: in the example above, our initial tibble of 32428 observations is split into 1474 groups based on the gene variable.\nWe could similarly decide to group the tibble by the samples:\n\nrna %&gt;%\n  group_by(sample)\n\n# A tibble: 32,428 × 19\n# Groups:   sample [22]\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…       1170 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 Apod    GSM254…      36194 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 3 Cyp2d22 GSM254…       4060 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 4 Klk6    GSM254…        287 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 5 Fcrls   GSM254…         85 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 6 Slc2a4  GSM254…        782 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 7 Exd2    GSM254…       1619 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 Gjc2    GSM254…        288 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 9 Plp1    GSM254…      43217 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n10 Gnb4    GSM254…       1071 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nHere our initial tibble of 32428 observations is split into 22 groups based on the sample variable.\nOnce the data has been grouped, subsequent operations will be applied on each group independently.\n\n\n\ngroup_by() is often used together with summarise(), which collapses each group into a single-row summary of that group.\ngroup_by() takes as arguments the column names that contain the categorical variables for which you want to calculate the summary statistics. So to compute the mean expression by gene:\n\nrna %&gt;%\n  group_by(gene) %&gt;%\n  summarise(mean_expression = mean(expression))\n\n# A tibble: 1,474 × 2\n   gene     mean_expression\n   &lt;chr&gt;              &lt;dbl&gt;\n 1 AI504432         1053.  \n 2 AW046200          131.  \n 3 AW551984          295.  \n 4 Aamp             4751.  \n 5 Abca12              4.55\n 6 Abcc8            2498.  \n 7 Abhd14a           525.  \n 8 Abi2             4909.  \n 9 Abi3bp           1002.  \n10 Abl2             2124.  \n# ℹ 1,464 more rows\n\n\nWe could also want to calculate the mean expression levels of all genes in each sample:\n\nrna %&gt;%\n  group_by(sample) %&gt;%\n  summarise(mean_expression = mean(expression))\n\n# A tibble: 22 × 2\n   sample     mean_expression\n   &lt;chr&gt;                &lt;dbl&gt;\n 1 GSM2545336           2062.\n 2 GSM2545337           1766.\n 3 GSM2545338           1668.\n 4 GSM2545339           1696.\n 5 GSM2545340           1682.\n 6 GSM2545341           1638.\n 7 GSM2545342           1594.\n 8 GSM2545343           2107.\n 9 GSM2545344           1712.\n10 GSM2545345           1700.\n# ℹ 12 more rows\n\n\nBut we can can also group by multiple columns:\n\nrna %&gt;%\n  group_by(gene, infection, time) %&gt;%\n  summarise(mean_expression = mean(expression))\n\n`summarise()` has grouped output by 'gene', 'infection'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 4,422 × 4\n# Groups:   gene, infection [2,948]\n   gene     infection    time mean_expression\n   &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;           &lt;dbl&gt;\n 1 AI504432 InfluenzaA      4           1104.\n 2 AI504432 InfluenzaA      8           1014 \n 3 AI504432 NonInfected     0           1034.\n 4 AW046200 InfluenzaA      4            152.\n 5 AW046200 InfluenzaA      8             81 \n 6 AW046200 NonInfected     0            155.\n 7 AW551984 InfluenzaA      4            302.\n 8 AW551984 InfluenzaA      8            342.\n 9 AW551984 NonInfected     0            238 \n10 Aamp     InfluenzaA      4           4870 \n# ℹ 4,412 more rows\n\n\nOnce the data is grouped, you can also summarise multiple variables at the same time (and not necessarily on the same variable). For instance, we could add a column indicating the median expression by gene and by condition:\n\nrna %&gt;%\n  group_by(gene, infection, time) %&gt;%\n  summarise(mean_expression = mean(expression),\n            median_expression = median(expression))\n\n`summarise()` has grouped output by 'gene', 'infection'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 4,422 × 5\n# Groups:   gene, infection [2,948]\n   gene     infection    time mean_expression median_expression\n   &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;           &lt;dbl&gt;             &lt;dbl&gt;\n 1 AI504432 InfluenzaA      4           1104.             1094.\n 2 AI504432 InfluenzaA      8           1014               985 \n 3 AI504432 NonInfected     0           1034.             1016 \n 4 AW046200 InfluenzaA      4            152.              144.\n 5 AW046200 InfluenzaA      8             81                82 \n 6 AW046200 NonInfected     0            155.              163 \n 7 AW551984 InfluenzaA      4            302.              245 \n 8 AW551984 InfluenzaA      8            342.              287 \n 9 AW551984 NonInfected     0            238               265 \n10 Aamp     InfluenzaA      4           4870              4708 \n# ℹ 4,412 more rows\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nCalculate the mean expression level of gene “Dok3” by timepoints.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nrna %&gt;%\n  filter(gene == \"Dok3\") %&gt;%\n  group_by(time) %&gt;%\n  summarise(mean = mean(expression))\n\n# A tibble: 3 × 2\n   time  mean\n  &lt;dbl&gt; &lt;dbl&gt;\n1     0  169 \n2     4  156.\n3     8   61 \n\n\n\n\n\n\n\n\nWhen working with data, we often want to know the number of observations found for each factor or combination of factors. For this task, dplyr provides count(). For example, if we wanted to count the number of rows of data for each infected and non-infected samples, we would do:\n\nrna %&gt;%\n    count(infection)\n\n# A tibble: 2 × 2\n  infection       n\n  &lt;chr&gt;       &lt;int&gt;\n1 InfluenzaA  22110\n2 NonInfected 10318\n\n\nThe count() function is shorthand for something we’ve already seen: grouping by a variable, and summarising it by counting the number of observations in that group. In other words, rna %&gt;% count(infection) is equivalent to:\n\nrna %&gt;%\n    group_by(infection) %&gt;%\n    summarise(n = n())\n\n# A tibble: 2 × 2\n  infection       n\n  &lt;chr&gt;       &lt;int&gt;\n1 InfluenzaA  22110\n2 NonInfected 10318\n\n\nThe previous example shows the use of count() to count the number of rows/observations for one factor (i.e., infection). If we wanted to count a combination of factors, such as infection and time, we would specify the first and the second factor as the arguments of count():\n\nrna %&gt;%\n    count(infection, time)\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      4 11792\n2 InfluenzaA      8 10318\n3 NonInfected     0 10318\n\n\nwhich is equivalent to this:\n\nrna %&gt;%\n  group_by(infection, time) %&gt;%\n  summarise(n = n())\n\n`summarise()` has grouped output by 'infection'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 3 × 3\n# Groups:   infection [2]\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      4 11792\n2 InfluenzaA      8 10318\n3 NonInfected     0 10318\n\n\nIt is sometimes useful to sort the result to facilitate the comparisons. We can use arrange() to sort the table. For instance, we might want to arrange the table above by time:\n\nrna %&gt;%\n  count(infection, time) %&gt;%\n  arrange(time)\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 NonInfected     0 10318\n2 InfluenzaA      4 11792\n3 InfluenzaA      8 10318\n\n\nor by counts:\n\nrna %&gt;%\n  count(infection, time) %&gt;%\n  arrange(n)\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      8 10318\n2 NonInfected     0 10318\n3 InfluenzaA      4 11792\n\n\nTo sort in descending order, we need to add the desc() function:\n\nrna %&gt;%\n  count(infection, time) %&gt;%\n  arrange(desc(n))\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      4 11792\n2 InfluenzaA      8 10318\n3 NonInfected     0 10318\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nHow many genes were analysed in each sample?\n\nUse group_by() and summarise() to evaluate the sequencing depth (the sum of all counts) in each sample. Which sample has the highest sequencing depth?\nPick one sample and evaluate the number of genes by biotype.\nIdentify genes associated with the “abnormal DNA methylation” phenotype description, and calculate their mean expression (in log) at time 0, time 4 and time 8.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nrna %&gt;%\n  count(sample)\n\n# A tibble: 22 × 2\n   sample         n\n   &lt;chr&gt;      &lt;int&gt;\n 1 GSM2545336  1474\n 2 GSM2545337  1474\n 3 GSM2545338  1474\n 4 GSM2545339  1474\n 5 GSM2545340  1474\n 6 GSM2545341  1474\n 7 GSM2545342  1474\n 8 GSM2545343  1474\n 9 GSM2545344  1474\n10 GSM2545345  1474\n# ℹ 12 more rows\n\n\n\n\n\n\n\n\nIn the rna tibble, the rows contain expression values (the unit) that are associated with a combination of 2 other variables: gene and sample.\nAll the other columns correspond to variables describing either the sample (organism, age, sex, …) or the gene (gene_biotype, ENTREZ_ID, product, …). The variables that don’t change with genes or with samples will have the same value in all the rows.\n\nrna %&gt;%\n  arrange(gene)\n\n# A tibble: 32,428 × 19\n   gene     sample expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 AI504432 GSM25…       1230 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 AI504432 GSM25…       1085 Mus mus…     8 Fema… NonInfec… C57BL…     0 Cereb…\n 3 AI504432 GSM25…        969 Mus mus…     8 Fema… NonInfec… C57BL…     0 Cereb…\n 4 AI504432 GSM25…       1284 Mus mus…     8 Fema… Influenz… C57BL…     4 Cereb…\n 5 AI504432 GSM25…        966 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 6 AI504432 GSM25…        918 Mus mus…     8 Male  Influenz… C57BL…     8 Cereb…\n 7 AI504432 GSM25…        985 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 AI504432 GSM25…        972 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 9 AI504432 GSM25…       1000 Mus mus…     8 Fema… Influenz… C57BL…     4 Cereb…\n10 AI504432 GSM25…        816 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nThis structure is called a long-format, as one column contains all the values, and other column(s) list(s) the context of the value.\nIn certain cases, the long-format is not really “human-readable”, and another format, a wide-format is preferred, as a more compact way of representing the data. This is typically the case with gene expression values that scientists are used to look as matrices, were rows represent genes and columns represent samples.\nIn this format, it would therefore become straightforward to explore the relationship between the gene expression levels within, and between, the samples.\nTo convert the gene expression values from rna into a wide-format, we need to create a new table where the values of the sample column would become the names of column variables.\nThe key point here is that we are still following a tidy data structure, but we have reshaped the data according to the observations of interest: expression levels per gene instead of recording them per gene and per sample.\nThe opposite transformation would be to transform column names into values of a new variable.\nWe can do both these of transformations with two tidyr functions, pivot_longer() and pivot_wider() (see here for details).\n\n\n\nLet’s select the first 3 columns of rna and use pivot_wider() to transform the data into a wide-format.\n\nrna_exp &lt;- rna %&gt;%\n  select(gene, sample, expression)\nrna_exp\n\n# A tibble: 32,428 × 3\n   gene    sample     expression\n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545336       1170\n 2 Apod    GSM2545336      36194\n 3 Cyp2d22 GSM2545336       4060\n 4 Klk6    GSM2545336        287\n 5 Fcrls   GSM2545336         85\n 6 Slc2a4  GSM2545336        782\n 7 Exd2    GSM2545336       1619\n 8 Gjc2    GSM2545336        288\n 9 Plp1    GSM2545336      43217\n10 Gnb4    GSM2545336       1071\n# ℹ 32,418 more rows\n\n\n\n\n\n\n\n\nNote\n\n\n\npivot_wider takes three main arguments:\n\nthe data to be transformed;\nthe names_from : the column whose values will become new column names;\nthe values_from: the column whose values will fill the new columns.\n\n\n\n\n\nrna_wide &lt;- rna_exp %&gt;%\n  pivot_wider(names_from = sample,\n              values_from = expression)\nrna_wide\n\n# A tibble: 1,474 × 23\n   gene    GSM2545336 GSM2545337 GSM2545338 GSM2545339 GSM2545340 GSM2545341\n   &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n 1 Asl           1170        361        400        586        626        988\n 2 Apod         36194      10347       9173      10620      13021      29594\n 3 Cyp2d22       4060       1616       1603       1901       2171       3349\n 4 Klk6           287        629        641        578        448        195\n 5 Fcrls           85        233        244        237        180         38\n 6 Slc2a4         782        231        248        265        313        786\n 7 Exd2          1619       2288       2235       2513       2366       1359\n 8 Gjc2           288        595        568        551        310        146\n 9 Plp1         43217     101241      96534      58354      53126      27173\n10 Gnb4          1071       1791       1867       1430       1355        798\n# ℹ 1,464 more rows\n# ℹ 16 more variables: GSM2545342 &lt;dbl&gt;, GSM2545343 &lt;dbl&gt;, GSM2545344 &lt;dbl&gt;,\n#   GSM2545345 &lt;dbl&gt;, GSM2545346 &lt;dbl&gt;, GSM2545347 &lt;dbl&gt;, GSM2545348 &lt;dbl&gt;,\n#   GSM2545349 &lt;dbl&gt;, GSM2545350 &lt;dbl&gt;, GSM2545351 &lt;dbl&gt;, GSM2545352 &lt;dbl&gt;,\n#   GSM2545353 &lt;dbl&gt;, GSM2545354 &lt;dbl&gt;, GSM2545362 &lt;dbl&gt;, GSM2545363 &lt;dbl&gt;,\n#   GSM2545380 &lt;dbl&gt;\n\n\nNote that by default, the pivot_wider() function will add NA for missing values.\nLet’s imagine that for some reason, we had some missing expression values for some genes in certain samples. In the following fictive example, the gene Cyp2d22 has only one expression value, in GSM2545338 sample.\n\nrna_with_missing_values &lt;- rna %&gt;%\n  select(gene, sample, expression) %&gt;%\n  filter(gene %in% c(\"Asl\", \"Apod\", \"Cyp2d22\")) %&gt;%\n  filter(sample %in% c(\"GSM2545336\", \"GSM2545337\", \"GSM2545338\")) %&gt;%\n  arrange(sample) %&gt;%\n  filter(!(gene == \"Cyp2d22\" & sample != \"GSM2545338\"))\nrna_with_missing_values\n\n# A tibble: 7 × 3\n  gene    sample     expression\n  &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n1 Asl     GSM2545336       1170\n2 Apod    GSM2545336      36194\n3 Asl     GSM2545337        361\n4 Apod    GSM2545337      10347\n5 Asl     GSM2545338        400\n6 Apod    GSM2545338       9173\n7 Cyp2d22 GSM2545338       1603\n\n\nBy default, the pivot_wider() function will add NA for missing values. This can be parameterised with the values_fill argument of the pivot_wider() function.\n\nrna_with_missing_values %&gt;%\n  pivot_wider(names_from = sample,values_from = expression)\n\n# A tibble: 3 × 4\n  gene    GSM2545336 GSM2545337 GSM2545338\n  &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 Asl           1170        361        400\n2 Apod         36194      10347       9173\n3 Cyp2d22         NA         NA       1603\n\n\n\nrna_with_missing_values %&gt;%\n  pivot_wider(names_from = sample,values_from = expression,values_fill = 0)\n\n# A tibble: 3 × 4\n  gene    GSM2545336 GSM2545337 GSM2545338\n  &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 Asl           1170        361        400\n2 Apod         36194      10347       9173\n3 Cyp2d22          0          0       1603\n\n\n\n\n\nIn the opposite situation we are using the column names and turning them into a pair of new variables. One variable represents the column names as values, and the other variable contains the values previously associated with the column names.\n\n\n\n\n\n\nNote\n\n\n\npivot_longer() takes four main arguments:\n\nthe data to be transformed;\nthe names_to: the new column name we wish to create and populate with the current column names;\nthe values_to: the new column name we wish to create and populate with current values;\nthe names of the columns to be used to populate the names_to and values_to variables (or to drop).\n\n\n\n\nTo recreate rna_long from rna_wide we would create a key called sample and value called expression and use all columns except gene for the key variable. Here we drop gene column with a minus sign.\n\n\n\n\n\n\nImportant\n\n\n\nNotice how the new variable names are to be quoted here.\n\n\n\nrna_long &lt;- rna_wide %&gt;%\n    pivot_longer(names_to = \"sample\",values_to = \"expression\",-gene)\nrna_long\n\n# A tibble: 32,428 × 3\n   gene  sample     expression\n   &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl   GSM2545336       1170\n 2 Asl   GSM2545337        361\n 3 Asl   GSM2545338        400\n 4 Asl   GSM2545339        586\n 5 Asl   GSM2545340        626\n 6 Asl   GSM2545341        988\n 7 Asl   GSM2545342        836\n 8 Asl   GSM2545343        535\n 9 Asl   GSM2545344        586\n10 Asl   GSM2545345        597\n# ℹ 32,418 more rows\n\n\nWe could also have used a specification for what columns to include. This can be useful if you have a large number of identifying columns, and it’s easier to specify what to gather than what to leave alone. Here the starts_with() function can help to retrieve sample names without having to list them all! Another possibility would be to use the : operator!\n\nrna_wide %&gt;%\n    pivot_longer(names_to = \"sample\",values_to = \"expression\",\ncols = starts_with(\"GSM\"))\n\n# A tibble: 32,428 × 3\n   gene  sample     expression\n   &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl   GSM2545336       1170\n 2 Asl   GSM2545337        361\n 3 Asl   GSM2545338        400\n 4 Asl   GSM2545339        586\n 5 Asl   GSM2545340        626\n 6 Asl   GSM2545341        988\n 7 Asl   GSM2545342        836\n 8 Asl   GSM2545343        535\n 9 Asl   GSM2545344        586\n10 Asl   GSM2545345        597\n# ℹ 32,418 more rows\n\n\n\nrna_wide %&gt;%\n    pivot_longer(names_to = \"sample\",values_to = \"expression\",\nGSM2545336:GSM2545380)\n\n# A tibble: 32,428 × 3\n   gene  sample     expression\n   &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl   GSM2545336       1170\n 2 Asl   GSM2545337        361\n 3 Asl   GSM2545338        400\n 4 Asl   GSM2545339        586\n 5 Asl   GSM2545340        626\n 6 Asl   GSM2545341        988\n 7 Asl   GSM2545342        836\n 8 Asl   GSM2545343        535\n 9 Asl   GSM2545344        586\n10 Asl   GSM2545345        597\n# ℹ 32,418 more rows\n\n\nNote that if we had missing values in the wide-format, the NA would be included in the new long format.\nRemember our previous fictive tibble containing missing values:\n\nrna_with_missing_values\n\n# A tibble: 7 × 3\n  gene    sample     expression\n  &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n1 Asl     GSM2545336       1170\n2 Apod    GSM2545336      36194\n3 Asl     GSM2545337        361\n4 Apod    GSM2545337      10347\n5 Asl     GSM2545338        400\n6 Apod    GSM2545338       9173\n7 Cyp2d22 GSM2545338       1603\n\n\n\nwide_with_NA &lt;- rna_with_missing_values %&gt;%\n  pivot_wider(names_from = sample,\nvalues_from = expression)\nwide_with_NA\n\n# A tibble: 3 × 4\n  gene    GSM2545336 GSM2545337 GSM2545338\n  &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 Asl           1170        361        400\n2 Apod         36194      10347       9173\n3 Cyp2d22         NA         NA       1603\n\n\n\nwide_with_NA %&gt;%\npivot_longer(names_to = \"sample\",\nvalues_to = \"expression\",\n-gene)\n\n# A tibble: 9 × 3\n  gene    sample     expression\n  &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n1 Asl     GSM2545336       1170\n2 Asl     GSM2545337        361\n3 Asl     GSM2545338        400\n4 Apod    GSM2545336      36194\n5 Apod    GSM2545337      10347\n6 Apod    GSM2545338       9173\n7 Cyp2d22 GSM2545336         NA\n8 Cyp2d22 GSM2545337         NA\n9 Cyp2d22 GSM2545338       1603\n\n\nPivoting to wider and longer formats can be a useful way to balance out a dataset so every replicate has the same composition.\n\n\n\n\n\n\nQuestion\n\n\n\nStarting from the rna table, use the pivot_wider() function to create a wide-format table giving the gene expression levels in each mouse. Then use the pivot_longer() function to restore a long-format table.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nFrom long to wide :\n\nrna1 &lt;- rna %&gt;%\nselect(gene, mouse, expression) %&gt;%\npivot_wider(names_from = mouse, values_from = expression)\nrna1\n\n# A tibble: 1,474 × 23\n   gene     `14`    `9`  `10`  `15`  `18`   `6`   `5`  `11`  `22`  `13`  `23`\n   &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 Asl      1170    361   400   586   626   988   836   535   586   597   938\n 2 Apod    36194  10347  9173 10620 13021 29594 24959 13668 13230 15868 27769\n 3 Cyp2d22  4060   1616  1603  1901  2171  3349  3122  2008  2254  2277  2985\n 4 Klk6      287    629   641   578   448   195   186  1101   537   567   327\n 5 Fcrls      85    233   244   237   180    38    68   375   199   177    89\n 6 Slc2a4    782    231   248   265   313   786   528   249   266   357   654\n 7 Exd2     1619   2288  2235  2513  2366  1359  1474  3126  2379  2173  1531\n 8 Gjc2      288    595   568   551   310   146   186   791   454   370   240\n 9 Plp1    43217 101241 96534 58354 53126 27173 28728 98658 61356 61647 38019\n10 Gnb4     1071   1791  1867  1430  1355   798   806  2437  1394  1554   960\n# ℹ 1,464 more rows\n# ℹ 11 more variables: `24` &lt;dbl&gt;, `8` &lt;dbl&gt;, `7` &lt;dbl&gt;, `1` &lt;dbl&gt;, `16` &lt;dbl&gt;,\n#   `21` &lt;dbl&gt;, `4` &lt;dbl&gt;, `2` &lt;dbl&gt;, `20` &lt;dbl&gt;, `12` &lt;dbl&gt;, `19` &lt;dbl&gt;\n\n\nFrom wide to long :\n\nrna1 %&gt;%\npivot_longer(names_to = \"mouse_id\", values_to = \"counts\", -gene)\n\n# A tibble: 32,428 × 3\n   gene  mouse_id counts\n   &lt;chr&gt; &lt;chr&gt;     &lt;dbl&gt;\n 1 Asl   14         1170\n 2 Asl   9           361\n 3 Asl   10          400\n 4 Asl   15          586\n 5 Asl   18          626\n 6 Asl   6           988\n 7 Asl   5           836\n 8 Asl   11          535\n 9 Asl   22          586\n10 Asl   13          597\n# ℹ 32,418 more rows\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nSubset genes located on X and Y chromosomes from the rna data frame and spread the data frame with sex as columns, chromosome_name as rows, and the mean expression of genes located in each chromosome as the values, as in the following tibble:\n\nYou will need to summarise before reshaping!\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nLet’s first calculate the mean expression level of X and Y linked genes from male and female samples…\n\nrna %&gt;%\n  filter(chromosome_name == \"Y\" | chromosome_name == \"X\") %&gt;%\n  group_by(sex, chromosome_name) %&gt;%\n  summarise(mean = mean(expression))\n\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\n\n\n# A tibble: 4 × 3\n# Groups:   sex [2]\n  sex    chromosome_name  mean\n  &lt;chr&gt;  &lt;chr&gt;           &lt;dbl&gt;\n1 Female X               3504.\n2 Female Y                  3 \n3 Male   X               2497.\n4 Male   Y               2117.\n\n\nAnd pivot the table to wide format\n\nrna_1 &lt;- rna %&gt;%\n  filter(chromosome_name == \"Y\" | chromosome_name == \"X\") %&gt;%\n  group_by(sex, chromosome_name) %&gt;%\n  summarise(mean = mean(expression)) %&gt;%\n  pivot_wider(names_from = sex,\n              values_from = mean)\n\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\n\nrna_1\n\n# A tibble: 2 × 3\n  chromosome_name Female  Male\n  &lt;chr&gt;            &lt;dbl&gt; &lt;dbl&gt;\n1 X                3504. 2497.\n2 Y                   3  2117.\n\n\nNow take that data frame and transform it with pivot_longer() so each row is a unique chromosome_name by gender combination.\n\nrna_1 %&gt;%\n  pivot_longer(names_to = \"gender\",\n               values_to = \"mean\",\n               -chromosome_name)\n\n# A tibble: 4 × 3\n  chromosome_name gender  mean\n  &lt;chr&gt;           &lt;chr&gt;  &lt;dbl&gt;\n1 X               Female 3504.\n2 X               Male   2497.\n3 Y               Female    3 \n4 Y               Male   2117.\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nUse the rna dataset to create an expression matrix where each row represents the mean expression levels of genes and columns represent the different timepoints.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nLet’s first calculate the mean expression by gene and by timebefore using the pivot_wider() function\n\nrna %&gt;%\n  group_by(gene, time) %&gt;%\n  summarise(mean_exp = mean(expression))\n\n`summarise()` has grouped output by 'gene'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 4,422 × 3\n# Groups:   gene [1,474]\n   gene      time mean_exp\n   &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n 1 AI504432     0    1034.\n 2 AI504432     4    1104.\n 3 AI504432     8    1014 \n 4 AW046200     0     155.\n 5 AW046200     4     152.\n 6 AW046200     8      81 \n 7 AW551984     0     238 \n 8 AW551984     4     302.\n 9 AW551984     8     342.\n10 Aamp         0    4603.\n# ℹ 4,412 more rows\n\n\nThen we use the pivot_wider() function\n\nrna_time &lt;- rna %&gt;%\n  group_by(gene, time) %&gt;%\n  summarise(mean_exp = mean(expression)) %&gt;%\n  pivot_wider(names_from = time,\n              values_from = mean_exp)\n\n`summarise()` has grouped output by 'gene'. You can override using the\n`.groups` argument.\n\nrna_time\n\n# A tibble: 1,474 × 4\n# Groups:   gene [1,474]\n   gene         `0`     `4`     `8`\n   &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1 AI504432 1034.   1104.   1014   \n 2 AW046200  155.    152.     81   \n 3 AW551984  238     302.    342.  \n 4 Aamp     4603.   4870    4763.  \n 5 Abca12      5.29    4.25    4.14\n 6 Abcc8    2576.   2609.   2292.  \n 7 Abhd14a   591.    547.    432.  \n 8 Abi2     4881.   4903.   4945.  \n 9 Abi3bp   1175.   1061.    762.  \n10 Abl2     2170.   2078.   2131.  \n# ℹ 1,464 more rows\n\n\nNotice that this generates a tibble with some column names starting by a number. If we wanted to select the column corresponding to the timepoints, we could not use the column names directly… What happens when we select the column 4?\n\nrna %&gt;%\n  group_by(gene, time) %&gt;%\n  summarise(mean_exp = mean(expression)) %&gt;%\n  pivot_wider(names_from = time,\n              values_from = mean_exp) %&gt;%\n  select(gene, 4)\n\n`summarise()` has grouped output by 'gene'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1,474 × 2\n# Groups:   gene [1,474]\n   gene         `8`\n   &lt;chr&gt;      &lt;dbl&gt;\n 1 AI504432 1014   \n 2 AW046200   81   \n 3 AW551984  342.  \n 4 Aamp     4763.  \n 5 Abca12      4.14\n 6 Abcc8    2292.  \n 7 Abhd14a   432.  \n 8 Abi2     4945.  \n 9 Abi3bp    762.  \n10 Abl2     2131.  \n# ℹ 1,464 more rows\n\n\nTo select the timepoint 4, we would have to quote the column name, with backticks “`”\n\nrna %&gt;%\n  group_by(gene, time) %&gt;%\n  summarise(mean_exp = mean(expression)) %&gt;%\n  pivot_wider(names_from = time,\n              values_from = mean_exp) %&gt;%\n  select(gene, `4`)\n\n`summarise()` has grouped output by 'gene'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1,474 × 2\n# Groups:   gene [1,474]\n   gene         `4`\n   &lt;chr&gt;      &lt;dbl&gt;\n 1 AI504432 1104.  \n 2 AW046200  152.  \n 3 AW551984  302.  \n 4 Aamp     4870   \n 5 Abca12      4.25\n 6 Abcc8    2609.  \n 7 Abhd14a   547.  \n 8 Abi2     4903.  \n 9 Abi3bp   1061.  \n10 Abl2     2078.  \n# ℹ 1,464 more rows\n\n\nAnother possibility would be to rename the column, choosing a name that doesn’t start by a number :\n\nrna %&gt;%\n  group_by(gene, time) %&gt;%\n  summarise(mean_exp = mean(expression)) %&gt;%\n  pivot_wider(names_from = time,\n              values_from = mean_exp) %&gt;%\n  rename(\"time0\" = `0`, \"time4\" = `4`, \"time8\" = `8`) %&gt;%\n  select(gene, time4)\n\n`summarise()` has grouped output by 'gene'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1,474 × 2\n# Groups:   gene [1,474]\n   gene       time4\n   &lt;chr&gt;      &lt;dbl&gt;\n 1 AI504432 1104.  \n 2 AW046200  152.  \n 3 AW551984  302.  \n 4 Aamp     4870   \n 5 Abca12      4.25\n 6 Abcc8    2609.  \n 7 Abhd14a   547.  \n 8 Abi2     4903.  \n 9 Abi3bp   1061.  \n10 Abl2     2078.  \n# ℹ 1,464 more rows\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nUse the previous data frame containing mean expression levels per timepoint and create a new column containing fold-changes between timepoint 8 and timepoint 0, and fold-changes between timepoint 8 and timepoint 4. Convert this table into a long-format table gathering the fold-changes calculated.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nStarting from the rna_time tibble:\n\nrna_time\n\n# A tibble: 1,474 × 4\n# Groups:   gene [1,474]\n   gene         `0`     `4`     `8`\n   &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1 AI504432 1034.   1104.   1014   \n 2 AW046200  155.    152.     81   \n 3 AW551984  238     302.    342.  \n 4 Aamp     4603.   4870    4763.  \n 5 Abca12      5.29    4.25    4.14\n 6 Abcc8    2576.   2609.   2292.  \n 7 Abhd14a   591.    547.    432.  \n 8 Abi2     4881.   4903.   4945.  \n 9 Abi3bp   1175.   1061.    762.  \n10 Abl2     2170.   2078.   2131.  \n# ℹ 1,464 more rows\n\n\nCalculate fold-changes:\n\nrna_time %&gt;%\n  mutate(time_8_vs_0 = `8` / `0`, time_8_vs_4 = `8` / `4`)\n\n# A tibble: 1,474 × 6\n# Groups:   gene [1,474]\n   gene         `0`     `4`     `8` time_8_vs_0 time_8_vs_4\n   &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 AI504432 1034.   1104.   1014          0.981       0.918\n 2 AW046200  155.    152.     81          0.522       0.532\n 3 AW551984  238     302.    342.         1.44        1.13 \n 4 Aamp     4603.   4870    4763.         1.03        0.978\n 5 Abca12      5.29    4.25    4.14       0.784       0.975\n 6 Abcc8    2576.   2609.   2292.         0.889       0.878\n 7 Abhd14a   591.    547.    432.         0.731       0.791\n 8 Abi2     4881.   4903.   4945.         1.01        1.01 \n 9 Abi3bp   1175.   1061.    762.         0.649       0.719\n10 Abl2     2170.   2078.   2131.         0.982       1.03 \n# ℹ 1,464 more rows\n\n\nAnd use the pivot_longer() function:\n\nrna_time %&gt;%\n  mutate(time_8_vs_0 = `8` / `0`, time_8_vs_4 = `8` / `4`) %&gt;%\n  pivot_longer(names_to = \"comparisons\",\n               values_to = \"Fold_changes\",\n               time_8_vs_0:time_8_vs_4)\n\n# A tibble: 2,948 × 6\n# Groups:   gene [1,474]\n   gene         `0`     `4`     `8` comparisons Fold_changes\n   &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;              &lt;dbl&gt;\n 1 AI504432 1034.   1104.   1014    time_8_vs_0        0.981\n 2 AI504432 1034.   1104.   1014    time_8_vs_4        0.918\n 3 AW046200  155.    152.     81    time_8_vs_0        0.522\n 4 AW046200  155.    152.     81    time_8_vs_4        0.532\n 5 AW551984  238     302.    342.   time_8_vs_0        1.44 \n 6 AW551984  238     302.    342.   time_8_vs_4        1.13 \n 7 Aamp     4603.   4870    4763.   time_8_vs_0        1.03 \n 8 Aamp     4603.   4870    4763.   time_8_vs_4        0.978\n 9 Abca12      5.29    4.25    4.14 time_8_vs_0        0.784\n10 Abca12      5.29    4.25    4.14 time_8_vs_4        0.975\n# ℹ 2,938 more rows\n\n\n\n\n\n\n\n\nIn many real life situations, data are spread across multiple tables. Usually this occurs because different types of information are collected from different sources.\nIt may be desirable for some analyses to combine data from two or more tables into a single data frame based on a column that would be common to all the tables.\nThe dplyr package provides a set of join functions for combining two data frames based on matches within specified columns. Here, we provide a short introduction to joins. For further reading, please refer to the chapter about table joins. The Data Transformation Cheat Sheet also provides a short overview on table joins.\nWe are going to illustrate join using a small table, rna_mini that we will create by subsetting the original rna table, keeping only 3 columns and 10 lines.\n\nrna_mini &lt;- rna %&gt;%\n   select(gene, sample, expression) %&gt;%\n   head(10)\nrna_mini\n\n# A tibble: 10 × 3\n   gene    sample     expression\n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545336       1170\n 2 Apod    GSM2545336      36194\n 3 Cyp2d22 GSM2545336       4060\n 4 Klk6    GSM2545336        287\n 5 Fcrls   GSM2545336         85\n 6 Slc2a4  GSM2545336        782\n 7 Exd2    GSM2545336       1619\n 8 Gjc2    GSM2545336        288\n 9 Plp1    GSM2545336      43217\n10 Gnb4    GSM2545336       1071\n\n\nThe second table, annot1, contains 2 columns, gene and gene_description. You can either download annot1.csv by clicking on the link and then moving it to the data/ folder, or you can use the R code below to download it directly to the folder.\n\ndownload.file(url = \"https://carpentries-incubator.github.io/bioc-intro/data/annot1.csv\",\n              destfile = \"data/annot1.csv\")\nannot1 &lt;- read_csv(file = \"data/annot1.csv\")\n\nRows: 10 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): gene, gene_description\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nannot1\n\n# A tibble: 10 × 2\n   gene    gene_description                                                     \n   &lt;chr&gt;   &lt;chr&gt;                                                                \n 1 Cyp2d22 cytochrome P450, family 2, subfamily d, polypeptide 22 [Source:MGI S…\n 2 Klk6    kallikrein related-peptidase 6 [Source:MGI Symbol;Acc:MGI:1343166]   \n 3 Fcrls   Fc receptor-like S, scavenger receptor [Source:MGI Symbol;Acc:MGI:19…\n 4 Plp1    proteolipid protein (myelin) 1 [Source:MGI Symbol;Acc:MGI:97623]     \n 5 Exd2    exonuclease 3'-5' domain containing 2 [Source:MGI Symbol;Acc:MGI:192…\n 6 Apod    apolipoprotein D [Source:MGI Symbol;Acc:MGI:88056]                   \n 7 Gnb4    guanine nucleotide binding protein (G protein), beta 4 [Source:MGI S…\n 8 Slc2a4  solute carrier family 2 (facilitated glucose transporter), member 4 …\n 9 Asl     argininosuccinate lyase [Source:MGI Symbol;Acc:MGI:88084]            \n10 Gjc2    gap junction protein, gamma 2 [Source:MGI Symbol;Acc:MGI:2153060]    \n\n\nWe now want to join these two tables into a single one containing all variables using the full_join() function from the dplyr package. The function will automatically find the common variable to match columns from the first and second table. In this case, gene is the common variable. Such variables are called keys. Keys are used to match observations across different tables.\n\nfull_join(rna_mini, annot1)\n\nJoining with `by = join_by(gene)`\n\n\n# A tibble: 10 × 4\n   gene    sample     expression gene_description                               \n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;                                          \n 1 Asl     GSM2545336       1170 argininosuccinate lyase [Source:MGI Symbol;Acc…\n 2 Apod    GSM2545336      36194 apolipoprotein D [Source:MGI Symbol;Acc:MGI:88…\n 3 Cyp2d22 GSM2545336       4060 cytochrome P450, family 2, subfamily d, polype…\n 4 Klk6    GSM2545336        287 kallikrein related-peptidase 6 [Source:MGI Sym…\n 5 Fcrls   GSM2545336         85 Fc receptor-like S, scavenger receptor [Source…\n 6 Slc2a4  GSM2545336        782 solute carrier family 2 (facilitated glucose t…\n 7 Exd2    GSM2545336       1619 exonuclease 3'-5' domain containing 2 [Source:…\n 8 Gjc2    GSM2545336        288 gap junction protein, gamma 2 [Source:MGI Symb…\n 9 Plp1    GSM2545336      43217 proteolipid protein (myelin) 1 [Source:MGI Sym…\n10 Gnb4    GSM2545336       1071 guanine nucleotide binding protein (G protein)…\n\n\nIn real life, gene annotations are sometimes labelled differently.\nThe annot2 table is exactly the same than annot1 except that the variable containing gene names is labelled differently. Again, either download annot2.csv yourself and move it to data/ or use the R code below.\n\ndownload.file(url = \"https://carpentries-incubator.github.io/bioc-intro/data/annot2.csv\",\n              destfile = \"data/annot2.csv\")\nannot2 &lt;- read_csv(file = \"data/annot2.csv\")\n\nRows: 10 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): external_gene_name, description\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nannot2\n\n# A tibble: 10 × 2\n   external_gene_name description                                               \n   &lt;chr&gt;              &lt;chr&gt;                                                     \n 1 Cyp2d22            cytochrome P450, family 2, subfamily d, polypeptide 22 [S…\n 2 Klk6               kallikrein related-peptidase 6 [Source:MGI Symbol;Acc:MGI…\n 3 Fcrls              Fc receptor-like S, scavenger receptor [Source:MGI Symbol…\n 4 Plp1               proteolipid protein (myelin) 1 [Source:MGI Symbol;Acc:MGI…\n 5 Exd2               exonuclease 3'-5' domain containing 2 [Source:MGI Symbol;…\n 6 Apod               apolipoprotein D [Source:MGI Symbol;Acc:MGI:88056]        \n 7 Gnb4               guanine nucleotide binding protein (G protein), beta 4 [S…\n 8 Slc2a4             solute carrier family 2 (facilitated glucose transporter)…\n 9 Asl                argininosuccinate lyase [Source:MGI Symbol;Acc:MGI:88084] \n10 Gjc2               gap junction protein, gamma 2 [Source:MGI Symbol;Acc:MGI:…\n\n\nIn case none of the variable names match, we can set manually the variables to use for the matching. These variables can be set using the by argument, as shown below with rna_mini and annot2 tables.\n\nfull_join(rna_mini, annot2, by = c(\"gene\" = \"external_gene_name\"))\n\n# A tibble: 10 × 4\n   gene    sample     expression description                                    \n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;                                          \n 1 Asl     GSM2545336       1170 argininosuccinate lyase [Source:MGI Symbol;Acc…\n 2 Apod    GSM2545336      36194 apolipoprotein D [Source:MGI Symbol;Acc:MGI:88…\n 3 Cyp2d22 GSM2545336       4060 cytochrome P450, family 2, subfamily d, polype…\n 4 Klk6    GSM2545336        287 kallikrein related-peptidase 6 [Source:MGI Sym…\n 5 Fcrls   GSM2545336         85 Fc receptor-like S, scavenger receptor [Source…\n 6 Slc2a4  GSM2545336        782 solute carrier family 2 (facilitated glucose t…\n 7 Exd2    GSM2545336       1619 exonuclease 3'-5' domain containing 2 [Source:…\n 8 Gjc2    GSM2545336        288 gap junction protein, gamma 2 [Source:MGI Symb…\n 9 Plp1    GSM2545336      43217 proteolipid protein (myelin) 1 [Source:MGI Sym…\n10 Gnb4    GSM2545336       1071 guanine nucleotide binding protein (G protein)…\n\n\nAs can be seen above, the variable name of the first table is retained in the joined one.\n\n\n\n\n\n\nQuestion\n\n\n\nDownload the annot3 table by clicking here and put the table in your data/ repository. Using the full_join() function, join tables rna_mini and annot3. What has happened for genes Klk6, mt-Tf, mt-Rnr1, mt-Tv, mt-Rnr2, and mt-Tl1 ?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ndownload.file(url = \"https://carpentries-incubator.github.io/bioc-intro/data/annot3.csv\",destfile = \"data/annot3.csv\")\nannot3 &lt;- read_csv(\"data/annot3.csv\")\n\nRows: 14 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): gene, gene_description\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nfull_join(rna_mini, annot3)\n\nJoining with `by = join_by(gene)`\n\n\n# A tibble: 15 × 4\n   gene    sample     expression gene_description                               \n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;                                          \n 1 Asl     GSM2545336       1170 argininosuccinate lyase [Source:MGI Symbol;Acc…\n 2 Apod    GSM2545336      36194 apolipoprotein D [Source:MGI Symbol;Acc:MGI:88…\n 3 Cyp2d22 GSM2545336       4060 cytochrome P450, family 2, subfamily d, polype…\n 4 Klk6    GSM2545336        287 &lt;NA&gt;                                           \n 5 Fcrls   GSM2545336         85 Fc receptor-like S, scavenger receptor [Source…\n 6 Slc2a4  GSM2545336        782 solute carrier family 2 (facilitated glucose t…\n 7 Exd2    GSM2545336       1619 exonuclease 3'-5' domain containing 2 [Source:…\n 8 Gjc2    GSM2545336        288 gap junction protein, gamma 2 [Source:MGI Symb…\n 9 Plp1    GSM2545336      43217 proteolipid protein (myelin) 1 [Source:MGI Sym…\n10 Gnb4    GSM2545336       1071 guanine nucleotide binding protein (G protein)…\n11 mt-Tf   &lt;NA&gt;               NA mitochondrially encoded tRNA phenylalanine [So…\n12 mt-Rnr1 &lt;NA&gt;               NA mitochondrially encoded 12S rRNA [Source:MGI S…\n13 mt-Tv   &lt;NA&gt;               NA mitochondrially encoded tRNA valine [Source:MG…\n14 mt-Rnr2 &lt;NA&gt;               NA mitochondrially encoded 16S rRNA [Source:MGI S…\n15 mt-Tl1  &lt;NA&gt;               NA mitochondrially encoded tRNA leucine 1 [Source…\n\n\nGenes Klk6 is only present in rna_mini, while genes mt-Tf, mt-Rnr1, mt-Tv, mt-Rnr2, and mt-Tl1 are only present in annot3 table. Their respective values for the variables of the table have been encoded as missing.\n\n\n\n\n\n\nNow that you have learned how to use dplyr to extract information from or summarise your raw data, you may want to export these new data sets to share them with your collaborators or for archival.\nSimilar to the read_csv() function used for reading CSV files into R, there is a write_csv() function that generates CSV files from data frames.\nBefore using write_csv(), we are going to create a new folder, data_output, in our working directory that will store this generated dataset. We don’t want to write generated datasets in the same directory as our raw data. It’s good practice to keep them separate. The data folder should only contain the raw, unaltered data, and should be left alone to make sure we don’t delete or modify it. In contrast, our script will generate the contents of the data_output directory, so even if the files it contains are deleted, we can always re-generate them.\nLet’s use write_csv() to save the rna_wide table that we have created previously.\n\nwrite_csv(rna_wide, file = \"data_output/rna_wide.csv\")"
  },
  {
    "objectID": "bioc_intro_dataManipulation_solutions.html#data-manipulation-using-dplyr-and-tidyr",
    "href": "bioc_intro_dataManipulation_solutions.html#data-manipulation-using-dplyr-and-tidyr",
    "title": "Manipulating and analysing data with dplyr",
    "section": "",
    "text": "Bracket subsetting is handy, but it can be cumbersome and difficult to read, especially for complicated operations.\nSome packages can greatly facilitate our task when we manipulate data. Packages in R are basically sets of additional functions that let you do more stuff. The functions we’ve been using so far, like str() or data.frame(), come built into R; Loading packages can give you access to other specific functions. Before you use a package for the first time you need to install it on your machine, and then you should import it in every subsequent R session when you need it.\n\nThe package dplyr provides powerful tools for data manipulation tasks. It is built to work directly with data frames, with many manipulation tasks optimised.\nAs we will see latter on, sometimes we want a data frame to be reshaped to be able to do some specific analyses or for visualisation. The package tidyr addresses this common problem of reshaping data and provides tools for manipulating data in a tidy way.\n\nTo learn more about dplyr and tidyr after the workshop, you may want to check out this handy data transformation with dplyr cheatsheet and this one about tidyr.\n\nThe tidyverse package is an “umbrella-package” that installs several useful packages for data analysis which work well together, such as tidyr, dplyr, ggplot2, tibble, etc. These packages help us to work and interact with the data. They allow us to do many things with your data, such as subsetting, transforming, visualising, etc.\n\nIf you did the set up, you should have already installed the tidyverse package. Check to see if you have it by trying to load in from the library:\n\n## load the tidyverse packages, incl. dplyr\nlibrary(\"tidyverse\")\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nIf you got an error message there is no package called ‘tidyverse’ then you have not installed the package yet for this version of R. To install the tidyverse package type:\n\nBiocManager::install(\"tidyverse\")\n\nIf you had to install the tidyverse package, do not forget to load it in this R session by using the library() command above!\n\n\nInstead of read.csv(), we will read in our data using the read_csv() function (notice the _ instead of the .), from the tidyverse package readr.\n\nrna &lt;- read_csv(\"data/rnaseq.csv\")\n\nRows: 32428 Columns: 19\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (14): gene, sample, organism, sex, infection, strain, tissue, product, e...\ndbl  (5): expression, age, time, mouse, ENTREZID\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n## view the data\nrna\n\n# A tibble: 32,428 × 19\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…       1170 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 Apod    GSM254…      36194 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 3 Cyp2d22 GSM254…       4060 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 4 Klk6    GSM254…        287 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 5 Fcrls   GSM254…         85 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 6 Slc2a4  GSM254…        782 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 7 Exd2    GSM254…       1619 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 Gjc2    GSM254…        288 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 9 Plp1    GSM254…      43217 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n10 Gnb4    GSM254…       1071 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\n\n\n\n\n\n\nImportant\n\n\n\nNotice that the class of the data is now referred to as a “tibble”.\n\n\nTibbles tweak some of the behaviors of the data frame objects we introduced in the previously. The data structure is very similar to a data frame. For our purposes the only differences are that:\n\nIt displays the data type of each column under its name. Note that &lt;dbl&gt; is a data type defined to hold numeric values with decimal points.\nIt only prints the first few rows of data and only as many columns as fit on one screen.\n\nWe are now going to learn some of the most common dplyr functions:\n\nselect(): subset columns\nfilter(): subset rows on conditions\nmutate(): create new columns by using information from other columns\ngroup_by() and summarise(): create summary statistics on grouped data\narrange(): sort results\ncount(): count discrete values\n\n\n\n\nTo select columns of a data frame, use select(). The first argument to this function is the data frame (rna), and the subsequent arguments are the columns to keep.\n\nselect(rna, gene, sample, tissue, expression)\n\n# A tibble: 32,428 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545336 Cerebellum       1170\n 2 Apod    GSM2545336 Cerebellum      36194\n 3 Cyp2d22 GSM2545336 Cerebellum       4060\n 4 Klk6    GSM2545336 Cerebellum        287\n 5 Fcrls   GSM2545336 Cerebellum         85\n 6 Slc2a4  GSM2545336 Cerebellum        782\n 7 Exd2    GSM2545336 Cerebellum       1619\n 8 Gjc2    GSM2545336 Cerebellum        288\n 9 Plp1    GSM2545336 Cerebellum      43217\n10 Gnb4    GSM2545336 Cerebellum       1071\n# ℹ 32,418 more rows\n\n\nTo select all columns except certain ones, put a “-” in front of the variable to exclude it.\n\nselect(rna, -tissue, -organism)\n\n# A tibble: 32,428 × 17\n   gene    sample   expression   age sex   infection strain  time mouse ENTREZID\n   &lt;chr&gt;   &lt;chr&gt;         &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;\n 1 Asl     GSM2545…       1170     8 Fema… Influenz… C57BL…     8    14   109900\n 2 Apod    GSM2545…      36194     8 Fema… Influenz… C57BL…     8    14    11815\n 3 Cyp2d22 GSM2545…       4060     8 Fema… Influenz… C57BL…     8    14    56448\n 4 Klk6    GSM2545…        287     8 Fema… Influenz… C57BL…     8    14    19144\n 5 Fcrls   GSM2545…         85     8 Fema… Influenz… C57BL…     8    14    80891\n 6 Slc2a4  GSM2545…        782     8 Fema… Influenz… C57BL…     8    14    20528\n 7 Exd2    GSM2545…       1619     8 Fema… Influenz… C57BL…     8    14    97827\n 8 Gjc2    GSM2545…        288     8 Fema… Influenz… C57BL…     8    14   118454\n 9 Plp1    GSM2545…      43217     8 Fema… Influenz… C57BL…     8    14    18823\n10 Gnb4    GSM2545…       1071     8 Fema… Influenz… C57BL…     8    14    14696\n# ℹ 32,418 more rows\n# ℹ 7 more variables: product &lt;chr&gt;, ensembl_gene_id &lt;chr&gt;,\n#   external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;, gene_biotype &lt;chr&gt;,\n#   phenotype_description &lt;chr&gt;, hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nThis will select all the variables in rna except tissue and organism.\nTo choose rows based on a specific criteria, use filter():\n\nfilter(rna, sex == \"Male\")\n\n# A tibble: 14,740 × 19\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…        626 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 2 Apod    GSM254…      13021 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 3 Cyp2d22 GSM254…       2171 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 4 Klk6    GSM254…        448 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 5 Fcrls   GSM254…        180 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 6 Slc2a4  GSM254…        313 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 7 Exd2    GSM254…       2366 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 8 Gjc2    GSM254…        310 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 9 Plp1    GSM254…      53126 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n10 Gnb4    GSM254…       1355 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n# ℹ 14,730 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\n\nfilter(rna, sex == \"Male\" & infection == \"NonInfected\")\n\n# A tibble: 4,422 × 19\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…        535 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 2 Apod    GSM254…      13668 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 3 Cyp2d22 GSM254…       2008 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 4 Klk6    GSM254…       1101 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 5 Fcrls   GSM254…        375 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 6 Slc2a4  GSM254…        249 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 7 Exd2    GSM254…       3126 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 8 Gjc2    GSM254…        791 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 9 Plp1    GSM254…      98658 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n10 Gnb4    GSM254…       2437 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n# ℹ 4,412 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nNow let’s imagine we are interested in the human homologs of the mouse genes analysed in this dataset. This information can be found in the last column of the rna tibble, named hsapiens_homolog_associated_gene_name. To visualise it easily, we will create a new table containing just the 2 columns gene and hsapiens_homolog_associated_gene_name.\n\ngenes &lt;- select(rna, gene, hsapiens_homolog_associated_gene_name)\ngenes\n\n# A tibble: 32,428 × 2\n   gene    hsapiens_homolog_associated_gene_name\n   &lt;chr&gt;   &lt;chr&gt;                                \n 1 Asl     ASL                                  \n 2 Apod    APOD                                 \n 3 Cyp2d22 CYP2D6                               \n 4 Klk6    KLK6                                 \n 5 Fcrls   FCRL2                                \n 6 Slc2a4  SLC2A4                               \n 7 Exd2    EXD2                                 \n 8 Gjc2    GJC2                                 \n 9 Plp1    PLP1                                 \n10 Gnb4    GNB4                                 \n# ℹ 32,418 more rows\n\n\nSome mouse genes have no human homologs. These can be retrieved using filter() and the is.na() function, that determines whether something is an NA.\n\nfilter(genes, is.na(hsapiens_homolog_associated_gene_name))\n\n# A tibble: 4,290 × 2\n   gene     hsapiens_homolog_associated_gene_name\n   &lt;chr&gt;    &lt;chr&gt;                                \n 1 Prodh    &lt;NA&gt;                                 \n 2 Tssk5    &lt;NA&gt;                                 \n 3 Vmn2r1   &lt;NA&gt;                                 \n 4 Gm10654  &lt;NA&gt;                                 \n 5 Hexa     &lt;NA&gt;                                 \n 6 Sult1a1  &lt;NA&gt;                                 \n 7 Gm6277   &lt;NA&gt;                                 \n 8 Tmem198b &lt;NA&gt;                                 \n 9 Adam1a   &lt;NA&gt;                                 \n10 Ebp      &lt;NA&gt;                                 \n# ℹ 4,280 more rows\n\n\nIf we want to keep only mouse genes that have a human homolog, we can insert a “!” symbol that negates the result, so we’re asking for every row where hsapiens_homolog_associated_gene_name is not an NA.\n\nfilter(genes, !is.na(hsapiens_homolog_associated_gene_name))\n\n# A tibble: 28,138 × 2\n   gene    hsapiens_homolog_associated_gene_name\n   &lt;chr&gt;   &lt;chr&gt;                                \n 1 Asl     ASL                                  \n 2 Apod    APOD                                 \n 3 Cyp2d22 CYP2D6                               \n 4 Klk6    KLK6                                 \n 5 Fcrls   FCRL2                                \n 6 Slc2a4  SLC2A4                               \n 7 Exd2    EXD2                                 \n 8 Gjc2    GJC2                                 \n 9 Plp1    PLP1                                 \n10 Gnb4    GNB4                                 \n# ℹ 28,128 more rows\n\n\n\n\n\nWhat if you want to select and filter at the same time? There are three ways to do this: use intermediate steps, nested functions, or pipes.\nWith intermediate steps, you create a temporary data frame and use that as input to the next function, like this:\n\nrna2 &lt;- filter(rna, sex == \"Male\")\nrna3 &lt;- select(rna2, gene, sample, tissue, expression)\nrna3\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\nThis is readable, but can clutter up your workspace with lots of intermediate objects that you have to name individually. With multiple steps, that can be hard to keep track of.\nYou can also nest functions (i.e. one function inside of another), like this:\n\nrna3 &lt;- select(filter(rna, sex == \"Male\"), gene, sample, tissue, expression)\nrna3\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\nThis is handy, but can be difficult to read if too many functions are nested, as R evaluates the expression from the inside out (in this case, filtering, then selecting).\nThe last option, pipes, are a recent addition to R. Pipes let you take the output of one function and send it directly to the next, which is useful when you need to do many things to the same dataset.\nPipes in R look like %&gt;% (made available via the magrittr package) or |&gt; (through base R). If you use RStudio, you can type the pipe with Ctrl + Shift + M if you have a PC or Cmd + Shift + M if you have a Mac.\nIn the above code, we use the pipe to send the rna dataset first through filter() to keep rows where sex is Male, then through select() to keep only the gene, sample, tissue, and expressioncolumns.\nThe pipe %&gt;% takes the object on its left and passes it directly as the first argument to the function on its right, we don’t need to explicitly include the data frame as an argument to the filter() and select() functions any more.\n\nrna %&gt;%\n  filter(sex == \"Male\") %&gt;%\n  select(gene, sample, tissue, expression)\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\nSome may find it helpful to read the pipe like the word “then”. For instance, in the above example, we took the data frame rna, then we filtered for rows with sex == \"Male\", then we selected columns gene, sample, tissue, and expression.\nThe dplyr functions by themselves are somewhat simple, but by combining them into linear workflows with the pipe, we can accomplish more complex manipulations of data frames.\nIf we want to create a new object with this smaller version of the data, we can assign it a new name:\n\nrna3 &lt;- rna %&gt;%\n  filter(sex == \"Male\") %&gt;%\n  select(gene, sample, tissue, expression)\n\nrna3\n\n# A tibble: 14,740 × 4\n   gene    sample     tissue     expression\n   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545340 Cerebellum        626\n 2 Apod    GSM2545340 Cerebellum      13021\n 3 Cyp2d22 GSM2545340 Cerebellum       2171\n 4 Klk6    GSM2545340 Cerebellum        448\n 5 Fcrls   GSM2545340 Cerebellum        180\n 6 Slc2a4  GSM2545340 Cerebellum        313\n 7 Exd2    GSM2545340 Cerebellum       2366\n 8 Gjc2    GSM2545340 Cerebellum        310\n 9 Plp1    GSM2545340 Cerebellum      53126\n10 Gnb4    GSM2545340 Cerebellum       1355\n# ℹ 14,730 more rows\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nUsing pipes, subset the rna data to keep observations in female mice at time 0, where the gene has an expression higher than 50000, and retain only the columns gene, sample, time, expression and age.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nrna %&gt;%\n  filter(expression &gt; 50000,\n         sex == \"Female\",\n         time == 0 ) %&gt;%\n  select(gene, sample, time, expression, age)\n\n# A tibble: 9 × 5\n  gene   sample      time expression   age\n  &lt;chr&gt;  &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n1 Plp1   GSM2545337     0     101241     8\n2 Atp1b1 GSM2545337     0      53260     8\n3 Plp1   GSM2545338     0      96534     8\n4 Atp1b1 GSM2545338     0      50614     8\n5 Plp1   GSM2545348     0     102790     8\n6 Atp1b1 GSM2545348     0      59544     8\n7 Plp1   GSM2545353     0      71237     8\n8 Glul   GSM2545353     0      52451     8\n9 Atp1b1 GSM2545353     0      61451     8\n\n\n\n\n\n\n\n\nFrequently you’ll want to create new columns based on the values of existing columns, for example to do unit conversions, or to find the ratio of values in two columns. For this we’ll use mutate().\nTo create a new column of time in hours:\n\nrna %&gt;%\n  mutate(time_hours = time * 24) %&gt;%\n  select(time, time_hours)\n\n# A tibble: 32,428 × 2\n    time time_hours\n   &lt;dbl&gt;      &lt;dbl&gt;\n 1     8        192\n 2     8        192\n 3     8        192\n 4     8        192\n 5     8        192\n 6     8        192\n 7     8        192\n 8     8        192\n 9     8        192\n10     8        192\n# ℹ 32,418 more rows\n\n\nYou can also create a second new column based on the first new column within the same call of mutate():\n\nrna %&gt;%\n  mutate(time_hours = time * 24,\n         time_mn = time_hours * 60) %&gt;%\n  select(time, time_hours, time_mn)\n\n# A tibble: 32,428 × 3\n    time time_hours time_mn\n   &lt;dbl&gt;      &lt;dbl&gt;   &lt;dbl&gt;\n 1     8        192   11520\n 2     8        192   11520\n 3     8        192   11520\n 4     8        192   11520\n 5     8        192   11520\n 6     8        192   11520\n 7     8        192   11520\n 8     8        192   11520\n 9     8        192   11520\n10     8        192   11520\n# ℹ 32,418 more rows\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nCreate a new data frame from the rna data that meets the following criteria: contains only the gene, chromosome_name, phenotype_description, sample, and expression columns. The expression values should be log-transformed. This data frame must only contain genes located on sex chromosomes, associated with a phenotype_description, and with a log expression higher than 5.\nHint: think about how the commands should be ordered to produce this data frame!\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nrna %&gt;%\n  mutate(expression = log(expression)) %&gt;%\n  select(gene, chromosome_name, phenotype_description, sample, expression) %&gt;%\n  filter(chromosome_name == \"X\" | chromosome_name == \"Y\") %&gt;%\n  filter(!is.na(phenotype_description)) %&gt;%\n  filter(expression &gt; 5)\n\n# A tibble: 649 × 5\n   gene   chromosome_name phenotype_description                sample expression\n   &lt;chr&gt;  &lt;chr&gt;           &lt;chr&gt;                                &lt;chr&gt;       &lt;dbl&gt;\n 1 Plp1   X               abnormal CNS glial cell morphology   GSM25…      10.7 \n 2 Slc7a3 X               decreased body length                GSM25…       5.46\n 3 Plxnb3 X               abnormal coat appearance             GSM25…       6.58\n 4 Rbm3   X               abnormal liver morphology            GSM25…       9.32\n 5 Cfp    X               abnormal cardiovascular system phys… GSM25…       6.18\n 6 Ebp    X               abnormal embryonic erythrocyte morp… GSM25…       6.68\n 7 Cd99l2 X               abnormal cellular extravasation      GSM25…       8.04\n 8 Piga   X               abnormal brain development           GSM25…       6.06\n 9 Pim2   X               decreased T cell proliferation       GSM25…       7.11\n10 Itm2a  X               no abnormal phenotype detected       GSM25…       7.48\n# ℹ 639 more rows\n\n\n\n\n\n\n\n\nMany data analysis tasks can be approached using the split-apply-combine paradigm: split the data into groups, apply some analysis to each group, and then combine the results. dplyr makes this very easy through the use of the group_by() function.\n\nrna %&gt;%\n  group_by(gene)\n\n# A tibble: 32,428 × 19\n# Groups:   gene [1,474]\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…       1170 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 Apod    GSM254…      36194 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 3 Cyp2d22 GSM254…       4060 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 4 Klk6    GSM254…        287 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 5 Fcrls   GSM254…         85 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 6 Slc2a4  GSM254…        782 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 7 Exd2    GSM254…       1619 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 Gjc2    GSM254…        288 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 9 Plp1    GSM254…      43217 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n10 Gnb4    GSM254…       1071 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nThe group_by() function doesn’t perform any data processing, it groups the data into subsets: in the example above, our initial tibble of 32428 observations is split into 1474 groups based on the gene variable.\nWe could similarly decide to group the tibble by the samples:\n\nrna %&gt;%\n  group_by(sample)\n\n# A tibble: 32,428 × 19\n# Groups:   sample [22]\n   gene    sample  expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 Asl     GSM254…       1170 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 Apod    GSM254…      36194 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 3 Cyp2d22 GSM254…       4060 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 4 Klk6    GSM254…        287 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 5 Fcrls   GSM254…         85 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 6 Slc2a4  GSM254…        782 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 7 Exd2    GSM254…       1619 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 Gjc2    GSM254…        288 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 9 Plp1    GSM254…      43217 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n10 Gnb4    GSM254…       1071 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nHere our initial tibble of 32428 observations is split into 22 groups based on the sample variable.\nOnce the data has been grouped, subsequent operations will be applied on each group independently.\n\n\n\ngroup_by() is often used together with summarise(), which collapses each group into a single-row summary of that group.\ngroup_by() takes as arguments the column names that contain the categorical variables for which you want to calculate the summary statistics. So to compute the mean expression by gene:\n\nrna %&gt;%\n  group_by(gene) %&gt;%\n  summarise(mean_expression = mean(expression))\n\n# A tibble: 1,474 × 2\n   gene     mean_expression\n   &lt;chr&gt;              &lt;dbl&gt;\n 1 AI504432         1053.  \n 2 AW046200          131.  \n 3 AW551984          295.  \n 4 Aamp             4751.  \n 5 Abca12              4.55\n 6 Abcc8            2498.  \n 7 Abhd14a           525.  \n 8 Abi2             4909.  \n 9 Abi3bp           1002.  \n10 Abl2             2124.  \n# ℹ 1,464 more rows\n\n\nWe could also want to calculate the mean expression levels of all genes in each sample:\n\nrna %&gt;%\n  group_by(sample) %&gt;%\n  summarise(mean_expression = mean(expression))\n\n# A tibble: 22 × 2\n   sample     mean_expression\n   &lt;chr&gt;                &lt;dbl&gt;\n 1 GSM2545336           2062.\n 2 GSM2545337           1766.\n 3 GSM2545338           1668.\n 4 GSM2545339           1696.\n 5 GSM2545340           1682.\n 6 GSM2545341           1638.\n 7 GSM2545342           1594.\n 8 GSM2545343           2107.\n 9 GSM2545344           1712.\n10 GSM2545345           1700.\n# ℹ 12 more rows\n\n\nBut we can can also group by multiple columns:\n\nrna %&gt;%\n  group_by(gene, infection, time) %&gt;%\n  summarise(mean_expression = mean(expression))\n\n`summarise()` has grouped output by 'gene', 'infection'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 4,422 × 4\n# Groups:   gene, infection [2,948]\n   gene     infection    time mean_expression\n   &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;           &lt;dbl&gt;\n 1 AI504432 InfluenzaA      4           1104.\n 2 AI504432 InfluenzaA      8           1014 \n 3 AI504432 NonInfected     0           1034.\n 4 AW046200 InfluenzaA      4            152.\n 5 AW046200 InfluenzaA      8             81 \n 6 AW046200 NonInfected     0            155.\n 7 AW551984 InfluenzaA      4            302.\n 8 AW551984 InfluenzaA      8            342.\n 9 AW551984 NonInfected     0            238 \n10 Aamp     InfluenzaA      4           4870 \n# ℹ 4,412 more rows\n\n\nOnce the data is grouped, you can also summarise multiple variables at the same time (and not necessarily on the same variable). For instance, we could add a column indicating the median expression by gene and by condition:\n\nrna %&gt;%\n  group_by(gene, infection, time) %&gt;%\n  summarise(mean_expression = mean(expression),\n            median_expression = median(expression))\n\n`summarise()` has grouped output by 'gene', 'infection'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 4,422 × 5\n# Groups:   gene, infection [2,948]\n   gene     infection    time mean_expression median_expression\n   &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;           &lt;dbl&gt;             &lt;dbl&gt;\n 1 AI504432 InfluenzaA      4           1104.             1094.\n 2 AI504432 InfluenzaA      8           1014               985 \n 3 AI504432 NonInfected     0           1034.             1016 \n 4 AW046200 InfluenzaA      4            152.              144.\n 5 AW046200 InfluenzaA      8             81                82 \n 6 AW046200 NonInfected     0            155.              163 \n 7 AW551984 InfluenzaA      4            302.              245 \n 8 AW551984 InfluenzaA      8            342.              287 \n 9 AW551984 NonInfected     0            238               265 \n10 Aamp     InfluenzaA      4           4870              4708 \n# ℹ 4,412 more rows\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nCalculate the mean expression level of gene “Dok3” by timepoints.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nrna %&gt;%\n  filter(gene == \"Dok3\") %&gt;%\n  group_by(time) %&gt;%\n  summarise(mean = mean(expression))\n\n# A tibble: 3 × 2\n   time  mean\n  &lt;dbl&gt; &lt;dbl&gt;\n1     0  169 \n2     4  156.\n3     8   61 \n\n\n\n\n\n\n\n\nWhen working with data, we often want to know the number of observations found for each factor or combination of factors. For this task, dplyr provides count(). For example, if we wanted to count the number of rows of data for each infected and non-infected samples, we would do:\n\nrna %&gt;%\n    count(infection)\n\n# A tibble: 2 × 2\n  infection       n\n  &lt;chr&gt;       &lt;int&gt;\n1 InfluenzaA  22110\n2 NonInfected 10318\n\n\nThe count() function is shorthand for something we’ve already seen: grouping by a variable, and summarising it by counting the number of observations in that group. In other words, rna %&gt;% count(infection) is equivalent to:\n\nrna %&gt;%\n    group_by(infection) %&gt;%\n    summarise(n = n())\n\n# A tibble: 2 × 2\n  infection       n\n  &lt;chr&gt;       &lt;int&gt;\n1 InfluenzaA  22110\n2 NonInfected 10318\n\n\nThe previous example shows the use of count() to count the number of rows/observations for one factor (i.e., infection). If we wanted to count a combination of factors, such as infection and time, we would specify the first and the second factor as the arguments of count():\n\nrna %&gt;%\n    count(infection, time)\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      4 11792\n2 InfluenzaA      8 10318\n3 NonInfected     0 10318\n\n\nwhich is equivalent to this:\n\nrna %&gt;%\n  group_by(infection, time) %&gt;%\n  summarise(n = n())\n\n`summarise()` has grouped output by 'infection'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 3 × 3\n# Groups:   infection [2]\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      4 11792\n2 InfluenzaA      8 10318\n3 NonInfected     0 10318\n\n\nIt is sometimes useful to sort the result to facilitate the comparisons. We can use arrange() to sort the table. For instance, we might want to arrange the table above by time:\n\nrna %&gt;%\n  count(infection, time) %&gt;%\n  arrange(time)\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 NonInfected     0 10318\n2 InfluenzaA      4 11792\n3 InfluenzaA      8 10318\n\n\nor by counts:\n\nrna %&gt;%\n  count(infection, time) %&gt;%\n  arrange(n)\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      8 10318\n2 NonInfected     0 10318\n3 InfluenzaA      4 11792\n\n\nTo sort in descending order, we need to add the desc() function:\n\nrna %&gt;%\n  count(infection, time) %&gt;%\n  arrange(desc(n))\n\n# A tibble: 3 × 3\n  infection    time     n\n  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;\n1 InfluenzaA      4 11792\n2 InfluenzaA      8 10318\n3 NonInfected     0 10318\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nHow many genes were analysed in each sample?\n\nUse group_by() and summarise() to evaluate the sequencing depth (the sum of all counts) in each sample. Which sample has the highest sequencing depth?\nPick one sample and evaluate the number of genes by biotype.\nIdentify genes associated with the “abnormal DNA methylation” phenotype description, and calculate their mean expression (in log) at time 0, time 4 and time 8.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nrna %&gt;%\n  count(sample)\n\n# A tibble: 22 × 2\n   sample         n\n   &lt;chr&gt;      &lt;int&gt;\n 1 GSM2545336  1474\n 2 GSM2545337  1474\n 3 GSM2545338  1474\n 4 GSM2545339  1474\n 5 GSM2545340  1474\n 6 GSM2545341  1474\n 7 GSM2545342  1474\n 8 GSM2545343  1474\n 9 GSM2545344  1474\n10 GSM2545345  1474\n# ℹ 12 more rows\n\n\n\n\n\n\n\n\nIn the rna tibble, the rows contain expression values (the unit) that are associated with a combination of 2 other variables: gene and sample.\nAll the other columns correspond to variables describing either the sample (organism, age, sex, …) or the gene (gene_biotype, ENTREZ_ID, product, …). The variables that don’t change with genes or with samples will have the same value in all the rows.\n\nrna %&gt;%\n  arrange(gene)\n\n# A tibble: 32,428 × 19\n   gene     sample expression organism   age sex   infection strain  time tissue\n   &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt; \n 1 AI504432 GSM25…       1230 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 2 AI504432 GSM25…       1085 Mus mus…     8 Fema… NonInfec… C57BL…     0 Cereb…\n 3 AI504432 GSM25…        969 Mus mus…     8 Fema… NonInfec… C57BL…     0 Cereb…\n 4 AI504432 GSM25…       1284 Mus mus…     8 Fema… Influenz… C57BL…     4 Cereb…\n 5 AI504432 GSM25…        966 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n 6 AI504432 GSM25…        918 Mus mus…     8 Male  Influenz… C57BL…     8 Cereb…\n 7 AI504432 GSM25…        985 Mus mus…     8 Fema… Influenz… C57BL…     8 Cereb…\n 8 AI504432 GSM25…        972 Mus mus…     8 Male  NonInfec… C57BL…     0 Cereb…\n 9 AI504432 GSM25…       1000 Mus mus…     8 Fema… Influenz… C57BL…     4 Cereb…\n10 AI504432 GSM25…        816 Mus mus…     8 Male  Influenz… C57BL…     4 Cereb…\n# ℹ 32,418 more rows\n# ℹ 9 more variables: mouse &lt;dbl&gt;, ENTREZID &lt;dbl&gt;, product &lt;chr&gt;,\n#   ensembl_gene_id &lt;chr&gt;, external_synonym &lt;chr&gt;, chromosome_name &lt;chr&gt;,\n#   gene_biotype &lt;chr&gt;, phenotype_description &lt;chr&gt;,\n#   hsapiens_homolog_associated_gene_name &lt;chr&gt;\n\n\nThis structure is called a long-format, as one column contains all the values, and other column(s) list(s) the context of the value.\nIn certain cases, the long-format is not really “human-readable”, and another format, a wide-format is preferred, as a more compact way of representing the data. This is typically the case with gene expression values that scientists are used to look as matrices, were rows represent genes and columns represent samples.\nIn this format, it would therefore become straightforward to explore the relationship between the gene expression levels within, and between, the samples.\nTo convert the gene expression values from rna into a wide-format, we need to create a new table where the values of the sample column would become the names of column variables.\nThe key point here is that we are still following a tidy data structure, but we have reshaped the data according to the observations of interest: expression levels per gene instead of recording them per gene and per sample.\nThe opposite transformation would be to transform column names into values of a new variable.\nWe can do both these of transformations with two tidyr functions, pivot_longer() and pivot_wider() (see here for details).\n\n\n\nLet’s select the first 3 columns of rna and use pivot_wider() to transform the data into a wide-format.\n\nrna_exp &lt;- rna %&gt;%\n  select(gene, sample, expression)\nrna_exp\n\n# A tibble: 32,428 × 3\n   gene    sample     expression\n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545336       1170\n 2 Apod    GSM2545336      36194\n 3 Cyp2d22 GSM2545336       4060\n 4 Klk6    GSM2545336        287\n 5 Fcrls   GSM2545336         85\n 6 Slc2a4  GSM2545336        782\n 7 Exd2    GSM2545336       1619\n 8 Gjc2    GSM2545336        288\n 9 Plp1    GSM2545336      43217\n10 Gnb4    GSM2545336       1071\n# ℹ 32,418 more rows\n\n\n\n\n\n\n\n\nNote\n\n\n\npivot_wider takes three main arguments:\n\nthe data to be transformed;\nthe names_from : the column whose values will become new column names;\nthe values_from: the column whose values will fill the new columns.\n\n\n\n\n\nrna_wide &lt;- rna_exp %&gt;%\n  pivot_wider(names_from = sample,\n              values_from = expression)\nrna_wide\n\n# A tibble: 1,474 × 23\n   gene    GSM2545336 GSM2545337 GSM2545338 GSM2545339 GSM2545340 GSM2545341\n   &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n 1 Asl           1170        361        400        586        626        988\n 2 Apod         36194      10347       9173      10620      13021      29594\n 3 Cyp2d22       4060       1616       1603       1901       2171       3349\n 4 Klk6           287        629        641        578        448        195\n 5 Fcrls           85        233        244        237        180         38\n 6 Slc2a4         782        231        248        265        313        786\n 7 Exd2          1619       2288       2235       2513       2366       1359\n 8 Gjc2           288        595        568        551        310        146\n 9 Plp1         43217     101241      96534      58354      53126      27173\n10 Gnb4          1071       1791       1867       1430       1355        798\n# ℹ 1,464 more rows\n# ℹ 16 more variables: GSM2545342 &lt;dbl&gt;, GSM2545343 &lt;dbl&gt;, GSM2545344 &lt;dbl&gt;,\n#   GSM2545345 &lt;dbl&gt;, GSM2545346 &lt;dbl&gt;, GSM2545347 &lt;dbl&gt;, GSM2545348 &lt;dbl&gt;,\n#   GSM2545349 &lt;dbl&gt;, GSM2545350 &lt;dbl&gt;, GSM2545351 &lt;dbl&gt;, GSM2545352 &lt;dbl&gt;,\n#   GSM2545353 &lt;dbl&gt;, GSM2545354 &lt;dbl&gt;, GSM2545362 &lt;dbl&gt;, GSM2545363 &lt;dbl&gt;,\n#   GSM2545380 &lt;dbl&gt;\n\n\nNote that by default, the pivot_wider() function will add NA for missing values.\nLet’s imagine that for some reason, we had some missing expression values for some genes in certain samples. In the following fictive example, the gene Cyp2d22 has only one expression value, in GSM2545338 sample.\n\nrna_with_missing_values &lt;- rna %&gt;%\n  select(gene, sample, expression) %&gt;%\n  filter(gene %in% c(\"Asl\", \"Apod\", \"Cyp2d22\")) %&gt;%\n  filter(sample %in% c(\"GSM2545336\", \"GSM2545337\", \"GSM2545338\")) %&gt;%\n  arrange(sample) %&gt;%\n  filter(!(gene == \"Cyp2d22\" & sample != \"GSM2545338\"))\nrna_with_missing_values\n\n# A tibble: 7 × 3\n  gene    sample     expression\n  &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n1 Asl     GSM2545336       1170\n2 Apod    GSM2545336      36194\n3 Asl     GSM2545337        361\n4 Apod    GSM2545337      10347\n5 Asl     GSM2545338        400\n6 Apod    GSM2545338       9173\n7 Cyp2d22 GSM2545338       1603\n\n\nBy default, the pivot_wider() function will add NA for missing values. This can be parameterised with the values_fill argument of the pivot_wider() function.\n\nrna_with_missing_values %&gt;%\n  pivot_wider(names_from = sample,values_from = expression)\n\n# A tibble: 3 × 4\n  gene    GSM2545336 GSM2545337 GSM2545338\n  &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 Asl           1170        361        400\n2 Apod         36194      10347       9173\n3 Cyp2d22         NA         NA       1603\n\n\n\nrna_with_missing_values %&gt;%\n  pivot_wider(names_from = sample,values_from = expression,values_fill = 0)\n\n# A tibble: 3 × 4\n  gene    GSM2545336 GSM2545337 GSM2545338\n  &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 Asl           1170        361        400\n2 Apod         36194      10347       9173\n3 Cyp2d22          0          0       1603\n\n\n\n\n\nIn the opposite situation we are using the column names and turning them into a pair of new variables. One variable represents the column names as values, and the other variable contains the values previously associated with the column names.\n\n\n\n\n\n\nNote\n\n\n\npivot_longer() takes four main arguments:\n\nthe data to be transformed;\nthe names_to: the new column name we wish to create and populate with the current column names;\nthe values_to: the new column name we wish to create and populate with current values;\nthe names of the columns to be used to populate the names_to and values_to variables (or to drop).\n\n\n\n\nTo recreate rna_long from rna_wide we would create a key called sample and value called expression and use all columns except gene for the key variable. Here we drop gene column with a minus sign.\n\n\n\n\n\n\nImportant\n\n\n\nNotice how the new variable names are to be quoted here.\n\n\n\nrna_long &lt;- rna_wide %&gt;%\n    pivot_longer(names_to = \"sample\",values_to = \"expression\",-gene)\nrna_long\n\n# A tibble: 32,428 × 3\n   gene  sample     expression\n   &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl   GSM2545336       1170\n 2 Asl   GSM2545337        361\n 3 Asl   GSM2545338        400\n 4 Asl   GSM2545339        586\n 5 Asl   GSM2545340        626\n 6 Asl   GSM2545341        988\n 7 Asl   GSM2545342        836\n 8 Asl   GSM2545343        535\n 9 Asl   GSM2545344        586\n10 Asl   GSM2545345        597\n# ℹ 32,418 more rows\n\n\nWe could also have used a specification for what columns to include. This can be useful if you have a large number of identifying columns, and it’s easier to specify what to gather than what to leave alone. Here the starts_with() function can help to retrieve sample names without having to list them all! Another possibility would be to use the : operator!\n\nrna_wide %&gt;%\n    pivot_longer(names_to = \"sample\",values_to = \"expression\",\ncols = starts_with(\"GSM\"))\n\n# A tibble: 32,428 × 3\n   gene  sample     expression\n   &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl   GSM2545336       1170\n 2 Asl   GSM2545337        361\n 3 Asl   GSM2545338        400\n 4 Asl   GSM2545339        586\n 5 Asl   GSM2545340        626\n 6 Asl   GSM2545341        988\n 7 Asl   GSM2545342        836\n 8 Asl   GSM2545343        535\n 9 Asl   GSM2545344        586\n10 Asl   GSM2545345        597\n# ℹ 32,418 more rows\n\n\n\nrna_wide %&gt;%\n    pivot_longer(names_to = \"sample\",values_to = \"expression\",\nGSM2545336:GSM2545380)\n\n# A tibble: 32,428 × 3\n   gene  sample     expression\n   &lt;chr&gt; &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl   GSM2545336       1170\n 2 Asl   GSM2545337        361\n 3 Asl   GSM2545338        400\n 4 Asl   GSM2545339        586\n 5 Asl   GSM2545340        626\n 6 Asl   GSM2545341        988\n 7 Asl   GSM2545342        836\n 8 Asl   GSM2545343        535\n 9 Asl   GSM2545344        586\n10 Asl   GSM2545345        597\n# ℹ 32,418 more rows\n\n\nNote that if we had missing values in the wide-format, the NA would be included in the new long format.\nRemember our previous fictive tibble containing missing values:\n\nrna_with_missing_values\n\n# A tibble: 7 × 3\n  gene    sample     expression\n  &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n1 Asl     GSM2545336       1170\n2 Apod    GSM2545336      36194\n3 Asl     GSM2545337        361\n4 Apod    GSM2545337      10347\n5 Asl     GSM2545338        400\n6 Apod    GSM2545338       9173\n7 Cyp2d22 GSM2545338       1603\n\n\n\nwide_with_NA &lt;- rna_with_missing_values %&gt;%\n  pivot_wider(names_from = sample,\nvalues_from = expression)\nwide_with_NA\n\n# A tibble: 3 × 4\n  gene    GSM2545336 GSM2545337 GSM2545338\n  &lt;chr&gt;        &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 Asl           1170        361        400\n2 Apod         36194      10347       9173\n3 Cyp2d22         NA         NA       1603\n\n\n\nwide_with_NA %&gt;%\npivot_longer(names_to = \"sample\",\nvalues_to = \"expression\",\n-gene)\n\n# A tibble: 9 × 3\n  gene    sample     expression\n  &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n1 Asl     GSM2545336       1170\n2 Asl     GSM2545337        361\n3 Asl     GSM2545338        400\n4 Apod    GSM2545336      36194\n5 Apod    GSM2545337      10347\n6 Apod    GSM2545338       9173\n7 Cyp2d22 GSM2545336         NA\n8 Cyp2d22 GSM2545337         NA\n9 Cyp2d22 GSM2545338       1603\n\n\nPivoting to wider and longer formats can be a useful way to balance out a dataset so every replicate has the same composition.\n\n\n\n\n\n\nQuestion\n\n\n\nStarting from the rna table, use the pivot_wider() function to create a wide-format table giving the gene expression levels in each mouse. Then use the pivot_longer() function to restore a long-format table.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nFrom long to wide :\n\nrna1 &lt;- rna %&gt;%\nselect(gene, mouse, expression) %&gt;%\npivot_wider(names_from = mouse, values_from = expression)\nrna1\n\n# A tibble: 1,474 × 23\n   gene     `14`    `9`  `10`  `15`  `18`   `6`   `5`  `11`  `22`  `13`  `23`\n   &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 Asl      1170    361   400   586   626   988   836   535   586   597   938\n 2 Apod    36194  10347  9173 10620 13021 29594 24959 13668 13230 15868 27769\n 3 Cyp2d22  4060   1616  1603  1901  2171  3349  3122  2008  2254  2277  2985\n 4 Klk6      287    629   641   578   448   195   186  1101   537   567   327\n 5 Fcrls      85    233   244   237   180    38    68   375   199   177    89\n 6 Slc2a4    782    231   248   265   313   786   528   249   266   357   654\n 7 Exd2     1619   2288  2235  2513  2366  1359  1474  3126  2379  2173  1531\n 8 Gjc2      288    595   568   551   310   146   186   791   454   370   240\n 9 Plp1    43217 101241 96534 58354 53126 27173 28728 98658 61356 61647 38019\n10 Gnb4     1071   1791  1867  1430  1355   798   806  2437  1394  1554   960\n# ℹ 1,464 more rows\n# ℹ 11 more variables: `24` &lt;dbl&gt;, `8` &lt;dbl&gt;, `7` &lt;dbl&gt;, `1` &lt;dbl&gt;, `16` &lt;dbl&gt;,\n#   `21` &lt;dbl&gt;, `4` &lt;dbl&gt;, `2` &lt;dbl&gt;, `20` &lt;dbl&gt;, `12` &lt;dbl&gt;, `19` &lt;dbl&gt;\n\n\nFrom wide to long :\n\nrna1 %&gt;%\npivot_longer(names_to = \"mouse_id\", values_to = \"counts\", -gene)\n\n# A tibble: 32,428 × 3\n   gene  mouse_id counts\n   &lt;chr&gt; &lt;chr&gt;     &lt;dbl&gt;\n 1 Asl   14         1170\n 2 Asl   9           361\n 3 Asl   10          400\n 4 Asl   15          586\n 5 Asl   18          626\n 6 Asl   6           988\n 7 Asl   5           836\n 8 Asl   11          535\n 9 Asl   22          586\n10 Asl   13          597\n# ℹ 32,418 more rows\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nSubset genes located on X and Y chromosomes from the rna data frame and spread the data frame with sex as columns, chromosome_name as rows, and the mean expression of genes located in each chromosome as the values, as in the following tibble:\n\nYou will need to summarise before reshaping!\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nLet’s first calculate the mean expression level of X and Y linked genes from male and female samples…\n\nrna %&gt;%\n  filter(chromosome_name == \"Y\" | chromosome_name == \"X\") %&gt;%\n  group_by(sex, chromosome_name) %&gt;%\n  summarise(mean = mean(expression))\n\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\n\n\n# A tibble: 4 × 3\n# Groups:   sex [2]\n  sex    chromosome_name  mean\n  &lt;chr&gt;  &lt;chr&gt;           &lt;dbl&gt;\n1 Female X               3504.\n2 Female Y                  3 \n3 Male   X               2497.\n4 Male   Y               2117.\n\n\nAnd pivot the table to wide format\n\nrna_1 &lt;- rna %&gt;%\n  filter(chromosome_name == \"Y\" | chromosome_name == \"X\") %&gt;%\n  group_by(sex, chromosome_name) %&gt;%\n  summarise(mean = mean(expression)) %&gt;%\n  pivot_wider(names_from = sex,\n              values_from = mean)\n\n`summarise()` has grouped output by 'sex'. You can override using the `.groups`\nargument.\n\nrna_1\n\n# A tibble: 2 × 3\n  chromosome_name Female  Male\n  &lt;chr&gt;            &lt;dbl&gt; &lt;dbl&gt;\n1 X                3504. 2497.\n2 Y                   3  2117.\n\n\nNow take that data frame and transform it with pivot_longer() so each row is a unique chromosome_name by gender combination.\n\nrna_1 %&gt;%\n  pivot_longer(names_to = \"gender\",\n               values_to = \"mean\",\n               -chromosome_name)\n\n# A tibble: 4 × 3\n  chromosome_name gender  mean\n  &lt;chr&gt;           &lt;chr&gt;  &lt;dbl&gt;\n1 X               Female 3504.\n2 X               Male   2497.\n3 Y               Female    3 \n4 Y               Male   2117.\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nUse the rna dataset to create an expression matrix where each row represents the mean expression levels of genes and columns represent the different timepoints.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nLet’s first calculate the mean expression by gene and by timebefore using the pivot_wider() function\n\nrna %&gt;%\n  group_by(gene, time) %&gt;%\n  summarise(mean_exp = mean(expression))\n\n`summarise()` has grouped output by 'gene'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 4,422 × 3\n# Groups:   gene [1,474]\n   gene      time mean_exp\n   &lt;chr&gt;    &lt;dbl&gt;    &lt;dbl&gt;\n 1 AI504432     0    1034.\n 2 AI504432     4    1104.\n 3 AI504432     8    1014 \n 4 AW046200     0     155.\n 5 AW046200     4     152.\n 6 AW046200     8      81 \n 7 AW551984     0     238 \n 8 AW551984     4     302.\n 9 AW551984     8     342.\n10 Aamp         0    4603.\n# ℹ 4,412 more rows\n\n\nThen we use the pivot_wider() function\n\nrna_time &lt;- rna %&gt;%\n  group_by(gene, time) %&gt;%\n  summarise(mean_exp = mean(expression)) %&gt;%\n  pivot_wider(names_from = time,\n              values_from = mean_exp)\n\n`summarise()` has grouped output by 'gene'. You can override using the\n`.groups` argument.\n\nrna_time\n\n# A tibble: 1,474 × 4\n# Groups:   gene [1,474]\n   gene         `0`     `4`     `8`\n   &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1 AI504432 1034.   1104.   1014   \n 2 AW046200  155.    152.     81   \n 3 AW551984  238     302.    342.  \n 4 Aamp     4603.   4870    4763.  \n 5 Abca12      5.29    4.25    4.14\n 6 Abcc8    2576.   2609.   2292.  \n 7 Abhd14a   591.    547.    432.  \n 8 Abi2     4881.   4903.   4945.  \n 9 Abi3bp   1175.   1061.    762.  \n10 Abl2     2170.   2078.   2131.  \n# ℹ 1,464 more rows\n\n\nNotice that this generates a tibble with some column names starting by a number. If we wanted to select the column corresponding to the timepoints, we could not use the column names directly… What happens when we select the column 4?\n\nrna %&gt;%\n  group_by(gene, time) %&gt;%\n  summarise(mean_exp = mean(expression)) %&gt;%\n  pivot_wider(names_from = time,\n              values_from = mean_exp) %&gt;%\n  select(gene, 4)\n\n`summarise()` has grouped output by 'gene'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1,474 × 2\n# Groups:   gene [1,474]\n   gene         `8`\n   &lt;chr&gt;      &lt;dbl&gt;\n 1 AI504432 1014   \n 2 AW046200   81   \n 3 AW551984  342.  \n 4 Aamp     4763.  \n 5 Abca12      4.14\n 6 Abcc8    2292.  \n 7 Abhd14a   432.  \n 8 Abi2     4945.  \n 9 Abi3bp    762.  \n10 Abl2     2131.  \n# ℹ 1,464 more rows\n\n\nTo select the timepoint 4, we would have to quote the column name, with backticks “`”\n\nrna %&gt;%\n  group_by(gene, time) %&gt;%\n  summarise(mean_exp = mean(expression)) %&gt;%\n  pivot_wider(names_from = time,\n              values_from = mean_exp) %&gt;%\n  select(gene, `4`)\n\n`summarise()` has grouped output by 'gene'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1,474 × 2\n# Groups:   gene [1,474]\n   gene         `4`\n   &lt;chr&gt;      &lt;dbl&gt;\n 1 AI504432 1104.  \n 2 AW046200  152.  \n 3 AW551984  302.  \n 4 Aamp     4870   \n 5 Abca12      4.25\n 6 Abcc8    2609.  \n 7 Abhd14a   547.  \n 8 Abi2     4903.  \n 9 Abi3bp   1061.  \n10 Abl2     2078.  \n# ℹ 1,464 more rows\n\n\nAnother possibility would be to rename the column, choosing a name that doesn’t start by a number :\n\nrna %&gt;%\n  group_by(gene, time) %&gt;%\n  summarise(mean_exp = mean(expression)) %&gt;%\n  pivot_wider(names_from = time,\n              values_from = mean_exp) %&gt;%\n  rename(\"time0\" = `0`, \"time4\" = `4`, \"time8\" = `8`) %&gt;%\n  select(gene, time4)\n\n`summarise()` has grouped output by 'gene'. You can override using the\n`.groups` argument.\n\n\n# A tibble: 1,474 × 2\n# Groups:   gene [1,474]\n   gene       time4\n   &lt;chr&gt;      &lt;dbl&gt;\n 1 AI504432 1104.  \n 2 AW046200  152.  \n 3 AW551984  302.  \n 4 Aamp     4870   \n 5 Abca12      4.25\n 6 Abcc8    2609.  \n 7 Abhd14a   547.  \n 8 Abi2     4903.  \n 9 Abi3bp   1061.  \n10 Abl2     2078.  \n# ℹ 1,464 more rows\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nUse the previous data frame containing mean expression levels per timepoint and create a new column containing fold-changes between timepoint 8 and timepoint 0, and fold-changes between timepoint 8 and timepoint 4. Convert this table into a long-format table gathering the fold-changes calculated.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nStarting from the rna_time tibble:\n\nrna_time\n\n# A tibble: 1,474 × 4\n# Groups:   gene [1,474]\n   gene         `0`     `4`     `8`\n   &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1 AI504432 1034.   1104.   1014   \n 2 AW046200  155.    152.     81   \n 3 AW551984  238     302.    342.  \n 4 Aamp     4603.   4870    4763.  \n 5 Abca12      5.29    4.25    4.14\n 6 Abcc8    2576.   2609.   2292.  \n 7 Abhd14a   591.    547.    432.  \n 8 Abi2     4881.   4903.   4945.  \n 9 Abi3bp   1175.   1061.    762.  \n10 Abl2     2170.   2078.   2131.  \n# ℹ 1,464 more rows\n\n\nCalculate fold-changes:\n\nrna_time %&gt;%\n  mutate(time_8_vs_0 = `8` / `0`, time_8_vs_4 = `8` / `4`)\n\n# A tibble: 1,474 × 6\n# Groups:   gene [1,474]\n   gene         `0`     `4`     `8` time_8_vs_0 time_8_vs_4\n   &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;\n 1 AI504432 1034.   1104.   1014          0.981       0.918\n 2 AW046200  155.    152.     81          0.522       0.532\n 3 AW551984  238     302.    342.         1.44        1.13 \n 4 Aamp     4603.   4870    4763.         1.03        0.978\n 5 Abca12      5.29    4.25    4.14       0.784       0.975\n 6 Abcc8    2576.   2609.   2292.         0.889       0.878\n 7 Abhd14a   591.    547.    432.         0.731       0.791\n 8 Abi2     4881.   4903.   4945.         1.01        1.01 \n 9 Abi3bp   1175.   1061.    762.         0.649       0.719\n10 Abl2     2170.   2078.   2131.         0.982       1.03 \n# ℹ 1,464 more rows\n\n\nAnd use the pivot_longer() function:\n\nrna_time %&gt;%\n  mutate(time_8_vs_0 = `8` / `0`, time_8_vs_4 = `8` / `4`) %&gt;%\n  pivot_longer(names_to = \"comparisons\",\n               values_to = \"Fold_changes\",\n               time_8_vs_0:time_8_vs_4)\n\n# A tibble: 2,948 × 6\n# Groups:   gene [1,474]\n   gene         `0`     `4`     `8` comparisons Fold_changes\n   &lt;chr&gt;      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;              &lt;dbl&gt;\n 1 AI504432 1034.   1104.   1014    time_8_vs_0        0.981\n 2 AI504432 1034.   1104.   1014    time_8_vs_4        0.918\n 3 AW046200  155.    152.     81    time_8_vs_0        0.522\n 4 AW046200  155.    152.     81    time_8_vs_4        0.532\n 5 AW551984  238     302.    342.   time_8_vs_0        1.44 \n 6 AW551984  238     302.    342.   time_8_vs_4        1.13 \n 7 Aamp     4603.   4870    4763.   time_8_vs_0        1.03 \n 8 Aamp     4603.   4870    4763.   time_8_vs_4        0.978\n 9 Abca12      5.29    4.25    4.14 time_8_vs_0        0.784\n10 Abca12      5.29    4.25    4.14 time_8_vs_4        0.975\n# ℹ 2,938 more rows\n\n\n\n\n\n\n\n\nIn many real life situations, data are spread across multiple tables. Usually this occurs because different types of information are collected from different sources.\nIt may be desirable for some analyses to combine data from two or more tables into a single data frame based on a column that would be common to all the tables.\nThe dplyr package provides a set of join functions for combining two data frames based on matches within specified columns. Here, we provide a short introduction to joins. For further reading, please refer to the chapter about table joins. The Data Transformation Cheat Sheet also provides a short overview on table joins.\nWe are going to illustrate join using a small table, rna_mini that we will create by subsetting the original rna table, keeping only 3 columns and 10 lines.\n\nrna_mini &lt;- rna %&gt;%\n   select(gene, sample, expression) %&gt;%\n   head(10)\nrna_mini\n\n# A tibble: 10 × 3\n   gene    sample     expression\n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;\n 1 Asl     GSM2545336       1170\n 2 Apod    GSM2545336      36194\n 3 Cyp2d22 GSM2545336       4060\n 4 Klk6    GSM2545336        287\n 5 Fcrls   GSM2545336         85\n 6 Slc2a4  GSM2545336        782\n 7 Exd2    GSM2545336       1619\n 8 Gjc2    GSM2545336        288\n 9 Plp1    GSM2545336      43217\n10 Gnb4    GSM2545336       1071\n\n\nThe second table, annot1, contains 2 columns, gene and gene_description. You can either download annot1.csv by clicking on the link and then moving it to the data/ folder, or you can use the R code below to download it directly to the folder.\n\ndownload.file(url = \"https://carpentries-incubator.github.io/bioc-intro/data/annot1.csv\",\n              destfile = \"data/annot1.csv\")\nannot1 &lt;- read_csv(file = \"data/annot1.csv\")\n\nRows: 10 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): gene, gene_description\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nannot1\n\n# A tibble: 10 × 2\n   gene    gene_description                                                     \n   &lt;chr&gt;   &lt;chr&gt;                                                                \n 1 Cyp2d22 cytochrome P450, family 2, subfamily d, polypeptide 22 [Source:MGI S…\n 2 Klk6    kallikrein related-peptidase 6 [Source:MGI Symbol;Acc:MGI:1343166]   \n 3 Fcrls   Fc receptor-like S, scavenger receptor [Source:MGI Symbol;Acc:MGI:19…\n 4 Plp1    proteolipid protein (myelin) 1 [Source:MGI Symbol;Acc:MGI:97623]     \n 5 Exd2    exonuclease 3'-5' domain containing 2 [Source:MGI Symbol;Acc:MGI:192…\n 6 Apod    apolipoprotein D [Source:MGI Symbol;Acc:MGI:88056]                   \n 7 Gnb4    guanine nucleotide binding protein (G protein), beta 4 [Source:MGI S…\n 8 Slc2a4  solute carrier family 2 (facilitated glucose transporter), member 4 …\n 9 Asl     argininosuccinate lyase [Source:MGI Symbol;Acc:MGI:88084]            \n10 Gjc2    gap junction protein, gamma 2 [Source:MGI Symbol;Acc:MGI:2153060]    \n\n\nWe now want to join these two tables into a single one containing all variables using the full_join() function from the dplyr package. The function will automatically find the common variable to match columns from the first and second table. In this case, gene is the common variable. Such variables are called keys. Keys are used to match observations across different tables.\n\nfull_join(rna_mini, annot1)\n\nJoining with `by = join_by(gene)`\n\n\n# A tibble: 10 × 4\n   gene    sample     expression gene_description                               \n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;                                          \n 1 Asl     GSM2545336       1170 argininosuccinate lyase [Source:MGI Symbol;Acc…\n 2 Apod    GSM2545336      36194 apolipoprotein D [Source:MGI Symbol;Acc:MGI:88…\n 3 Cyp2d22 GSM2545336       4060 cytochrome P450, family 2, subfamily d, polype…\n 4 Klk6    GSM2545336        287 kallikrein related-peptidase 6 [Source:MGI Sym…\n 5 Fcrls   GSM2545336         85 Fc receptor-like S, scavenger receptor [Source…\n 6 Slc2a4  GSM2545336        782 solute carrier family 2 (facilitated glucose t…\n 7 Exd2    GSM2545336       1619 exonuclease 3'-5' domain containing 2 [Source:…\n 8 Gjc2    GSM2545336        288 gap junction protein, gamma 2 [Source:MGI Symb…\n 9 Plp1    GSM2545336      43217 proteolipid protein (myelin) 1 [Source:MGI Sym…\n10 Gnb4    GSM2545336       1071 guanine nucleotide binding protein (G protein)…\n\n\nIn real life, gene annotations are sometimes labelled differently.\nThe annot2 table is exactly the same than annot1 except that the variable containing gene names is labelled differently. Again, either download annot2.csv yourself and move it to data/ or use the R code below.\n\ndownload.file(url = \"https://carpentries-incubator.github.io/bioc-intro/data/annot2.csv\",\n              destfile = \"data/annot2.csv\")\nannot2 &lt;- read_csv(file = \"data/annot2.csv\")\n\nRows: 10 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): external_gene_name, description\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nannot2\n\n# A tibble: 10 × 2\n   external_gene_name description                                               \n   &lt;chr&gt;              &lt;chr&gt;                                                     \n 1 Cyp2d22            cytochrome P450, family 2, subfamily d, polypeptide 22 [S…\n 2 Klk6               kallikrein related-peptidase 6 [Source:MGI Symbol;Acc:MGI…\n 3 Fcrls              Fc receptor-like S, scavenger receptor [Source:MGI Symbol…\n 4 Plp1               proteolipid protein (myelin) 1 [Source:MGI Symbol;Acc:MGI…\n 5 Exd2               exonuclease 3'-5' domain containing 2 [Source:MGI Symbol;…\n 6 Apod               apolipoprotein D [Source:MGI Symbol;Acc:MGI:88056]        \n 7 Gnb4               guanine nucleotide binding protein (G protein), beta 4 [S…\n 8 Slc2a4             solute carrier family 2 (facilitated glucose transporter)…\n 9 Asl                argininosuccinate lyase [Source:MGI Symbol;Acc:MGI:88084] \n10 Gjc2               gap junction protein, gamma 2 [Source:MGI Symbol;Acc:MGI:…\n\n\nIn case none of the variable names match, we can set manually the variables to use for the matching. These variables can be set using the by argument, as shown below with rna_mini and annot2 tables.\n\nfull_join(rna_mini, annot2, by = c(\"gene\" = \"external_gene_name\"))\n\n# A tibble: 10 × 4\n   gene    sample     expression description                                    \n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;                                          \n 1 Asl     GSM2545336       1170 argininosuccinate lyase [Source:MGI Symbol;Acc…\n 2 Apod    GSM2545336      36194 apolipoprotein D [Source:MGI Symbol;Acc:MGI:88…\n 3 Cyp2d22 GSM2545336       4060 cytochrome P450, family 2, subfamily d, polype…\n 4 Klk6    GSM2545336        287 kallikrein related-peptidase 6 [Source:MGI Sym…\n 5 Fcrls   GSM2545336         85 Fc receptor-like S, scavenger receptor [Source…\n 6 Slc2a4  GSM2545336        782 solute carrier family 2 (facilitated glucose t…\n 7 Exd2    GSM2545336       1619 exonuclease 3'-5' domain containing 2 [Source:…\n 8 Gjc2    GSM2545336        288 gap junction protein, gamma 2 [Source:MGI Symb…\n 9 Plp1    GSM2545336      43217 proteolipid protein (myelin) 1 [Source:MGI Sym…\n10 Gnb4    GSM2545336       1071 guanine nucleotide binding protein (G protein)…\n\n\nAs can be seen above, the variable name of the first table is retained in the joined one.\n\n\n\n\n\n\nQuestion\n\n\n\nDownload the annot3 table by clicking here and put the table in your data/ repository. Using the full_join() function, join tables rna_mini and annot3. What has happened for genes Klk6, mt-Tf, mt-Rnr1, mt-Tv, mt-Rnr2, and mt-Tl1 ?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ndownload.file(url = \"https://carpentries-incubator.github.io/bioc-intro/data/annot3.csv\",destfile = \"data/annot3.csv\")\nannot3 &lt;- read_csv(\"data/annot3.csv\")\n\nRows: 14 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): gene, gene_description\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nfull_join(rna_mini, annot3)\n\nJoining with `by = join_by(gene)`\n\n\n# A tibble: 15 × 4\n   gene    sample     expression gene_description                               \n   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;                                          \n 1 Asl     GSM2545336       1170 argininosuccinate lyase [Source:MGI Symbol;Acc…\n 2 Apod    GSM2545336      36194 apolipoprotein D [Source:MGI Symbol;Acc:MGI:88…\n 3 Cyp2d22 GSM2545336       4060 cytochrome P450, family 2, subfamily d, polype…\n 4 Klk6    GSM2545336        287 &lt;NA&gt;                                           \n 5 Fcrls   GSM2545336         85 Fc receptor-like S, scavenger receptor [Source…\n 6 Slc2a4  GSM2545336        782 solute carrier family 2 (facilitated glucose t…\n 7 Exd2    GSM2545336       1619 exonuclease 3'-5' domain containing 2 [Source:…\n 8 Gjc2    GSM2545336        288 gap junction protein, gamma 2 [Source:MGI Symb…\n 9 Plp1    GSM2545336      43217 proteolipid protein (myelin) 1 [Source:MGI Sym…\n10 Gnb4    GSM2545336       1071 guanine nucleotide binding protein (G protein)…\n11 mt-Tf   &lt;NA&gt;               NA mitochondrially encoded tRNA phenylalanine [So…\n12 mt-Rnr1 &lt;NA&gt;               NA mitochondrially encoded 12S rRNA [Source:MGI S…\n13 mt-Tv   &lt;NA&gt;               NA mitochondrially encoded tRNA valine [Source:MG…\n14 mt-Rnr2 &lt;NA&gt;               NA mitochondrially encoded 16S rRNA [Source:MGI S…\n15 mt-Tl1  &lt;NA&gt;               NA mitochondrially encoded tRNA leucine 1 [Source…\n\n\nGenes Klk6 is only present in rna_mini, while genes mt-Tf, mt-Rnr1, mt-Tv, mt-Rnr2, and mt-Tl1 are only present in annot3 table. Their respective values for the variables of the table have been encoded as missing.\n\n\n\n\n\n\nNow that you have learned how to use dplyr to extract information from or summarise your raw data, you may want to export these new data sets to share them with your collaborators or for archival.\nSimilar to the read_csv() function used for reading CSV files into R, there is a write_csv() function that generates CSV files from data frames.\nBefore using write_csv(), we are going to create a new folder, data_output, in our working directory that will store this generated dataset. We don’t want to write generated datasets in the same directory as our raw data. It’s good practice to keep them separate. The data folder should only contain the raw, unaltered data, and should be left alone to make sure we don’t delete or modify it. In contrast, our script will generate the contents of the data_output directory, so even if the files it contains are deleted, we can always re-generate them.\nLet’s use write_csv() to save the rna_wide table that we have created previously.\n\nwrite_csv(rna_wide, file = \"data_output/rna_wide.csv\")"
  },
  {
    "objectID": "bioc_intro_dataVisualization.html",
    "href": "bioc_intro_dataVisualization.html",
    "title": "Data Visualization",
    "section": "",
    "text": "We start by loading the required packages. ggplot2 is included in the tidyverse package.\n\nlibrary(\"tidyverse\")\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nIf not still in the workspace, load the data we saved in the previous lesson.\n\nrna &lt;- read.csv(\"data/rnaseq.csv\")\n\nThe Data Visualization Cheat Sheet will cover the basics and more advanced features of ggplot2 and will help, in addition to serve as a reminder, getting an overview of the many data representations available in the package. The following video tutorials (part 1 and 2) by Thomas Lin Pedersen are also very instructive.\n\n\nggplot2 is a plotting package that makes it simple to create complex plots from data in a data frame. It provides a more programmatic interface for specifying what variables to plot, how they are displayed, and general visual properties. The theoretical foundation that supports the ggplot2 is the Grammar of Graphics (@Wilkinson:2005). Using this approach, we only need minimal changes if the underlying data change or if we decide to change from a bar plot to a scatterplot. This helps in creating publication quality plots with minimal amounts of adjustments and tweaking.\nThere is a book about ggplot2 (@ggplot2book) that provides a good overview, but it is outdated. The 3rd edition is in preparation and will be freely available online. The ggplot2 webpage (https://ggplot2.tidyverse.org) provides ample documentation.\nggplot2 functions like data in the ‘long’ format, i.e., a column for every dimension, and a row for every observation. Well-structured data will save you lots of time when making figures with ggplot2.\nggplot graphics are built step by step by adding new elements. Adding layers in this fashion allows for extensive flexibility and customization of plots.\nThe idea behind the Grammar of Graphics it is that you can build every graph from the same 3 components: (1) a data set, (2) a coordinate system, and (3) geoms — i.e. visual marks that represent data points 1.\nTo build a ggplot, we will use the following basic template that can be used for different types of plots:\n\nggplot(data = &lt;DATA&gt;, mapping = aes(&lt;MAPPINGS&gt;)) +  &lt;GEOM_FUNCTION&gt;()\n\n\nuse the ggplot() function and bind the plot to a specific data frame using the data argument\n\nggplot(data = rna)\n\n\n\n\n\n\n\n\n\n\n\ndefine a mapping (using the aesthetic (aes) function), by selecting the variables to be plotted and specifying how to present them in the graph, e.g. as x/y positions or characteristics such as size, shape, color, etc.\n\nggplot(data = rna, mapping = aes(x = expression))\n\n\n\n\n\n\n\n\nadd ‘geoms’ - geometries, or graphical representations of the data in the plot (points, lines, bars). ggplot2 offers many different geoms; we will use some common ones today, including:\n\n* `geom_point()` for scatter plots, dot plots, etc.\n* `geom_histogram()` for histograms\n* `geom_boxplot()` for, well, boxplots!\n* `geom_line()` for trend lines, time series, etc.\n\n\nTo add a geom(etry) to the plot use the + operator. Let’s use geom_histogram() first:\n\nggplot(data = rna, mapping = aes(x = expression)) +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nThe + in the ggplot2 package is particularly useful because it allows you to modify existing ggplot objects. This means you can easily set up plot templates and conveniently explore different types of plots, so the above plot can also be generated with code like this:\n\n# Assign plot to a variable\nrna_plot &lt;- ggplot(data = rna,\n                   mapping = aes(x = expression))\n\n# Draw the plot\nrna_plot + geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nYou have probably noticed an automatic message that appears when drawing the histogram:\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\nChange the arguments bins or binwidth of geom_histogram() to change the number or width of the bins.\n\n\nWe can observe here that the data are skewed to the right. We can apply log2 transformation to have a more symmetric distribution. Note that we add here a small constant value (+1) to avoid having -Inf values returned for expression values equal to 0.\n\nrna &lt;- rna %&gt;%\n  mutate(expression_log = log2(expression + 1))\n\nIf we now draw the histogram of the log2-transformed expressions, the distribution is indeed closer to a normal distribution.\n\nggplot(rna, aes(x = expression_log)) + geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nFrom now on we will work on the log-transformed expression values.\n\n\n\n\n\n\nChallenge\n\n\n\nAnother way to visualize this transformation is to consider the scale of the observations. For example, it may be worth changing the scale of the axis to better distribute the observations in the space of the plot. Changing the scale of the axes is done similarly to adding/modifying other components (i.e., by incrementally adding commands). Try making this modification:\n\nRepresent the un-transformed expression on the log10 scale; see scale_x_log10(). Compare it with the previous graph. Why do you now have warning messages appearing?\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNotes\n\nAnything you put in the ggplot() function can be seen by any geom layers that you add (i.e., these are global plot settings). This includes the x- and y-axis mapping you set up in aes().\nYou can also specify mappings for a given geom independently of the mappings defined globally in the ggplot() function.\n\nThe + sign used to add new layers must be placed at the end of the line containing the previous layer. If, instead, the + sign is added at the beginning of the line containing the new layer, ggplot2 will not add the new layer and will return an error message.\n\n\n\n# This is the correct syntax for adding layers\nrna_plot +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n# This will not add the new layer and will return an error message\nrna_plot + \n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\n\n\nWe will now draw a scatter plot with two continuous variables and the geom_point() function. This graph will represent the log2 fold changes of expression comparing time 8 versus time 0, and time 4 versus time 0. To this end, we first need to compute the means of the log-transformed expression values by gene and time, then the log fold changes by subtracting the mean log expressions between time 8 and time 0 and between time 4 and time 0. Note that we also include here the gene biotype that we will use later on to represent the genes. We will save the fold changes in a new data frame called rna_fc.\n\nrna_fc &lt;- rna %&gt;% select(gene, time,\n                         gene_biotype, expression_log) %&gt;%\n  group_by(gene, time, gene_biotype) %&gt;%\n  summarize(mean_exp = mean(expression_log)) %&gt;%\n  pivot_wider(names_from = time,\n              values_from = mean_exp) %&gt;%\n  mutate(time_8_vs_0 = `8` - `0`, time_4_vs_0 = `4` - `0`)\n\n`summarise()` has grouped output by 'gene', 'time'. You can override using the\n`.groups` argument.\n\n\nWe can then build a ggplot with the newly created dataset rna_fc. Building plots with ggplot2 is typically an iterative process. We start by defining the dataset we’ll use, lay out the axes, and choose a geom:\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +\n  geom_point()\n\n\n\n\n\n\n\n\nThen, we start modifying this plot to extract more information from it. For instance, we can add transparency (alpha) to avoid overplotting:\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +\n  geom_point(alpha = 0.3)\n\n\n\n\n\n\n\n\nWe can also add colors for all the points:\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +\n  geom_point(alpha = 0.3, color = \"blue\")\n\n\n\n\n\n\n\n\nOr to color each gene in the plot differently, you could use a vector as an input to the argument color. ggplot2 will provide a different color corresponding to different values in the vector. Here is an example where we color with gene_biotype:\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +\n  geom_point(alpha = 0.3, aes(color = gene_biotype))\n\n\n\n\n\n\n\n\nWe can also specify the colors directly inside the mapping provided in the ggplot() function. This will be seen by any geom layers and the mapping will be determined by the x- and y-axis set up in aes().\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0,\n                                color = gene_biotype)) +\n  geom_point(alpha = 0.3)\n\n\n\n\n\n\n\n\nFinally, we could also add a diagonal line with the geom_abline() function:\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0,\n                                color = gene_biotype)) +\n  geom_point(alpha = 0.3) +\n  geom_abline(intercept = 0)\n\n\n\n\n\n\n\n\nNotice that we can change the geom layer from geom_point to geom_jitter and colors will still be determined by gene_biotype.\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0,\n                                color = gene_biotype)) +\n  geom_jitter(alpha = 0.3) +\n  geom_abline(intercept = 0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nScatter plots can be useful exploratory tools for small datasets. For data sets with large numbers of observations, such as the rna_fc data set, overplotting of points can be a limitation of scatter plots. One strategy for handling such settings is to use hexagonal binning of observations. The plot space is tessellated into hexagons. Each hexagon is assigned a color based on the number of observations that fall within its boundaries.\n\nTo use hexagonal binning in ggplot2, first install the R package hexbin from CRAN and load it.\nThen use the geom_hex() function to produce the hexbin figure.\nWhat are the relative strengths and weaknesses of a hexagonal bin plot compared to a scatter plot? Examine the above scatter plot and compare it with the hexagonal bin plot that you created.\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nUse what you just learned to create a scatter plot of expression_log over sample from the rna dataset with the time showing in different colors. Is this a good way to show this type of data?\n\n\n\n\n\nWe can use boxplots to visualize the distribution of gene expressions within each sample:\n\nggplot(data = rna,\n         mapping = aes(y = expression_log, x = sample)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nBy adding points to boxplot, we can have a better idea of the number of measurements and of their distribution:\n\nggplot(data = rna,\n         mapping = aes(y = expression_log, x = sample)) +\n  geom_jitter(alpha = 0.2, color = \"tomato\") +\n  geom_boxplot(alpha = 0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nNote how the boxplot layer is in front of the jitter layer? What do you need to change in the code to put the boxplot below the points?\n\n\nYou may notice that the values on the x-axis are still not properly readable. Let’s change the orientation of the labels and adjust them vertically and horizontally so they don’t overlap. You can use a 90-degree angle, or experiment to find the appropriate angle for diagonally oriented labels:\n\nggplot(data = rna,\n         mapping = aes(y = expression_log, x = sample)) +\n  geom_jitter(alpha = 0.2, color = \"tomato\") +\n  geom_boxplot(alpha = 0) +\n  theme(axis.text.x = element_text(angle = 90,  hjust = 0.5, vjust = 0.5))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nAdd color to the data points on your boxplot according to the duration of the infection (time).\nHint: Check the class for time. Consider changing the class of time from integer to factor directly in the ggplot mapping. Why does this change how R makes the graph?\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nBoxplots are useful summaries, but hide the shape of the distribution. For example, if the distribution is bimodal, we would not see it in a boxplot. An alternative to the boxplot is the violin plot, where the shape (of the density of points) is drawn.\n\nReplace the box plot with a violin plot; see geom_violin(). Fill in the violins according to the time with the argument fill.\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nModify the violin plot to fill in the violins by sex.\n\n\n\n\n\nLet’s calculate the mean expression per duration of the infection for the 10 genes having the highest log fold changes comparing time 8 versus time 0. First, we need to select the genes and create a subset of rna called sub_rna containing the 10 selected genes, then we need to group the data and calculate the mean gene expression within each group:\n\nrna_fc &lt;- rna_fc %&gt;% arrange(desc(time_8_vs_0))\n\ngenes_selected &lt;- rna_fc$gene[1:10]\n\nsub_rna &lt;- rna %&gt;%\n    filter(gene %in% genes_selected)\n\nmean_exp_by_time &lt;- sub_rna %&gt;%\n  group_by(gene,time) %&gt;%\n    summarize(mean_exp = mean(expression_log))\n\n`summarise()` has grouped output by 'gene'. You can override using the\n`.groups` argument.\n\n\n\nmean_exp_by_time\n\n# A tibble: 30 × 3\n# Groups:   gene [10]\n   gene   time mean_exp\n   &lt;chr&gt; &lt;int&gt;    &lt;dbl&gt;\n 1 Acr       0     5.07\n 2 Acr       4     5.54\n 3 Acr       8     7.31\n 4 Aipl1     0     3.70\n 5 Aipl1     4     3.89\n 6 Aipl1     8     6.56\n 7 Bst1      0     3.20\n 8 Bst1      4     3.77\n 9 Bst1      8     5.22\n10 Chil3     0     4.00\n# ℹ 20 more rows\n\n\nWe can build the line plot with duration of the infection on the x-axis and the mean expression on the y-axis:\n\nggplot(data = mean_exp_by_time, mapping = aes(x = time, y = mean_exp)) +\n  geom_line()\n\n\n\n\n\n\n\n\nUnfortunately, this does not work because we plotted data for all the genes together. We need to tell ggplot to draw a line for each gene by modifying the aesthetic function to include group = gene:\n\nggplot(data = mean_exp_by_time,\n       mapping = aes(x = time, y = mean_exp, group = gene)) +\n  geom_line()\n\n\n\n\n\n\n\n\nWe will be able to distinguish genes in the plot if we add colors (using color also automatically groups the data):\n\nggplot(data = mean_exp_by_time,\n       mapping = aes(x = time, y = mean_exp, color = gene)) +\n  geom_line()\n\n\n\n\n\n\n\n\n\n\n\nggplot2 has a special technique called faceting that allows the user to split one plot into multiple (sub) plots based on a factor included in the dataset. These different subplots inherit the same properties (axes limits, ticks, …) to facilitate their direct comparison. We will use it to make a line plot across time for each gene:\n\nggplot(data = mean_exp_by_time,\n       mapping = aes(x = time, y = mean_exp)) + geom_line() +\n  facet_wrap(~ gene)\n\n\n\n\n\n\n\n\nHere both x- and y-axis have the same scale for all the subplots. You can change this default behavior by modifying scales in order to allow a free scale for the y-axis:\n\nggplot(data = mean_exp_by_time,\n       mapping = aes(x = time, y = mean_exp)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\")\n\n\n\n\n\n\n\n\nNow we would like to split the line in each plot by the sex of the mice. To do that we need to calculate the mean expression in the data frame grouped by gene, time, and sex:\n\nmean_exp_by_time_sex &lt;- sub_rna %&gt;%\n  group_by(gene, time, sex) %&gt;%\n    summarize(mean_exp = mean(expression_log))\n\n`summarise()` has grouped output by 'gene', 'time'. You can override using the\n`.groups` argument.\n\n\n\nmean_exp_by_time_sex\n\n# A tibble: 60 × 4\n# Groups:   gene, time [30]\n   gene   time sex    mean_exp\n   &lt;chr&gt; &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;\n 1 Acr       0 Female     5.13\n 2 Acr       0 Male       5.00\n 3 Acr       4 Female     5.93\n 4 Acr       4 Male       5.15\n 5 Acr       8 Female     7.27\n 6 Acr       8 Male       7.36\n 7 Aipl1     0 Female     3.67\n 8 Aipl1     0 Male       3.73\n 9 Aipl1     4 Female     4.07\n10 Aipl1     4 Male       3.72\n# ℹ 50 more rows\n\n\nWe can now make the faceted plot by splitting further by sex using color (within a single plot):\n\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\")\n\n\n\n\n\n\n\n\nUsually plots with white background look more readable when printed. We can set the background to white using the function theme_bw(). Additionally, we can remove the grid:\n\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nUse what you just learned to create a plot that depicts how the average expression of each chromosome changes through the duration of infection.\n\n\nThe facet_wrap geometry extracts plots into an arbitrary number of dimensions to allow them to cleanly fit on one page. On the other hand, the facet_grid geometry allows you to explicitly specify how you want your plots to be arranged via formula notation (rows ~ columns; a . can be used as a placeholder that indicates only one row or column).\nLet’s modify the previous plot to compare how the mean gene expression of males and females has changed through time:\n\n# One column, facet by rows\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = gene)) +\n  geom_line() +\n  facet_grid(sex ~ .)\n\n\n\n\n\n\n\n\n\n# One row, facet by column\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = gene)) +\n  geom_line() +\n  facet_grid(. ~ sex)\n\n\n\n\n\n\n\n\n\n\n\nIn addition to theme_bw(), which changes the plot background to white, ggplot2 comes with several other themes which can be useful to quickly change the look of your visualization. The complete list of themes is available at https://ggplot2.tidyverse.org/reference/ggtheme.html. theme_minimal() and theme_light() are popular, and theme_void() can be useful as a starting point to create a new hand-crafted theme.\nThe ggthemes package provides a wide variety of options (including an Excel 2003 theme). The ggplot2 extensions website provides a list of packages that extend the capabilities of ggplot2, including additional themes.\n\n\n\nLet’s come back to the faceted plot of mean expression by time and gene, colored by sex.\nTake a look at the ggplot2 cheat sheet, and think of ways you could improve the plot.\nNow, we can change names of axes to something more informative than ‘time’ and ‘mean_exp’, and add a title to the figure:\n\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank()) +\n  labs(title = \"Mean gene expression by duration of the infection\",\n       x = \"Duration of the infection (in days)\",\n       y = \"Mean gene expression\")\n\n\n\n\n\n\n\n\nThe axes have more informative names, but their readability can be improved by increasing the font size:\n\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank()) +\n  labs(title = \"Mean gene expression by duration of the infection\",\n       x = \"Duration of the infection (in days)\",\n       y = \"Mean gene expression\")  +\n  theme(text = element_text(size = 16))\n\n\n\n\n\n\n\n\nNote that it is also possible to change the fonts of your plots. If you are on Windows, you may have to install the extrafont package.\nWe can further customize the color of x- and y-axis text, the color of the grid, etc. We can also for example move the legend to the top by setting legend.position to \"top\".\n\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank()) +\n  labs(title = \"Mean gene expression by duration of the infection\",\n       x = \"Duration of the infection (in days)\",\n       y = \"Mean gene expression\")  +\n  theme(text = element_text(size = 16),\n        axis.text.x = element_text(colour = \"royalblue4\", size = 12),\n        axis.text.y = element_text(colour = \"royalblue4\", size = 12),\n        panel.grid = element_line(colour=\"lightsteelblue1\"),\n        legend.position = \"top\")\n\n\n\n\n\n\n\n\nIf you like the changes you created better than the default theme, you can save them as an object to be able to easily apply them to other plots you may create. Here is an example with the histogram we have previously created.\n\nblue_theme &lt;- theme(axis.text.x = element_text(colour = \"royalblue4\",\n                                               size = 12),\n                    axis.text.y = element_text(colour = \"royalblue4\",\n                                               size = 12),\n                    text = element_text(size = 16),\n                    panel.grid = element_line(colour=\"lightsteelblue1\"))\n\nggplot(rna, aes(x = expression_log)) +\n  geom_histogram(bins = 20) +\n    blue_theme\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWith all of this information in hand, please take another five minutes to either improve one of the plots generated in this exercise or create a beautiful graph of your own. Use the RStudio ggplot2 cheat sheet for inspiration. Here are some ideas:\n\nSee if you can change the thickness of the lines.\nCan you find a way to change the name of the legend? What about its labels? (hint: look for a ggplot function starting with scale_)\nTry using a different color palette or manually specifying the colors for the lines (see http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/).\n\n\n\n\n\n\nFaceting is a great tool for splitting one plot into multiple subplots, but sometimes you may want to produce a single figure that contains multiple independent plots, i.e. plots that are based on different variables or even different data frames.\nLet’s start by creating the two plots that we want to arrange next to each other:\nThe first graph counts the number of unique genes per chromosome. We first need to reorder the levels of chromosome_name and filter the unique genes per chromosome. We also change the scale of the y-axis to a log10 scale for better readability.\n\nrna$chromosome_name &lt;- factor(rna$chromosome_name,\n                               levels = c(1:19,\"X\",\"Y\"))\n\ncount_gene_chromosome &lt;- rna %&gt;% select(chromosome_name, gene) %&gt;%\n  distinct() %&gt;% ggplot() +\n  geom_bar(aes(x = chromosome_name), fill = \"seagreen\",\n           position = \"dodge\", stat = \"count\") +\n  labs(y = \"log10(n genes)\", x = \"chromosome\") +\n  scale_y_log10()\n\ncount_gene_chromosome\n\n\n\n\n\n\n\n\nBelow, we also remove the legend altogether by setting the legend.position to \"none\".\n\nexp_boxplot_sex &lt;- ggplot(rna, aes(y=expression_log, x = as.factor(time),\n                 color=sex)) +\n   geom_boxplot(alpha = 0) +\n  labs(y = \"Mean gene exp\",\n       x = \"time\") + theme(legend.position = \"none\")\n\nexp_boxplot_sex\n\n\n\n\n\n\n\n\nThe patchwork package provides an elegant approach to combining figures using the + to arrange figures (typically side by side). More specifically the | explicitly arranges them side by side and / stacks them on top of each other.\n\ninstall.packages(\"patchwork\")\n\n\nThe downloaded binary packages are in\n    /var/folders/6v/qms_hkh14rqbc_q9c29yjk3m0000gn/T//RtmpRcjcli/downloaded_packages\n\n\n\nlibrary(\"patchwork\")\n\nWarning: package 'patchwork' was built under R version 4.3.3\n\ncount_gene_chromosome + exp_boxplot_sex\n\n\n\n\n\n\n\n\n\n## or count_gene_chromosome | exp_boxplot_sex\n\n\ncount_gene_chromosome / exp_boxplot_sex\n\n\n\n\n\n\n\n\nWe can combine further control the layout of the final composition with plot_layout to create more complex layouts:\n\ncount_gene_chromosome + exp_boxplot_sex + plot_layout(ncol = 1)\n\n\n\n\n\n\n\n\n\ncount_gene_chromosome +\n (count_gene_chromosome + exp_boxplot_sex) +\n exp_boxplot_sex +\n plot_layout(ncol = 1)\n\n\n\n\n\n\n\n\nThe last plot can also be created using the | and / composers:\n\ncount_gene_chromosome /\n (count_gene_chromosome | exp_boxplot_sex) /\n exp_boxplot_sex\n\n\n\n\n\n\n\n\nLearn more about patchwork on its webpage or in this video.\nAnother option is the gridExtra package that allows to combine separate ggplots into a single figure using grid.arrange():\n\ninstall.packages(\"gridExtra\")\n\n\nThe downloaded binary packages are in\n    /var/folders/6v/qms_hkh14rqbc_q9c29yjk3m0000gn/T//RtmpRcjcli/downloaded_packages\n\n\n\nlibrary(\"gridExtra\")\n\n\nAttaching package: 'gridExtra'\n\n\nThe following object is masked from 'package:dplyr':\n\n    combine\n\ngrid.arrange(count_gene_chromosome, exp_boxplot_sex, ncol = 2)\n\n\n\n\n\n\n\n\nIn addition to the ncol and nrow arguments, used to make simple arrangements, there are tools for constructing more complex layouts.\n\n\n\nAfter creating your plot, you can save it to a file in your favorite format. The Export tab in the Plot pane in RStudio will save your plots at low resolution, which will not be accepted by many journals and will not scale well for posters.\nInstead, use the ggsave() function, which allows you easily change the dimension and resolution of your plot by adjusting the appropriate arguments (width, height and dpi).\nMake sure you have the fig_output/ folder in your working directory.\n\nmy_plot &lt;- ggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  labs(title = \"Mean gene expression by duration of the infection\",\n         x = \"Duration of the infection (in days)\",\n         y = \"Mean gene expression\") +\n  guides(color=guide_legend(title=\"Gender\")) +\n  theme_bw() +\n  theme(axis.text.x = element_text(colour = \"royalblue4\", size = 12),\n        axis.text.y = element_text(colour = \"royalblue4\", size = 12),\n        text = element_text(size = 16),\n        panel.grid = element_line(colour=\"lightsteelblue1\"),\n        legend.position = \"top\")\nggsave(\"fig_output/mean_exp_by_time_sex.png\", my_plot, width = 15,\n       height = 10,create.dir = TRUE)\n\n# This also works for grid.arrange() plots\ncombo_plot &lt;- grid.arrange(count_gene_chromosome, exp_boxplot_sex,\n                           ncol = 2, widths = c(4, 6))\n\n\n\n\n\n\n\nggsave(\"fig_output/combo_plot_chromosome_sex.png\", combo_plot,width = 10, dpi = 300,create.dir = TRUE)\n\nSaving 10 x 5 in image\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote: The parameters width and height also determine the font size in the saved plot.\n\n\n\n\n\nggplot2 is a very powerful package that fits very nicely in our tidy data and tidy tools pipeline. There are other visualization packages in R that shouldn’t be ignored.\n\n\nThe default graphics system that comes with R, often called base R graphics is simple and fast. It is based on the painter’s or canvas model, where different output are directly overlaid on top of each other (see figure @ref(fig:paintermodel)). This is a fundamental difference with ggplot2 (and with lattice, described below), that returns dedicated objects, that are rendered on screen or in a file, and that can even be updated.\n\npar(mfrow = c(1, 3))\nplot(1:20, main = \"First layer, produced with plot(1:20)\")\n\nplot(1:20, main = \"A horizontal red line, added with abline(h = 10)\")\nabline(h = 10, col = \"red\")\n\nplot(1:20, main = \"A rectangle, added with rect(5, 5, 15, 15)\")\nabline(h = 10, col = \"red\")\nrect(5, 5, 15, 15, lwd = 3)\n\n\n\n\n\n\n\n\nAnother main difference is that base graphics’ plotting function try to do the right thing based on their input type, i.e. they will adapt their behaviour based on the class of their input. This is again very different from what we have in ggplot2, that only accepts dataframes as input, and that requires plots to be constructed bit by bit.\n\npar(mfrow = c(2, 2))\nboxplot(rnorm(100),\n        main = \"Boxplot of rnorm(100)\")\nboxplot(matrix(rnorm(100), ncol = 10),\n        main = \"Boxplot of matrix(rnorm(100), ncol = 10)\")\nhist(rnorm(100))\nhist(matrix(rnorm(100), ncol = 10))\n\n\n\n\n\n\n\n\nThe out-of-the-box approach in base graphics can be very efficient for simple, standard figures, that can be produced very quickly with a single line of code and a single function such as plot, or hist, or boxplot, … The defaults are however not always the most appealing and tuning of figures, especially when they become more complex (for example to produce facets), can become lengthy and cumbersome.\n\n\n\nThe lattice package is similar to ggplot2 in that is uses dataframes as input, returns graphical objects and supports faceting. lattice however isn’t based on the grammar of graphics and has a more convoluted interface.\nA good reference for the lattice package is @latticebook."
  },
  {
    "objectID": "bioc_intro_dataVisualization.html#data-visualization",
    "href": "bioc_intro_dataVisualization.html#data-visualization",
    "title": "Data Visualization",
    "section": "",
    "text": "We start by loading the required packages. ggplot2 is included in the tidyverse package.\n\nlibrary(\"tidyverse\")\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nIf not still in the workspace, load the data we saved in the previous lesson.\n\nrna &lt;- read.csv(\"data/rnaseq.csv\")\n\nThe Data Visualization Cheat Sheet will cover the basics and more advanced features of ggplot2 and will help, in addition to serve as a reminder, getting an overview of the many data representations available in the package. The following video tutorials (part 1 and 2) by Thomas Lin Pedersen are also very instructive.\n\n\nggplot2 is a plotting package that makes it simple to create complex plots from data in a data frame. It provides a more programmatic interface for specifying what variables to plot, how they are displayed, and general visual properties. The theoretical foundation that supports the ggplot2 is the Grammar of Graphics (@Wilkinson:2005). Using this approach, we only need minimal changes if the underlying data change or if we decide to change from a bar plot to a scatterplot. This helps in creating publication quality plots with minimal amounts of adjustments and tweaking.\nThere is a book about ggplot2 (@ggplot2book) that provides a good overview, but it is outdated. The 3rd edition is in preparation and will be freely available online. The ggplot2 webpage (https://ggplot2.tidyverse.org) provides ample documentation.\nggplot2 functions like data in the ‘long’ format, i.e., a column for every dimension, and a row for every observation. Well-structured data will save you lots of time when making figures with ggplot2.\nggplot graphics are built step by step by adding new elements. Adding layers in this fashion allows for extensive flexibility and customization of plots.\nThe idea behind the Grammar of Graphics it is that you can build every graph from the same 3 components: (1) a data set, (2) a coordinate system, and (3) geoms — i.e. visual marks that represent data points 1.\nTo build a ggplot, we will use the following basic template that can be used for different types of plots:\n\nggplot(data = &lt;DATA&gt;, mapping = aes(&lt;MAPPINGS&gt;)) +  &lt;GEOM_FUNCTION&gt;()\n\n\nuse the ggplot() function and bind the plot to a specific data frame using the data argument\n\nggplot(data = rna)\n\n\n\n\n\n\n\n\n\n\n\ndefine a mapping (using the aesthetic (aes) function), by selecting the variables to be plotted and specifying how to present them in the graph, e.g. as x/y positions or characteristics such as size, shape, color, etc.\n\nggplot(data = rna, mapping = aes(x = expression))\n\n\n\n\n\n\n\n\nadd ‘geoms’ - geometries, or graphical representations of the data in the plot (points, lines, bars). ggplot2 offers many different geoms; we will use some common ones today, including:\n\n* `geom_point()` for scatter plots, dot plots, etc.\n* `geom_histogram()` for histograms\n* `geom_boxplot()` for, well, boxplots!\n* `geom_line()` for trend lines, time series, etc.\n\n\nTo add a geom(etry) to the plot use the + operator. Let’s use geom_histogram() first:\n\nggplot(data = rna, mapping = aes(x = expression)) +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nThe + in the ggplot2 package is particularly useful because it allows you to modify existing ggplot objects. This means you can easily set up plot templates and conveniently explore different types of plots, so the above plot can also be generated with code like this:\n\n# Assign plot to a variable\nrna_plot &lt;- ggplot(data = rna,\n                   mapping = aes(x = expression))\n\n# Draw the plot\nrna_plot + geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nYou have probably noticed an automatic message that appears when drawing the histogram:\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\nChange the arguments bins or binwidth of geom_histogram() to change the number or width of the bins.\n\n\nWe can observe here that the data are skewed to the right. We can apply log2 transformation to have a more symmetric distribution. Note that we add here a small constant value (+1) to avoid having -Inf values returned for expression values equal to 0.\n\nrna &lt;- rna %&gt;%\n  mutate(expression_log = log2(expression + 1))\n\nIf we now draw the histogram of the log2-transformed expressions, the distribution is indeed closer to a normal distribution.\n\nggplot(rna, aes(x = expression_log)) + geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nFrom now on we will work on the log-transformed expression values.\n\n\n\n\n\n\nChallenge\n\n\n\nAnother way to visualize this transformation is to consider the scale of the observations. For example, it may be worth changing the scale of the axis to better distribute the observations in the space of the plot. Changing the scale of the axes is done similarly to adding/modifying other components (i.e., by incrementally adding commands). Try making this modification:\n\nRepresent the un-transformed expression on the log10 scale; see scale_x_log10(). Compare it with the previous graph. Why do you now have warning messages appearing?\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNotes\n\nAnything you put in the ggplot() function can be seen by any geom layers that you add (i.e., these are global plot settings). This includes the x- and y-axis mapping you set up in aes().\nYou can also specify mappings for a given geom independently of the mappings defined globally in the ggplot() function.\n\nThe + sign used to add new layers must be placed at the end of the line containing the previous layer. If, instead, the + sign is added at the beginning of the line containing the new layer, ggplot2 will not add the new layer and will return an error message.\n\n\n\n# This is the correct syntax for adding layers\nrna_plot +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n# This will not add the new layer and will return an error message\nrna_plot + \n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\n\n\nWe will now draw a scatter plot with two continuous variables and the geom_point() function. This graph will represent the log2 fold changes of expression comparing time 8 versus time 0, and time 4 versus time 0. To this end, we first need to compute the means of the log-transformed expression values by gene and time, then the log fold changes by subtracting the mean log expressions between time 8 and time 0 and between time 4 and time 0. Note that we also include here the gene biotype that we will use later on to represent the genes. We will save the fold changes in a new data frame called rna_fc.\n\nrna_fc &lt;- rna %&gt;% select(gene, time,\n                         gene_biotype, expression_log) %&gt;%\n  group_by(gene, time, gene_biotype) %&gt;%\n  summarize(mean_exp = mean(expression_log)) %&gt;%\n  pivot_wider(names_from = time,\n              values_from = mean_exp) %&gt;%\n  mutate(time_8_vs_0 = `8` - `0`, time_4_vs_0 = `4` - `0`)\n\n`summarise()` has grouped output by 'gene', 'time'. You can override using the\n`.groups` argument.\n\n\nWe can then build a ggplot with the newly created dataset rna_fc. Building plots with ggplot2 is typically an iterative process. We start by defining the dataset we’ll use, lay out the axes, and choose a geom:\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +\n  geom_point()\n\n\n\n\n\n\n\n\nThen, we start modifying this plot to extract more information from it. For instance, we can add transparency (alpha) to avoid overplotting:\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +\n  geom_point(alpha = 0.3)\n\n\n\n\n\n\n\n\nWe can also add colors for all the points:\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +\n  geom_point(alpha = 0.3, color = \"blue\")\n\n\n\n\n\n\n\n\nOr to color each gene in the plot differently, you could use a vector as an input to the argument color. ggplot2 will provide a different color corresponding to different values in the vector. Here is an example where we color with gene_biotype:\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0)) +\n  geom_point(alpha = 0.3, aes(color = gene_biotype))\n\n\n\n\n\n\n\n\nWe can also specify the colors directly inside the mapping provided in the ggplot() function. This will be seen by any geom layers and the mapping will be determined by the x- and y-axis set up in aes().\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0,\n                                color = gene_biotype)) +\n  geom_point(alpha = 0.3)\n\n\n\n\n\n\n\n\nFinally, we could also add a diagonal line with the geom_abline() function:\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0,\n                                color = gene_biotype)) +\n  geom_point(alpha = 0.3) +\n  geom_abline(intercept = 0)\n\n\n\n\n\n\n\n\nNotice that we can change the geom layer from geom_point to geom_jitter and colors will still be determined by gene_biotype.\n\nggplot(data = rna_fc, mapping = aes(x = time_4_vs_0, y = time_8_vs_0,\n                                color = gene_biotype)) +\n  geom_jitter(alpha = 0.3) +\n  geom_abline(intercept = 0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nScatter plots can be useful exploratory tools for small datasets. For data sets with large numbers of observations, such as the rna_fc data set, overplotting of points can be a limitation of scatter plots. One strategy for handling such settings is to use hexagonal binning of observations. The plot space is tessellated into hexagons. Each hexagon is assigned a color based on the number of observations that fall within its boundaries.\n\nTo use hexagonal binning in ggplot2, first install the R package hexbin from CRAN and load it.\nThen use the geom_hex() function to produce the hexbin figure.\nWhat are the relative strengths and weaknesses of a hexagonal bin plot compared to a scatter plot? Examine the above scatter plot and compare it with the hexagonal bin plot that you created.\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nUse what you just learned to create a scatter plot of expression_log over sample from the rna dataset with the time showing in different colors. Is this a good way to show this type of data?\n\n\n\n\n\nWe can use boxplots to visualize the distribution of gene expressions within each sample:\n\nggplot(data = rna,\n         mapping = aes(y = expression_log, x = sample)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nBy adding points to boxplot, we can have a better idea of the number of measurements and of their distribution:\n\nggplot(data = rna,\n         mapping = aes(y = expression_log, x = sample)) +\n  geom_jitter(alpha = 0.2, color = \"tomato\") +\n  geom_boxplot(alpha = 0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nNote how the boxplot layer is in front of the jitter layer? What do you need to change in the code to put the boxplot below the points?\n\n\nYou may notice that the values on the x-axis are still not properly readable. Let’s change the orientation of the labels and adjust them vertically and horizontally so they don’t overlap. You can use a 90-degree angle, or experiment to find the appropriate angle for diagonally oriented labels:\n\nggplot(data = rna,\n         mapping = aes(y = expression_log, x = sample)) +\n  geom_jitter(alpha = 0.2, color = \"tomato\") +\n  geom_boxplot(alpha = 0) +\n  theme(axis.text.x = element_text(angle = 90,  hjust = 0.5, vjust = 0.5))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nAdd color to the data points on your boxplot according to the duration of the infection (time).\nHint: Check the class for time. Consider changing the class of time from integer to factor directly in the ggplot mapping. Why does this change how R makes the graph?\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nBoxplots are useful summaries, but hide the shape of the distribution. For example, if the distribution is bimodal, we would not see it in a boxplot. An alternative to the boxplot is the violin plot, where the shape (of the density of points) is drawn.\n\nReplace the box plot with a violin plot; see geom_violin(). Fill in the violins according to the time with the argument fill.\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nModify the violin plot to fill in the violins by sex.\n\n\n\n\n\nLet’s calculate the mean expression per duration of the infection for the 10 genes having the highest log fold changes comparing time 8 versus time 0. First, we need to select the genes and create a subset of rna called sub_rna containing the 10 selected genes, then we need to group the data and calculate the mean gene expression within each group:\n\nrna_fc &lt;- rna_fc %&gt;% arrange(desc(time_8_vs_0))\n\ngenes_selected &lt;- rna_fc$gene[1:10]\n\nsub_rna &lt;- rna %&gt;%\n    filter(gene %in% genes_selected)\n\nmean_exp_by_time &lt;- sub_rna %&gt;%\n  group_by(gene,time) %&gt;%\n    summarize(mean_exp = mean(expression_log))\n\n`summarise()` has grouped output by 'gene'. You can override using the\n`.groups` argument.\n\n\n\nmean_exp_by_time\n\n# A tibble: 30 × 3\n# Groups:   gene [10]\n   gene   time mean_exp\n   &lt;chr&gt; &lt;int&gt;    &lt;dbl&gt;\n 1 Acr       0     5.07\n 2 Acr       4     5.54\n 3 Acr       8     7.31\n 4 Aipl1     0     3.70\n 5 Aipl1     4     3.89\n 6 Aipl1     8     6.56\n 7 Bst1      0     3.20\n 8 Bst1      4     3.77\n 9 Bst1      8     5.22\n10 Chil3     0     4.00\n# ℹ 20 more rows\n\n\nWe can build the line plot with duration of the infection on the x-axis and the mean expression on the y-axis:\n\nggplot(data = mean_exp_by_time, mapping = aes(x = time, y = mean_exp)) +\n  geom_line()\n\n\n\n\n\n\n\n\nUnfortunately, this does not work because we plotted data for all the genes together. We need to tell ggplot to draw a line for each gene by modifying the aesthetic function to include group = gene:\n\nggplot(data = mean_exp_by_time,\n       mapping = aes(x = time, y = mean_exp, group = gene)) +\n  geom_line()\n\n\n\n\n\n\n\n\nWe will be able to distinguish genes in the plot if we add colors (using color also automatically groups the data):\n\nggplot(data = mean_exp_by_time,\n       mapping = aes(x = time, y = mean_exp, color = gene)) +\n  geom_line()\n\n\n\n\n\n\n\n\n\n\n\nggplot2 has a special technique called faceting that allows the user to split one plot into multiple (sub) plots based on a factor included in the dataset. These different subplots inherit the same properties (axes limits, ticks, …) to facilitate their direct comparison. We will use it to make a line plot across time for each gene:\n\nggplot(data = mean_exp_by_time,\n       mapping = aes(x = time, y = mean_exp)) + geom_line() +\n  facet_wrap(~ gene)\n\n\n\n\n\n\n\n\nHere both x- and y-axis have the same scale for all the subplots. You can change this default behavior by modifying scales in order to allow a free scale for the y-axis:\n\nggplot(data = mean_exp_by_time,\n       mapping = aes(x = time, y = mean_exp)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\")\n\n\n\n\n\n\n\n\nNow we would like to split the line in each plot by the sex of the mice. To do that we need to calculate the mean expression in the data frame grouped by gene, time, and sex:\n\nmean_exp_by_time_sex &lt;- sub_rna %&gt;%\n  group_by(gene, time, sex) %&gt;%\n    summarize(mean_exp = mean(expression_log))\n\n`summarise()` has grouped output by 'gene', 'time'. You can override using the\n`.groups` argument.\n\n\n\nmean_exp_by_time_sex\n\n# A tibble: 60 × 4\n# Groups:   gene, time [30]\n   gene   time sex    mean_exp\n   &lt;chr&gt; &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;\n 1 Acr       0 Female     5.13\n 2 Acr       0 Male       5.00\n 3 Acr       4 Female     5.93\n 4 Acr       4 Male       5.15\n 5 Acr       8 Female     7.27\n 6 Acr       8 Male       7.36\n 7 Aipl1     0 Female     3.67\n 8 Aipl1     0 Male       3.73\n 9 Aipl1     4 Female     4.07\n10 Aipl1     4 Male       3.72\n# ℹ 50 more rows\n\n\nWe can now make the faceted plot by splitting further by sex using color (within a single plot):\n\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\")\n\n\n\n\n\n\n\n\nUsually plots with white background look more readable when printed. We can set the background to white using the function theme_bw(). Additionally, we can remove the grid:\n\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nUse what you just learned to create a plot that depicts how the average expression of each chromosome changes through the duration of infection.\n\n\nThe facet_wrap geometry extracts plots into an arbitrary number of dimensions to allow them to cleanly fit on one page. On the other hand, the facet_grid geometry allows you to explicitly specify how you want your plots to be arranged via formula notation (rows ~ columns; a . can be used as a placeholder that indicates only one row or column).\nLet’s modify the previous plot to compare how the mean gene expression of males and females has changed through time:\n\n# One column, facet by rows\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = gene)) +\n  geom_line() +\n  facet_grid(sex ~ .)\n\n\n\n\n\n\n\n\n\n# One row, facet by column\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = gene)) +\n  geom_line() +\n  facet_grid(. ~ sex)\n\n\n\n\n\n\n\n\n\n\n\nIn addition to theme_bw(), which changes the plot background to white, ggplot2 comes with several other themes which can be useful to quickly change the look of your visualization. The complete list of themes is available at https://ggplot2.tidyverse.org/reference/ggtheme.html. theme_minimal() and theme_light() are popular, and theme_void() can be useful as a starting point to create a new hand-crafted theme.\nThe ggthemes package provides a wide variety of options (including an Excel 2003 theme). The ggplot2 extensions website provides a list of packages that extend the capabilities of ggplot2, including additional themes.\n\n\n\nLet’s come back to the faceted plot of mean expression by time and gene, colored by sex.\nTake a look at the ggplot2 cheat sheet, and think of ways you could improve the plot.\nNow, we can change names of axes to something more informative than ‘time’ and ‘mean_exp’, and add a title to the figure:\n\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank()) +\n  labs(title = \"Mean gene expression by duration of the infection\",\n       x = \"Duration of the infection (in days)\",\n       y = \"Mean gene expression\")\n\n\n\n\n\n\n\n\nThe axes have more informative names, but their readability can be improved by increasing the font size:\n\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank()) +\n  labs(title = \"Mean gene expression by duration of the infection\",\n       x = \"Duration of the infection (in days)\",\n       y = \"Mean gene expression\")  +\n  theme(text = element_text(size = 16))\n\n\n\n\n\n\n\n\nNote that it is also possible to change the fonts of your plots. If you are on Windows, you may have to install the extrafont package.\nWe can further customize the color of x- and y-axis text, the color of the grid, etc. We can also for example move the legend to the top by setting legend.position to \"top\".\n\nggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  theme_bw() +\n  theme(panel.grid = element_blank()) +\n  labs(title = \"Mean gene expression by duration of the infection\",\n       x = \"Duration of the infection (in days)\",\n       y = \"Mean gene expression\")  +\n  theme(text = element_text(size = 16),\n        axis.text.x = element_text(colour = \"royalblue4\", size = 12),\n        axis.text.y = element_text(colour = \"royalblue4\", size = 12),\n        panel.grid = element_line(colour=\"lightsteelblue1\"),\n        legend.position = \"top\")\n\n\n\n\n\n\n\n\nIf you like the changes you created better than the default theme, you can save them as an object to be able to easily apply them to other plots you may create. Here is an example with the histogram we have previously created.\n\nblue_theme &lt;- theme(axis.text.x = element_text(colour = \"royalblue4\",\n                                               size = 12),\n                    axis.text.y = element_text(colour = \"royalblue4\",\n                                               size = 12),\n                    text = element_text(size = 16),\n                    panel.grid = element_line(colour=\"lightsteelblue1\"))\n\nggplot(rna, aes(x = expression_log)) +\n  geom_histogram(bins = 20) +\n    blue_theme\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWith all of this information in hand, please take another five minutes to either improve one of the plots generated in this exercise or create a beautiful graph of your own. Use the RStudio ggplot2 cheat sheet for inspiration. Here are some ideas:\n\nSee if you can change the thickness of the lines.\nCan you find a way to change the name of the legend? What about its labels? (hint: look for a ggplot function starting with scale_)\nTry using a different color palette or manually specifying the colors for the lines (see http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/).\n\n\n\n\n\n\nFaceting is a great tool for splitting one plot into multiple subplots, but sometimes you may want to produce a single figure that contains multiple independent plots, i.e. plots that are based on different variables or even different data frames.\nLet’s start by creating the two plots that we want to arrange next to each other:\nThe first graph counts the number of unique genes per chromosome. We first need to reorder the levels of chromosome_name and filter the unique genes per chromosome. We also change the scale of the y-axis to a log10 scale for better readability.\n\nrna$chromosome_name &lt;- factor(rna$chromosome_name,\n                               levels = c(1:19,\"X\",\"Y\"))\n\ncount_gene_chromosome &lt;- rna %&gt;% select(chromosome_name, gene) %&gt;%\n  distinct() %&gt;% ggplot() +\n  geom_bar(aes(x = chromosome_name), fill = \"seagreen\",\n           position = \"dodge\", stat = \"count\") +\n  labs(y = \"log10(n genes)\", x = \"chromosome\") +\n  scale_y_log10()\n\ncount_gene_chromosome\n\n\n\n\n\n\n\n\nBelow, we also remove the legend altogether by setting the legend.position to \"none\".\n\nexp_boxplot_sex &lt;- ggplot(rna, aes(y=expression_log, x = as.factor(time),\n                 color=sex)) +\n   geom_boxplot(alpha = 0) +\n  labs(y = \"Mean gene exp\",\n       x = \"time\") + theme(legend.position = \"none\")\n\nexp_boxplot_sex\n\n\n\n\n\n\n\n\nThe patchwork package provides an elegant approach to combining figures using the + to arrange figures (typically side by side). More specifically the | explicitly arranges them side by side and / stacks them on top of each other.\n\ninstall.packages(\"patchwork\")\n\n\nThe downloaded binary packages are in\n    /var/folders/6v/qms_hkh14rqbc_q9c29yjk3m0000gn/T//RtmpRcjcli/downloaded_packages\n\n\n\nlibrary(\"patchwork\")\n\nWarning: package 'patchwork' was built under R version 4.3.3\n\ncount_gene_chromosome + exp_boxplot_sex\n\n\n\n\n\n\n\n\n\n## or count_gene_chromosome | exp_boxplot_sex\n\n\ncount_gene_chromosome / exp_boxplot_sex\n\n\n\n\n\n\n\n\nWe can combine further control the layout of the final composition with plot_layout to create more complex layouts:\n\ncount_gene_chromosome + exp_boxplot_sex + plot_layout(ncol = 1)\n\n\n\n\n\n\n\n\n\ncount_gene_chromosome +\n (count_gene_chromosome + exp_boxplot_sex) +\n exp_boxplot_sex +\n plot_layout(ncol = 1)\n\n\n\n\n\n\n\n\nThe last plot can also be created using the | and / composers:\n\ncount_gene_chromosome /\n (count_gene_chromosome | exp_boxplot_sex) /\n exp_boxplot_sex\n\n\n\n\n\n\n\n\nLearn more about patchwork on its webpage or in this video.\nAnother option is the gridExtra package that allows to combine separate ggplots into a single figure using grid.arrange():\n\ninstall.packages(\"gridExtra\")\n\n\nThe downloaded binary packages are in\n    /var/folders/6v/qms_hkh14rqbc_q9c29yjk3m0000gn/T//RtmpRcjcli/downloaded_packages\n\n\n\nlibrary(\"gridExtra\")\n\n\nAttaching package: 'gridExtra'\n\n\nThe following object is masked from 'package:dplyr':\n\n    combine\n\ngrid.arrange(count_gene_chromosome, exp_boxplot_sex, ncol = 2)\n\n\n\n\n\n\n\n\nIn addition to the ncol and nrow arguments, used to make simple arrangements, there are tools for constructing more complex layouts.\n\n\n\nAfter creating your plot, you can save it to a file in your favorite format. The Export tab in the Plot pane in RStudio will save your plots at low resolution, which will not be accepted by many journals and will not scale well for posters.\nInstead, use the ggsave() function, which allows you easily change the dimension and resolution of your plot by adjusting the appropriate arguments (width, height and dpi).\nMake sure you have the fig_output/ folder in your working directory.\n\nmy_plot &lt;- ggplot(data = mean_exp_by_time_sex,\n       mapping = aes(x = time, y = mean_exp, color = sex)) +\n  geom_line() +\n  facet_wrap(~ gene, scales = \"free_y\") +\n  labs(title = \"Mean gene expression by duration of the infection\",\n         x = \"Duration of the infection (in days)\",\n         y = \"Mean gene expression\") +\n  guides(color=guide_legend(title=\"Gender\")) +\n  theme_bw() +\n  theme(axis.text.x = element_text(colour = \"royalblue4\", size = 12),\n        axis.text.y = element_text(colour = \"royalblue4\", size = 12),\n        text = element_text(size = 16),\n        panel.grid = element_line(colour=\"lightsteelblue1\"),\n        legend.position = \"top\")\nggsave(\"fig_output/mean_exp_by_time_sex.png\", my_plot, width = 15,\n       height = 10,create.dir = TRUE)\n\n# This also works for grid.arrange() plots\ncombo_plot &lt;- grid.arrange(count_gene_chromosome, exp_boxplot_sex,\n                           ncol = 2, widths = c(4, 6))\n\n\n\n\n\n\n\nggsave(\"fig_output/combo_plot_chromosome_sex.png\", combo_plot,width = 10, dpi = 300,create.dir = TRUE)\n\nSaving 10 x 5 in image\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote: The parameters width and height also determine the font size in the saved plot.\n\n\n\n\n\nggplot2 is a very powerful package that fits very nicely in our tidy data and tidy tools pipeline. There are other visualization packages in R that shouldn’t be ignored.\n\n\nThe default graphics system that comes with R, often called base R graphics is simple and fast. It is based on the painter’s or canvas model, where different output are directly overlaid on top of each other (see figure @ref(fig:paintermodel)). This is a fundamental difference with ggplot2 (and with lattice, described below), that returns dedicated objects, that are rendered on screen or in a file, and that can even be updated.\n\npar(mfrow = c(1, 3))\nplot(1:20, main = \"First layer, produced with plot(1:20)\")\n\nplot(1:20, main = \"A horizontal red line, added with abline(h = 10)\")\nabline(h = 10, col = \"red\")\n\nplot(1:20, main = \"A rectangle, added with rect(5, 5, 15, 15)\")\nabline(h = 10, col = \"red\")\nrect(5, 5, 15, 15, lwd = 3)\n\n\n\n\n\n\n\n\nAnother main difference is that base graphics’ plotting function try to do the right thing based on their input type, i.e. they will adapt their behaviour based on the class of their input. This is again very different from what we have in ggplot2, that only accepts dataframes as input, and that requires plots to be constructed bit by bit.\n\npar(mfrow = c(2, 2))\nboxplot(rnorm(100),\n        main = \"Boxplot of rnorm(100)\")\nboxplot(matrix(rnorm(100), ncol = 10),\n        main = \"Boxplot of matrix(rnorm(100), ncol = 10)\")\nhist(rnorm(100))\nhist(matrix(rnorm(100), ncol = 10))\n\n\n\n\n\n\n\n\nThe out-of-the-box approach in base graphics can be very efficient for simple, standard figures, that can be produced very quickly with a single line of code and a single function such as plot, or hist, or boxplot, … The defaults are however not always the most appealing and tuning of figures, especially when they become more complex (for example to produce facets), can become lengthy and cumbersome.\n\n\n\nThe lattice package is similar to ggplot2 in that is uses dataframes as input, returns graphical objects and supports faceting. lattice however isn’t based on the grammar of graphics and has a more convoluted interface.\nA good reference for the lattice package is @latticebook."
  },
  {
    "objectID": "bioc_intro_Introduction2R.html",
    "href": "bioc_intro_Introduction2R.html",
    "title": "Introduction to R",
    "section": "",
    "text": "Objectives\n\nDefine the following terms as they relate to R: object, assign, call, function, arguments, options.\nAssign values to objects in R.\nLearn how to name objects\nUse comments to inform script.\nSolve simple arithmetic operations in R.\nCall functions and use arguments to change their default options.\nInspect the content of vectors and manipulate their content.\nSubset and extract values from vectors.\nAnalyze vectors with missing data."
  },
  {
    "objectID": "bioc_intro_Introduction2R.html#creating-objects-in-r",
    "href": "bioc_intro_Introduction2R.html#creating-objects-in-r",
    "title": "Introduction to R",
    "section": "Creating objects in R",
    "text": "Creating objects in R\nYou can get output from R simply by typing math in the console:\n\n3 + 5\n\n[1] 8\n\n\n\n12 / 7\n\n[1] 1.714286\n\n\nHowever, to do useful and interesting things, we need to assign values to objects. To create an object, we need to give it a name followed by the assignment operator &lt;-, and the value we want to give it:\n\nweight_kg &lt;- 55\n\n&lt;- is the assignment operator. It assigns values on the right to objects on the left. So, after executing x &lt;- 3, the value of x is 3. The arrow can be read as 3 goes into x. For historical reasons, you can also use = for assignments, but not in every context. Because of the slight differences in syntax, it is good practice to always use &lt;- for assignments.\nIn RStudio, typing Alt + - (push Alt at the same time as the - key) will write &lt;- in a single keystroke in a PC, while typing Option + - (push Option at the same time as the - key) does the same in a Mac."
  },
  {
    "objectID": "bioc_intro_Introduction2R.html#naming-variables",
    "href": "bioc_intro_Introduction2R.html#naming-variables",
    "title": "Introduction to R",
    "section": "Naming variables",
    "text": "Naming variables\nObjects can be given any name such as x, current_temperature, or subject_id. You want your object names to be explicit and not too long. They cannot start with a number (2x is not valid, but x2 is). R is case sensitive (e.g., weight_kg is different from Weight_kg). There are some names that cannot be used because they are the names of fundamental functions in R (e.g., if, else, for, see here for a complete list). In general, even if it’s allowed, it’s best to not use other function names (e.g., c, T, mean, data, df, weights). If in doubt, check the help to see if the name is already in use. It’s also best to avoid dots (.) within an object name as in my.dataset. There are many functions in R with dots in their names for historical reasons, but because dots have a special meaning in R (for methods) and other programming languages, it’s best to avoid them. It is also recommended to use nouns for object names, and verbs for function names. It’s important to be consistent in the styling of your code (where you put spaces, how you name objects, etc.). Using a consistent coding style makes your code clearer to read for your future self and your collaborators. In R, some popular style guides are Google’s, the tidyverse’s style and the Bioconductor style guide. The tidyverse’s is very comprehensive and may seem overwhelming at first. You can install the lintr package to automatically check for issues in the styling of your code.\n\n\n\n\n\n\nImportant\n\n\n\nObjects vs. variables: What are known as objects in R are known as variables in many other programming languages. Depending on the context, object and variable can have drastically different meanings. However, in this lesson, the two words are used synonymously. For more information see here.\n\n\nWhen assigning a value to an object, R does not print anything. You can force R to print the value by using parentheses or by typing the object name:\n\nweight_kg &lt;- 55    # doesn't print anything\n(weight_kg &lt;- 55)  # but putting parenthesis around the call prints the value of `weight_kg`\n\n[1] 55\n\n\n\nweight_kg          # and so does typing the name of the object\n\n[1] 55\n\n\nNow that R has weight_kg in memory, we can do arithmetic with it. For instance, we may want to convert this weight into pounds (weight in pounds is 2.2 times the weight in kg):\n\n2.2 * weight_kg\n\n[1] 121\n\n\nWe can also change an object’s value by assigning it a new one:\n\nweight_kg &lt;- 57.5\n2.2 * weight_kg\n\n[1] 126.5\n\n\nThis means that assigning a value to one object does not change the values of other objects For example, let’s store the animal’s weight in pounds in a new object, weight_lb:\n\nweight_lb &lt;- 2.2 * weight_kg\n\nand then change weight_kg to 100.\n\nweight_kg &lt;- 100\n\n\n\n\n\n\n\nChallenge\n\n\n\nWhat do you think is the current content of the object weight_lb? 126.5 or 220?"
  },
  {
    "objectID": "bioc_intro_Introduction2R.html#comments",
    "href": "bioc_intro_Introduction2R.html#comments",
    "title": "Introduction to R",
    "section": "Comments",
    "text": "Comments\nThe comment character in R is #, anything to the right of a # in a script will be ignored by R. It is useful to leave notes, and explanations in your scripts.\nRStudio makes it easy to comment or uncomment a paragraph: after selecting the lines you want to comment, press at the same time on your keyboard Ctrl + Shift + C. If you only want to comment out one line, you can put the cursor at any location of that line (i.e. no need to select the whole line), then press Ctrl + Shift + C.\n\n\n\n\n\n\nChallenge\n\n\n\nWhat are the values after each statement in the following?\n\nmass &lt;- 47.5            # mass?\nage  &lt;- 122             # age?\nmass &lt;- mass * 2.0      # mass?\nage  &lt;- age - 20        # age?\nmass_index &lt;- mass/age  # mass_index?"
  },
  {
    "objectID": "bioc_intro_Introduction2R.html#functions-and-their-arguments",
    "href": "bioc_intro_Introduction2R.html#functions-and-their-arguments",
    "title": "Introduction to R",
    "section": "Functions and their arguments",
    "text": "Functions and their arguments\nFunctions are “canned scripts” that automate more complicated sets of commands including operations assignments, etc. Many functions are predefined, or can be made available by importing R packages (more on that later). A function usually gets one or more inputs called arguments. Functions often (but not always) return a value. A typical example would be the function sqrt(). The input (the argument) must be a number, and the return value (in fact, the output) is the square root of that number. Executing a function (‘running it’) is called calling the function. An example of a function call is:\n\nb &lt;- sqrt(a)\n\nHere, the value of a is given to the sqrt() function, the sqrt() function calculates the square root, and returns the value which is then assigned to the object b. This function is very simple, because it takes just one argument.\nThe return ‘value’ of a function need not be numerical (like that of sqrt()), and it also does not need to be a single item: it can be a set of things, or even a dataset. We’ll see that when we read data files into R.\nArguments can be anything, not only numbers or filenames, but also other objects. Exactly what each argument means differs per function, and must be looked up in the documentation (see below). Some functions take arguments which may either be specified by the user, or, if left out, take on a default value: these are called options. Options are typically used to alter the way the function operates, such as whether it ignores ‘bad values’, or what symbol to use in a plot. However, if you want something specific, you can specify a value of your choice which will be used instead of the default.\nLet’s try a function that can take multiple arguments: round().\n\nround(3.14159)\n\n[1] 3\n\n\nHere, we’ve called round() with just one argument, 3.14159, and it has returned the value 3. That’s because the default is to round to the nearest whole number. If we want more digits we can see how to do that by getting information about the round function. We can use args(round) or look at the help for this function using ?round.\n\nargs(round)\n\nfunction (x, digits = 0) \nNULL\n\n\n\n?round\n\nWe see that if we want a different number of digits, we can type digits=2 or however many we want.\n\nround(3.14159, digits = 2)\n\n[1] 3.14\n\n\nIf you provide the arguments in the exact same order as they are defined you don’t have to name them:\n\nround(3.14159, 2)\n\n[1] 3.14\n\n\nAnd if you do name the arguments, you can switch their order:\n\nround(digits = 2, x = 3.14159)\n\n[1] 3.14\n\n\nIt’s good practice to put the non-optional arguments (like the number you’re rounding) first in your function call, and to specify the names of all optional arguments. If you don’t, someone reading your code might have to look up the definition of a function with unfamiliar arguments to understand what you’re doing. By specifying the name of the arguments you are also safeguarding against possible future changes in the function interface, which may potentially add new arguments in between the existing ones."
  },
  {
    "objectID": "bioc_intro_Introduction2R.html#vectors-and-data-types",
    "href": "bioc_intro_Introduction2R.html#vectors-and-data-types",
    "title": "Introduction to R",
    "section": "Vectors and data types",
    "text": "Vectors and data types\nA vector is the most common and basic data type in R, and is pretty much the workhorse of R. A vector is composed by a series of values, such as numbers or characters. We can assign a series of values to a vector using the c() function. For example we can create a vector of animal weights and assign it to a new object weight_g:\n\nweight_g &lt;- c(50, 60, 65, 82)\nweight_g\n\n[1] 50 60 65 82\n\n\nA vector can also contain characters:\n\nmolecules &lt;- c(\"dna\", \"rna\", \"protein\")\nmolecules\n\n[1] \"dna\"     \"rna\"     \"protein\"\n\n\nThe quotes around “dna”, “rna”, etc. are essential here. Without the quotes R will assume there are objects called dna, rna and protein. As these objects don’t exist in R’s memory, there will be an error message.\nThere are many functions that allow you to inspect the content of a vector. length() tells you how many elements are in a particular vector:\n\nlength(weight_g)\n\n[1] 4\n\n\n\nlength(molecules)\n\n[1] 3\n\n\nAn important feature of a vector, is that all of the elements are the same type of data. The function class() indicates the class (the type of element) of an object:\n\nclass(weight_g)\n\n[1] \"numeric\"\n\n\n\nclass(molecules)\n\n[1] \"character\"\n\n\nThe function str() provides an overview of the structure of an object and its elements. It is a useful function when working with large and complex objects:\n\nstr(weight_g)\n\n num [1:4] 50 60 65 82\n\n\n\nstr(molecules)\n\n chr [1:3] \"dna\" \"rna\" \"protein\"\n\n\nYou can use the c() function to add other elements to your vector:\n\nweight_g &lt;- c(weight_g, 90) # add to the end of the vector\nweight_g &lt;- c(30, weight_g) # add to the beginning of the vector\nweight_g\n\n[1] 30 50 60 65 82 90\n\n\nIn the first line, we take the original vector weight_g, add the value 90 to the end of it, and save the result back into weight_g. Then we add the value 30 to the beginning, again saving the result back into weight_g.\nWe can do this over and over again to grow a vector, or assemble a dataset. As we program, this may be useful to add results that we are collecting or calculating.\nAn atomic vector is the simplest R data type and is a linear vector of a single type. Above, we saw 2 of the 6 main atomic vector types that R uses: \"character\" and \"numeric\" (or \"double\"). These are the basic building blocks that all R objects are built from. The other 4 atomic vector types are:\n\n\"logical\" for TRUE and FALSE (the boolean data type)\n\"integer\" for integer numbers (e.g., 2L, the L indicates to R that it’s an integer)\n\"complex\" to represent complex numbers with real and imaginary parts (e.g., 1 + 4i) and that’s all we’re going to say about them\n\"raw\" for bitstreams that we won’t discuss further\n\nYou can check the type of your vector using the typeof() function and inputting your vector as the argument.\nVectors are one of the many data structures that R uses. Other important ones are lists (list), matrices (matrix), data frames (data.frame), factors (factor) and arrays (array).\n\n\n\n\n\n\nChallenge\n\n\n\nWe’ve seen that atomic vectors can be of type character, numeric (or double), integer, and logical. But what happens if we try to mix these types in a single vector?\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWhat will happen in each of these examples? (hint: use class() to check the data type of your objects and type in their names to see what happens):\n\nnum_char &lt;- c(1, 2, 3, \"a\")\nnum_logical &lt;- c(1, 2, 3, TRUE, FALSE)\nchar_logical &lt;- c(\"a\", \"b\", \"c\", TRUE)\ntricky &lt;- c(1, 2, 3, \"4\")\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWhy do you think it happens?\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nHow many values in combined_logical are \"TRUE\" (as a character) in the following example:\n\nnum_logical &lt;- c(1, 2, 3, TRUE)\nchar_logical &lt;- c(\"a\", \"b\", \"c\", TRUE)\ncombined_logical &lt;- c(num_logical, char_logical)\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nIn R, we call converting objects from one class into another class coercion. These conversions happen according to a hierarchy, whereby some types get preferentially coerced into other types. Can you draw a diagram that represents the hierarchy of how these data types are coerced?"
  },
  {
    "objectID": "bioc_intro_Introduction2R.html#subsetting-vectors",
    "href": "bioc_intro_Introduction2R.html#subsetting-vectors",
    "title": "Introduction to R",
    "section": "Subsetting vectors",
    "text": "Subsetting vectors\nIf we want to extract one or several values from a vector, we must provide one or several indices in square brackets. For instance:\n\nmolecules &lt;- c(\"dna\", \"rna\", \"peptide\", \"protein\")\nmolecules[2]\n\n[1] \"rna\"\n\n\n\nmolecules[c(3, 2)]\n\n[1] \"peptide\" \"rna\"    \n\n\nWe can also repeat the indices to create an object with more elements than the original one:\n\nmore_molecules &lt;- molecules[c(1, 2, 3, 2, 1, 4)]\nmore_molecules\n\n[1] \"dna\"     \"rna\"     \"peptide\" \"rna\"     \"dna\"     \"protein\"\n\n\nR indices start at 1. Programming languages like Fortran, MATLAB, Julia, and R start counting at 1, because that’s what human beings typically do. Languages in the C family (including C++, Java, Perl, and Python) count from 0 because that’s simpler for computers to do.\nFinally, it is also possible to get all the elements of a vector except some specified elements using negative indices:\n\nmolecules ## all molecules\n\n[1] \"dna\"     \"rna\"     \"peptide\" \"protein\"\n\n\n\nmolecules[-1] ## all but the first one\n\n[1] \"rna\"     \"peptide\" \"protein\"\n\n\n\nmolecules[-c(1, 3)] ## all but 1st/3rd ones\n\n[1] \"rna\"     \"protein\"\n\n\n\nmolecules[c(-1, -3)] ## all but 1st/3rd ones\n\n[1] \"rna\"     \"protein\""
  },
  {
    "objectID": "bioc_intro_Introduction2R.html#conditional-subsetting",
    "href": "bioc_intro_Introduction2R.html#conditional-subsetting",
    "title": "Introduction to R",
    "section": "Conditional subsetting",
    "text": "Conditional subsetting\nAnother common way of subsetting is by using a logical vector. TRUE will select the element with the same index, while FALSE will not:\n\nweight_g &lt;- c(21, 34, 39, 54, 55)\nweight_g[c(TRUE, FALSE, TRUE, TRUE, FALSE)]\n\n[1] 21 39 54\n\n\nTypically, these logical vectors are not typed by hand, but are the output of other functions or logical tests. For instance, if you wanted to select only the values above 50:\n\n## will return logicals with TRUE for the indices that meet\n## the condition\nweight_g &gt; 50\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\n\n\n## so we can use this to select only the values above 50\nweight_g[weight_g &gt; 50]\n\n[1] 54 55\n\n\nYou can combine multiple tests using & (both conditions are true, AND) or | (at least one of the conditions is true, OR):\n\nweight_g[weight_g &lt; 30 | weight_g &gt; 50]\n\n[1] 21 54 55\n\n\n\nweight_g[weight_g &gt;= 30 & weight_g == 21]\n\nnumeric(0)\n\n\nHere, &lt; stands for “less than”, &gt; for “greater than”, &gt;= for “greater than or equal to”, and == for “equal to”. The double equal sign == is a test for numerical equality between the left and right hand sides, and should not be confused with the single = sign, which performs variable assignment (similar to &lt;-).\nA common task is to search for certain strings in a vector. One could use the “or” operator | to test for equality to multiple values, but this can quickly become tedious. The function %in% allows you to test if any of the elements of a search vector are found:\n\nmolecules &lt;- c(\"dna\", \"rna\", \"protein\", \"peptide\")\nmolecules[molecules == \"rna\" | molecules == \"dna\"] # returns both rna and dna\n\n[1] \"dna\" \"rna\"\n\n\n\nmolecules %in% c(\"rna\", \"dna\", \"metabolite\", \"peptide\", \"glycerol\")\n\n[1]  TRUE  TRUE FALSE  TRUE\n\n\n\nmolecules[molecules %in% c(\"rna\", \"dna\", \"metabolite\", \"peptide\", \"glycerol\")]\n\n[1] \"dna\"     \"rna\"     \"peptide\"\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nCan you figure out why \"four\" &gt; \"five\" returns TRUE?"
  },
  {
    "objectID": "bioc_intro_Introduction2R.html#names",
    "href": "bioc_intro_Introduction2R.html#names",
    "title": "Introduction to R",
    "section": "Names",
    "text": "Names\nIt is possible to name each element of a vector. The code chunk below shows an initial vector without any names, how names are set, and retrieved.\n\nx &lt;- c(1, 5, 3, 5, 10)\nnames(x) ## no names\n\nNULL\n\n\n\nnames(x) &lt;- c(\"A\", \"B\", \"C\", \"D\", \"E\")\nnames(x) ## now we have names\n\n[1] \"A\" \"B\" \"C\" \"D\" \"E\"\n\n\nWhen a vector has names, it is possible to access elements by their name, in addition to their index.\n\nx[c(1, 3)]\n\nA C \n1 3 \n\n\n\nx[c(\"A\", \"C\")]\n\nA C \n1 3"
  },
  {
    "objectID": "bioc_intro_Introduction2R.html#missing-data",
    "href": "bioc_intro_Introduction2R.html#missing-data",
    "title": "Introduction to R",
    "section": "Missing data",
    "text": "Missing data\nAs R was designed to analyze datasets, it includes the concept of missing data (which is uncommon in other programming languages). Missing data are represented in vectors as NA.\nWhen doing operations on numbers, most functions will return NA if the data you are working with include missing values. This feature makes it harder to overlook the cases where you are dealing with missing data. You can add the argument na.rm = TRUE to calculate the result while ignoring the missing values.\n\nheights &lt;- c(2, 4, 4, NA, 6)\nmean(heights)\n\n[1] NA\n\n\n\nmax(heights)\n\n[1] NA\n\n\n\nmean(heights, na.rm = TRUE)\n\n[1] 4\n\n\n\nmax(heights, na.rm = TRUE)\n\n[1] 6\n\n\nIf your data include missing values, you may want to become familiar with the functions is.na(), na.omit(), and complete.cases(). See below for examples.\n\n## Extract those elements which are not missing values.\nheights[!is.na(heights)]\n\n[1] 2 4 4 6\n\n\n\n## Returns the object with incomplete cases removed.\n## The returned object is an atomic vector of type `\"numeric\"`\n## (or `\"double\"`).\nna.omit(heights)\n\n[1] 2 4 4 6\nattr(,\"na.action\")\n[1] 4\nattr(,\"class\")\n[1] \"omit\"\n\n\n\n## Extract those elements which are complete cases.\n## The returned object is an atomic vector of type `\"numeric\"`\n## (or `\"double\"`).\nheights[complete.cases(heights)]\n\n[1] 2 4 4 6\n\n\n\n\n\n\n\n\nChallenge\n\n\n\n\nUsing this vector of heights in inches, create a new vector with the NAs removed.\n\nheights &lt;- c(63, 69, 60, 65, NA, 68, 61, 70, 61, 59, 64, 69, 63, 63, NA, 72, 65, 64, 70, 63, 65)                                      \n\n\n\n\nUse the function median() to calculate the median of the heights vector.\nUse R to figure out how many people in the set are taller than 67 inches."
  },
  {
    "objectID": "bioc_intro_Introduction2R.html#generating-vectors",
    "href": "bioc_intro_Introduction2R.html#generating-vectors",
    "title": "Introduction to R",
    "section": "Generating vectors",
    "text": "Generating vectors\n\nConstructors\nThere exists some functions to generate vectors of different type. To generate a vector of numerics, one can use the numeric() constructor, providing the length of the output vector as parameter. The values will be initialised with 0.\n\nnumeric(3)\n\n[1] 0 0 0\n\n\n\nnumeric(10)\n\n [1] 0 0 0 0 0 0 0 0 0 0\n\n\nNote that if we ask for a vector of numerics of length 0, we obtain exactly that:\n\nnumeric(0)\n\nnumeric(0)\n\n\nThere are similar constructors for characters and logicals, named character() and logical() respectively.\n\n\n\n\n\n\nChallenge\n\n\n\nWhat are the defaults for character and logical vectors?\n\n\n\n\nReplicate elements\nThe rep function allow to repeat a value a certain number of times. If we want to initiate a vector of numerics of length 5 with the value -1, for example, we could do the following:\n\nrep(-1, 5)\n\n[1] -1 -1 -1 -1 -1\n\n\nSimilarly, to generate a vector populated with missing values, which is often a good way to start, without setting assumptions on the data to be collected:\n\nrep(NA, 5)\n\n[1] NA NA NA NA NA\n\n\nrep can take vectors of any length as input (above, we used vectors of length 1) and any type. For example, if we want to repeat the values 1, 2 and 3 five times, we would do the following:\n\nrep(c(1, 2, 3), 5)\n\n [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWhat if we wanted to repeat the values 1, 2 and 3 five times, but obtain five 1s, five 2s and five 3s in that order? There are two possibilities - see ?rep or ?sort for help.\n\n\n\n\nSequence generation\nAnother very useful function is seq, to generate a sequence of numbers. For example, to generate a sequence of integers from 1 to 20 by steps of 2, one would use:\n\nseq(from = 1, to = 20, by = 2)\n\n [1]  1  3  5  7  9 11 13 15 17 19\n\n\nThe default value of by is 1 and, given that the generation of a sequence of one value to another with steps of 1 is frequently used, there’s a shortcut:\n\nseq(1, 5, 1)\n\n[1] 1 2 3 4 5\n\n\n\nseq(1, 5) ## default by\n\n[1] 1 2 3 4 5\n\n\n\n1:5\n\n[1] 1 2 3 4 5\n\n\nTo generate a sequence of numbers from 1 to 20 of final length of 3, one would use:\n\nseq(from = 1, to = 20, length.out = 3)\n\n[1]  1.0 10.5 20.0\n\n\n\n\nRandom samples and permutations\nA last group of useful functions are those that generate random data. The first one, sample, generates a random permutation of another vector. For example, to draw a random order to 10 students oral exam, I first assign each student a number from 1 to ten (for instance based on the alphabetic order of their name) and then:\n\nsample(1:10)\n\n [1] 10  1  8  4  3  2  7  6  5  9\n\n\nWithout further arguments, sample will return a permutation of all elements of the vector. If I want a random sample of a certain size, I would set this value as the second argument. Below, I sample 5 random letters from the alphabet contained in the pre-defined letters vector:\n\nsample(letters, 5)\n\n[1] \"c\" \"d\" \"l\" \"s\" \"q\"\n\n\nIf I wanted an output larger than the input vector, or being able to draw some elements multiple times, I would need to set the replace argument to TRUE:\n\nsample(1:5, 10, replace = TRUE)\n\n [1] 4 5 3 5 3 1 2 3 3 1\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWhen trying the functions above out, you will have realised that the samples are indeed random and that one doesn’t get the same permutation twice. To be able to reproduce these random draws, one can set the random number generation seed manually with set.seed() before drawing the random sample.\nTest this feature with your neighbour. First draw two random permutations of 1:10 independently and observe that you get different results.\nNow set the seed with, for example, set.seed(123) and repeat the random draw. Observe that you now get the same random draws.\nRepeat by setting a different seed.\n\n\n\n\nDrawing samples from a normal distribution\nThe last function we are going to see is rnorm, that draws a random sample from a normal distribution. Two normal distributions of means 0 and 100 and standard deviations 1 and 5, noted N(0, 1) and N(100, 5), are shown below.\n\nThe three arguments, n, mean and sd, define the size of the sample, and the parameters of the normal distribution, i.e the mean and its standard deviation. The defaults of the latter are 0 and 1.\n\nrnorm(5)\n\n[1]  0.8213603 -0.6062007  0.3245431  1.2528095 -1.5175367\n\n\n\nrnorm(5, 2, 2)\n\n[1]  1.6323466 -0.5942983  7.8557881  3.2930085  3.7174651\n\n\n\nrnorm(5, 100, 5)\n\n[1] 100.46033  85.58865  90.00833  95.63062  93.89640\n\n\nNow that we have learned how to write scripts, and the basics of R’s data structures, we are ready to start working with larger data, and learn about data frames."
  },
  {
    "objectID": "bioc_intro_Introduction2R_solutions.html",
    "href": "bioc_intro_Introduction2R_solutions.html",
    "title": "Introduction to R",
    "section": "",
    "text": "Objectives\n\nDefine the following terms as they relate to R: object, assign, call, function, arguments, options.\nAssign values to objects in R.\nLearn how to name objects\nUse comments to inform script.\nSolve simple arithmetic operations in R.\nCall functions and use arguments to change their default options.\nInspect the content of vectors and manipulate their content.\nSubset and extract values from vectors.\nAnalyze vectors with missing data."
  },
  {
    "objectID": "bioc_intro_Introduction2R_solutions.html#creating-objects-in-r",
    "href": "bioc_intro_Introduction2R_solutions.html#creating-objects-in-r",
    "title": "Introduction to R",
    "section": "Creating objects in R",
    "text": "Creating objects in R\nYou can get output from R simply by typing math in the console:\n\n3 + 5\n\n[1] 8\n\n\n\n12 / 7\n\n[1] 1.714286\n\n\nHowever, to do useful and interesting things, we need to assign values to objects. To create an object, we need to give it a name followed by the assignment operator &lt;-, and the value we want to give it:\n\nweight_kg &lt;- 55\n\n&lt;- is the assignment operator. It assigns values on the right to objects on the left. So, after executing x &lt;- 3, the value of x is 3. The arrow can be read as 3 goes into x. For historical reasons, you can also use = for assignments, but not in every context. Because of the slight differences in syntax, it is good practice to always use &lt;- for assignments.\nIn RStudio, typing Alt + - (push Alt at the same time as the - key) will write &lt;- in a single keystroke in a PC, while typing Option + - (push Option at the same time as the - key) does the same in a Mac."
  },
  {
    "objectID": "bioc_intro_Introduction2R_solutions.html#naming-variables",
    "href": "bioc_intro_Introduction2R_solutions.html#naming-variables",
    "title": "Introduction to R",
    "section": "Naming variables",
    "text": "Naming variables\nObjects can be given any name such as x, current_temperature, or subject_id. You want your object names to be explicit and not too long. They cannot start with a number (2x is not valid, but x2 is). R is case sensitive (e.g., weight_kg is different from Weight_kg). There are some names that cannot be used because they are the names of fundamental functions in R (e.g., if, else, for, see here for a complete list). In general, even if it’s allowed, it’s best to not use other function names (e.g., c, T, mean, data, df, weights). If in doubt, check the help to see if the name is already in use. It’s also best to avoid dots (.) within an object name as in my.dataset. There are many functions in R with dots in their names for historical reasons, but because dots have a special meaning in R (for methods) and other programming languages, it’s best to avoid them. It is also recommended to use nouns for object names, and verbs for function names. It’s important to be consistent in the styling of your code (where you put spaces, how you name objects, etc.). Using a consistent coding style makes your code clearer to read for your future self and your collaborators. In R, some popular style guides are Google’s, the tidyverse’s style and the Bioconductor style guide. The tidyverse’s is very comprehensive and may seem overwhelming at first. You can install the lintr package to automatically check for issues in the styling of your code.\n\n\n\n\n\n\nImportant\n\n\n\nObjects vs. variables: What are known as objects in R are known as variables in many other programming languages. Depending on the context, object and variable can have drastically different meanings. However, in this lesson, the two words are used synonymously. For more information see here.\n\n\nWhen assigning a value to an object, R does not print anything. You can force R to print the value by using parentheses or by typing the object name:\n\nweight_kg &lt;- 55    # doesn't print anything\n(weight_kg &lt;- 55)  # but putting parenthesis around the call prints the value of `weight_kg`\n\n[1] 55\n\n\n\nweight_kg          # and so does typing the name of the object\n\n[1] 55\n\n\nNow that R has weight_kg in memory, we can do arithmetic with it. For instance, we may want to convert this weight into pounds (weight in pounds is 2.2 times the weight in kg):\n\n2.2 * weight_kg\n\n[1] 121\n\n\nWe can also change an object’s value by assigning it a new one:\n\nweight_kg &lt;- 57.5\n2.2 * weight_kg\n\n[1] 126.5\n\n\nThis means that assigning a value to one object does not change the values of other objects For example, let’s store the animal’s weight in pounds in a new object, weight_lb:\n\nweight_lb &lt;- 2.2 * weight_kg\n\nand then change weight_kg to 100.\n\nweight_kg &lt;- 100\n\n\n\n\n\n\n\nChallenge\n\n\n\nWhat do you think is the current content of the object weight_lb? 126.5 or 220?"
  },
  {
    "objectID": "bioc_intro_Introduction2R_solutions.html#comments",
    "href": "bioc_intro_Introduction2R_solutions.html#comments",
    "title": "Introduction to R",
    "section": "Comments",
    "text": "Comments\nThe comment character in R is #, anything to the right of a # in a script will be ignored by R. It is useful to leave notes, and explanations in your scripts.\nRStudio makes it easy to comment or uncomment a paragraph: after selecting the lines you want to comment, press at the same time on your keyboard Ctrl + Shift + C. If you only want to comment out one line, you can put the cursor at any location of that line (i.e. no need to select the whole line), then press Ctrl + Shift + C.\n\n\n\n\n\n\nChallenge\n\n\n\nWhat are the values after each statement in the following?\n\nmass &lt;- 47.5            # mass?\nage  &lt;- 122             # age?\nmass &lt;- mass * 2.0      # mass?\nage  &lt;- age - 20        # age?\nmass_index &lt;- mass/age  # mass_index?"
  },
  {
    "objectID": "bioc_intro_Introduction2R_solutions.html#functions-and-their-arguments",
    "href": "bioc_intro_Introduction2R_solutions.html#functions-and-their-arguments",
    "title": "Introduction to R",
    "section": "Functions and their arguments",
    "text": "Functions and their arguments\nFunctions are “canned scripts” that automate more complicated sets of commands including operations assignments, etc. Many functions are predefined, or can be made available by importing R packages (more on that later). A function usually gets one or more inputs called arguments. Functions often (but not always) return a value. A typical example would be the function sqrt(). The input (the argument) must be a number, and the return value (in fact, the output) is the square root of that number. Executing a function (‘running it’) is called calling the function. An example of a function call is:\n\nb &lt;- sqrt(a)\n\nHere, the value of a is given to the sqrt() function, the sqrt() function calculates the square root, and returns the value which is then assigned to the object b. This function is very simple, because it takes just one argument.\nThe return ‘value’ of a function need not be numerical (like that of sqrt()), and it also does not need to be a single item: it can be a set of things, or even a dataset. We’ll see that when we read data files into R.\nArguments can be anything, not only numbers or filenames, but also other objects. Exactly what each argument means differs per function, and must be looked up in the documentation (see below). Some functions take arguments which may either be specified by the user, or, if left out, take on a default value: these are called options. Options are typically used to alter the way the function operates, such as whether it ignores ‘bad values’, or what symbol to use in a plot. However, if you want something specific, you can specify a value of your choice which will be used instead of the default.\nLet’s try a function that can take multiple arguments: round().\n\nround(3.14159)\n\n[1] 3\n\n\nHere, we’ve called round() with just one argument, 3.14159, and it has returned the value 3. That’s because the default is to round to the nearest whole number. If we want more digits we can see how to do that by getting information about the round function. We can use args(round) or look at the help for this function using ?round.\n\nargs(round)\n\nfunction (x, digits = 0) \nNULL\n\n\n\n?round\n\nWe see that if we want a different number of digits, we can type digits=2 or however many we want.\n\nround(3.14159, digits = 2)\n\n[1] 3.14\n\n\nIf you provide the arguments in the exact same order as they are defined you don’t have to name them:\n\nround(3.14159, 2)\n\n[1] 3.14\n\n\nAnd if you do name the arguments, you can switch their order:\n\nround(digits = 2, x = 3.14159)\n\n[1] 3.14\n\n\nIt’s good practice to put the non-optional arguments (like the number you’re rounding) first in your function call, and to specify the names of all optional arguments. If you don’t, someone reading your code might have to look up the definition of a function with unfamiliar arguments to understand what you’re doing. By specifying the name of the arguments you are also safeguarding against possible future changes in the function interface, which may potentially add new arguments in between the existing ones."
  },
  {
    "objectID": "bioc_intro_Introduction2R_solutions.html#vectors-and-data-types",
    "href": "bioc_intro_Introduction2R_solutions.html#vectors-and-data-types",
    "title": "Introduction to R",
    "section": "Vectors and data types",
    "text": "Vectors and data types\nA vector is the most common and basic data type in R, and is pretty much the workhorse of R. A vector is composed by a series of values, such as numbers or characters. We can assign a series of values to a vector using the c() function. For example we can create a vector of animal weights and assign it to a new object weight_g:\n\nweight_g &lt;- c(50, 60, 65, 82)\nweight_g\n\n[1] 50 60 65 82\n\n\nA vector can also contain characters:\n\nmolecules &lt;- c(\"dna\", \"rna\", \"protein\")\nmolecules\n\n[1] \"dna\"     \"rna\"     \"protein\"\n\n\nThe quotes around “dna”, “rna”, etc. are essential here. Without the quotes R will assume there are objects called dna, rna and protein. As these objects don’t exist in R’s memory, there will be an error message.\nThere are many functions that allow you to inspect the content of a vector. length() tells you how many elements are in a particular vector:\n\nlength(weight_g)\n\n[1] 4\n\n\n\nlength(molecules)\n\n[1] 3\n\n\nAn important feature of a vector, is that all of the elements are the same type of data. The function class() indicates the class (the type of element) of an object:\n\nclass(weight_g)\n\n[1] \"numeric\"\n\n\n\nclass(molecules)\n\n[1] \"character\"\n\n\nThe function str() provides an overview of the structure of an object and its elements. It is a useful function when working with large and complex objects:\n\nstr(weight_g)\n\n num [1:4] 50 60 65 82\n\n\n\nstr(molecules)\n\n chr [1:3] \"dna\" \"rna\" \"protein\"\n\n\nYou can use the c() function to add other elements to your vector:\n\nweight_g &lt;- c(weight_g, 90) # add to the end of the vector\nweight_g &lt;- c(30, weight_g) # add to the beginning of the vector\nweight_g\n\n[1] 30 50 60 65 82 90\n\n\nIn the first line, we take the original vector weight_g, add the value 90 to the end of it, and save the result back into weight_g. Then we add the value 30 to the beginning, again saving the result back into weight_g.\nWe can do this over and over again to grow a vector, or assemble a dataset. As we program, this may be useful to add results that we are collecting or calculating.\nAn atomic vector is the simplest R data type and is a linear vector of a single type. Above, we saw 2 of the 6 main atomic vector types that R uses: \"character\" and \"numeric\" (or \"double\"). These are the basic building blocks that all R objects are built from. The other 4 atomic vector types are:\n\n\"logical\" for TRUE and FALSE (the boolean data type)\n\"integer\" for integer numbers (e.g., 2L, the L indicates to R that it’s an integer)\n\"complex\" to represent complex numbers with real and imaginary parts (e.g., 1 + 4i) and that’s all we’re going to say about them\n\"raw\" for bitstreams that we won’t discuss further\n\nYou can check the type of your vector using the typeof() function and inputting your vector as the argument.\nVectors are one of the many data structures that R uses. Other important ones are lists (list), matrices (matrix), data frames (data.frame), factors (factor) and arrays (array).\n\n\n\n\n\n\nChallenge\n\n\n\nWe’ve seen that atomic vectors can be of type character, numeric (or double), integer, and logical. But what happens if we try to mix these types in a single vector?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nR implicitly converts them to all be the same type\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWhat will happen in each of these examples? (hint: use class() to check the data type of your objects and type in their names to see what happens):\n\nnum_char &lt;- c(1, 2, 3, \"a\")\nnum_logical &lt;- c(1, 2, 3, TRUE, FALSE)\nchar_logical &lt;- c(\"a\", \"b\", \"c\", TRUE)\ntricky &lt;- c(1, 2, 3, \"4\")\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nclass(num_char)\n\n[1] \"character\"\n\n\n\nnum_char\n\n[1] \"1\" \"2\" \"3\" \"a\"\n\n\n\nclass(num_logical)\n\n[1] \"numeric\"\n\n\n\nnum_logical\n\n[1] 1 2 3 1 0\n\n\n\nclass(char_logical)\n\n[1] \"character\"\n\n\n\nchar_logical\n\n[1] \"a\"    \"b\"    \"c\"    \"TRUE\"\n\n\n\nclass(tricky)\n\n[1] \"character\"\n\n\n\ntricky\n\n[1] \"1\" \"2\" \"3\" \"4\"\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWhy do you think it happens?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nVectors can be of only one data type. R tries to convert (coerce) the content of this vector to find a common denominator that doesn’t lose any information.\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nHow many values in combined_logical are \"TRUE\" (as a character) in the following example:\n\nnum_logical &lt;- c(1, 2, 3, TRUE)\nchar_logical &lt;- c(\"a\", \"b\", \"c\", TRUE)\ncombined_logical &lt;- c(num_logical, char_logical)\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nOnly one. There is no memory of past data types, and the coercion happens the first time the vector is evaluated. Therefore, the TRUE in num_logical gets converted into a 1 before it gets converted into \"1\" in combined_logical.\n\ncombined_logical\n\n[1] \"1\"    \"2\"    \"3\"    \"1\"    \"a\"    \"b\"    \"c\"    \"TRUE\"\n\n\n\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nIn R, we call converting objects from one class into another class coercion. These conversions happen according to a hierarchy, whereby some types get preferentially coerced into other types. Can you draw a diagram that represents the hierarchy of how these data types are coerced?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nlogical → numeric → character ← logical"
  },
  {
    "objectID": "bioc_intro_Introduction2R_solutions.html#subsetting-vectors",
    "href": "bioc_intro_Introduction2R_solutions.html#subsetting-vectors",
    "title": "Introduction to R",
    "section": "Subsetting vectors",
    "text": "Subsetting vectors\nIf we want to extract one or several values from a vector, we must provide one or several indices in square brackets. For instance:\n\nmolecules &lt;- c(\"dna\", \"rna\", \"peptide\", \"protein\")\nmolecules[2]\n\n[1] \"rna\"\n\n\n\nmolecules[c(3, 2)]\n\n[1] \"peptide\" \"rna\"    \n\n\nWe can also repeat the indices to create an object with more elements than the original one:\n\nmore_molecules &lt;- molecules[c(1, 2, 3, 2, 1, 4)]\nmore_molecules\n\n[1] \"dna\"     \"rna\"     \"peptide\" \"rna\"     \"dna\"     \"protein\"\n\n\nR indices start at 1. Programming languages like Fortran, MATLAB, Julia, and R start counting at 1, because that’s what human beings typically do. Languages in the C family (including C++, Java, Perl, and Python) count from 0 because that’s simpler for computers to do.\nFinally, it is also possible to get all the elements of a vector except some specified elements using negative indices:\n\nmolecules ## all molecules\n\n[1] \"dna\"     \"rna\"     \"peptide\" \"protein\"\n\n\n\nmolecules[-1] ## all but the first one\n\n[1] \"rna\"     \"peptide\" \"protein\"\n\n\n\nmolecules[-c(1, 3)] ## all but 1st/3rd ones\n\n[1] \"rna\"     \"protein\"\n\n\n\nmolecules[c(-1, -3)] ## all but 1st/3rd ones\n\n[1] \"rna\"     \"protein\""
  },
  {
    "objectID": "bioc_intro_Introduction2R_solutions.html#conditional-subsetting",
    "href": "bioc_intro_Introduction2R_solutions.html#conditional-subsetting",
    "title": "Introduction to R",
    "section": "Conditional subsetting",
    "text": "Conditional subsetting\nAnother common way of subsetting is by using a logical vector. TRUE will select the element with the same index, while FALSE will not:\n\nweight_g &lt;- c(21, 34, 39, 54, 55)\nweight_g[c(TRUE, FALSE, TRUE, TRUE, FALSE)]\n\n[1] 21 39 54\n\n\nTypically, these logical vectors are not typed by hand, but are the output of other functions or logical tests. For instance, if you wanted to select only the values above 50:\n\n## will return logicals with TRUE for the indices that meet\n## the condition\nweight_g &gt; 50\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\n\n\n## so we can use this to select only the values above 50\nweight_g[weight_g &gt; 50]\n\n[1] 54 55\n\n\nYou can combine multiple tests using & (both conditions are true, AND) or | (at least one of the conditions is true, OR):\n\nweight_g[weight_g &lt; 30 | weight_g &gt; 50]\n\n[1] 21 54 55\n\n\n\nweight_g[weight_g &gt;= 30 & weight_g == 21]\n\nnumeric(0)\n\n\nHere, &lt; stands for “less than”, &gt; for “greater than”, &gt;= for “greater than or equal to”, and == for “equal to”. The double equal sign == is a test for numerical equality between the left and right hand sides, and should not be confused with the single = sign, which performs variable assignment (similar to &lt;-).\nA common task is to search for certain strings in a vector. One could use the “or” operator | to test for equality to multiple values, but this can quickly become tedious. The function %in% allows you to test if any of the elements of a search vector are found:\n\nmolecules &lt;- c(\"dna\", \"rna\", \"protein\", \"peptide\")\nmolecules[molecules == \"rna\" | molecules == \"dna\"] # returns both rna and dna\n\n[1] \"dna\" \"rna\"\n\n\n\nmolecules %in% c(\"rna\", \"dna\", \"metabolite\", \"peptide\", \"glycerol\")\n\n[1]  TRUE  TRUE FALSE  TRUE\n\n\n\nmolecules[molecules %in% c(\"rna\", \"dna\", \"metabolite\", \"peptide\", \"glycerol\")]\n\n[1] \"dna\"     \"rna\"     \"peptide\"\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nCan you figure out why \"four\" &gt; \"five\" returns TRUE?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n\"four\" &gt; \"five\"\n\n[1] TRUE\n\n\nWhen using &gt; or &lt; on strings, R compares their alphabetical order. Here \"four\" comes after \"five\", and therefore is greater than it."
  },
  {
    "objectID": "bioc_intro_Introduction2R_solutions.html#names",
    "href": "bioc_intro_Introduction2R_solutions.html#names",
    "title": "Introduction to R",
    "section": "Names",
    "text": "Names\nIt is possible to name each element of a vector. The code chunk below shows an initial vector without any names, how names are set, and retrieved.\n\nx &lt;- c(1, 5, 3, 5, 10)\nnames(x) ## no names\n\nNULL\n\n\n\nnames(x) &lt;- c(\"A\", \"B\", \"C\", \"D\", \"E\")\nnames(x) ## now we have names\n\n[1] \"A\" \"B\" \"C\" \"D\" \"E\"\n\n\nWhen a vector has names, it is possible to access elements by their name, in addition to their index.\n\nx[c(1, 3)]\n\nA C \n1 3 \n\n\n\nx[c(\"A\", \"C\")]\n\nA C \n1 3"
  },
  {
    "objectID": "bioc_intro_Introduction2R_solutions.html#missing-data",
    "href": "bioc_intro_Introduction2R_solutions.html#missing-data",
    "title": "Introduction to R",
    "section": "Missing data",
    "text": "Missing data\nAs R was designed to analyze datasets, it includes the concept of missing data (which is uncommon in other programming languages). Missing data are represented in vectors as NA.\nWhen doing operations on numbers, most functions will return NA if the data you are working with include missing values. This feature makes it harder to overlook the cases where you are dealing with missing data. You can add the argument na.rm = TRUE to calculate the result while ignoring the missing values.\n\nheights &lt;- c(2, 4, 4, NA, 6)\nmean(heights)\n\n[1] NA\n\n\n\nmax(heights)\n\n[1] NA\n\n\n\nmean(heights, na.rm = TRUE)\n\n[1] 4\n\n\n\nmax(heights, na.rm = TRUE)\n\n[1] 6\n\n\nIf your data include missing values, you may want to become familiar with the functions is.na(), na.omit(), and complete.cases(). See below for examples.\n\n## Extract those elements which are not missing values.\nheights[!is.na(heights)]\n\n[1] 2 4 4 6\n\n\n\n## Returns the object with incomplete cases removed.\n## The returned object is an atomic vector of type `\"numeric\"`\n## (or `\"double\"`).\nna.omit(heights)\n\n[1] 2 4 4 6\nattr(,\"na.action\")\n[1] 4\nattr(,\"class\")\n[1] \"omit\"\n\n\n\n## Extract those elements which are complete cases.\n## The returned object is an atomic vector of type `\"numeric\"`\n## (or `\"double\"`).\nheights[complete.cases(heights)]\n\n[1] 2 4 4 6\n\n\n\n\n\n\n\n\nChallenge\n\n\n\n\nUsing this vector of heights in inches, create a new vector with the NAs removed.\n\nheights &lt;- c(63, 69, 60, 65, NA, 68, 61, 70, 61, 59, 64, 69, 63, 63, NA, 72, 65, 64, 70, 63, 65)                                      \n\nUse the function median() to calculate the median of the heights vector.\nUse R to figure out how many people in the set are taller than 67 inches.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nheights_no_na &lt;- heights[!is.na(heights)]\n## or\nheights_no_na &lt;- na.omit(heights)\n\n\nmedian(heights, na.rm = TRUE)\n\n[1] 64\n\n\n\nheights_above_67 &lt;- heights_no_na[heights_no_na &gt; 67]\nlength(heights_above_67)\n\n[1] 6"
  },
  {
    "objectID": "bioc_intro_Introduction2R_solutions.html#generating-vectors",
    "href": "bioc_intro_Introduction2R_solutions.html#generating-vectors",
    "title": "Introduction to R",
    "section": "Generating vectors",
    "text": "Generating vectors\n\nConstructors\nThere exists some functions to generate vectors of different type. To generate a vector of numerics, one can use the numeric() constructor, providing the length of the output vector as parameter. The values will be initialised with 0.\n\nnumeric(3)\n\n[1] 0 0 0\n\n\n\nnumeric(10)\n\n [1] 0 0 0 0 0 0 0 0 0 0\n\n\nNote that if we ask for a vector of numerics of length 0, we obtain exactly that:\n\nnumeric(0)\n\nnumeric(0)\n\n\nThere are similar constructors for characters and logicals, named character() and logical() respectively.\n\n\n\n\n\n\nChallenge\n\n\n\nWhat are the defaults for character and logical vectors?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ncharacter(2) ## the empty character\n\n[1] \"\" \"\"\n\n\n\nlogical(2)   ## FALSE\n\n[1] FALSE FALSE\n\n\n\n\n\n\n\nReplicate elements\nThe rep function allow to repeat a value a certain number of times. If we want to initiate a vector of numerics of length 5 with the value -1, for example, we could do the following:\n\nrep(-1, 5)\n\n[1] -1 -1 -1 -1 -1\n\n\nSimilarly, to generate a vector populated with missing values, which is often a good way to start, without setting assumptions on the data to be collected:\n\nrep(NA, 5)\n\n[1] NA NA NA NA NA\n\n\nrep can take vectors of any length as input (above, we used vectors of length 1) and any type. For example, if we want to repeat the values 1, 2 and 3 five times, we would do the following:\n\nrep(c(1, 2, 3), 5)\n\n [1] 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWhat if we wanted to repeat the values 1, 2 and 3 five times, but obtain five 1s, five 2s and five 3s in that order? There are two possibilities - see ?rep or ?sort for help.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nrep(c(1, 2, 3), each = 5)\n\n [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3\n\n\n\nsort(rep(c(1, 2, 3), 5))\n\n [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3\n\n\n\n\n\n\n\nSequence generation\nAnother very useful function is seq, to generate a sequence of numbers. For example, to generate a sequence of integers from 1 to 20 by steps of 2, one would use:\n\nseq(from = 1, to = 20, by = 2)\n\n [1]  1  3  5  7  9 11 13 15 17 19\n\n\nThe default value of by is 1 and, given that the generation of a sequence of one value to another with steps of 1 is frequently used, there’s a shortcut:\n\nseq(1, 5, 1)\n\n[1] 1 2 3 4 5\n\n\n\nseq(1, 5) ## default by\n\n[1] 1 2 3 4 5\n\n\n\n1:5\n\n[1] 1 2 3 4 5\n\n\nTo generate a sequence of numbers from 1 to 20 of final length of 3, one would use:\n\nseq(from = 1, to = 20, length.out = 3)\n\n[1]  1.0 10.5 20.0\n\n\n\n\nRandom samples and permutations\nA last group of useful functions are those that generate random data. The first one, sample, generates a random permutation of another vector. For example, to draw a random order to 10 students oral exam, I first assign each student a number from 1 to ten (for instance based on the alphabetic order of their name) and then:\n\nsample(1:10)\n\n [1]  3  8  1  6  9 10  7  4  5  2\n\n\nWithout further arguments, sample will return a permutation of all elements of the vector. If I want a random sample of a certain size, I would set this value as the second argument. Below, I sample 5 random letters from the alphabet contained in the pre-defined letters vector:\n\nsample(letters, 5)\n\n[1] \"j\" \"p\" \"u\" \"m\" \"d\"\n\n\nIf I wanted an output larger than the input vector, or being able to draw some elements multiple times, I would need to set the replace argument to TRUE:\n\nsample(1:5, 10, replace = TRUE)\n\n [1] 2 4 2 3 3 1 5 5 2 4\n\n\n\n\n\n\n\n\nChallenge\n\n\n\nWhen trying the functions above out, you will have realised that the samples are indeed random and that one doesn’t get the same permutation twice. To be able to reproduce these random draws, one can set the random number generation seed manually with set.seed() before drawing the random sample.\nTest this feature with your neighbour. First draw two random permutations of 1:10 independently and observe that you get different results.\nNow set the seed with, for example, set.seed(123) and repeat the random draw. Observe that you now get the same random draws.\nRepeat by setting a different seed.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nDifferent permutations\n\nsample(1:10)\n\n [1]  1  9  2  8  4  3 10  5  7  6\n\n\n\nsample(1:10)\n\n [1]  2  9  5  1  7  6  8 10  3  4\n\n\nSame permutations with seed 123\n\nset.seed(123)\nsample(1:10)\n\n [1]  3 10  2  8  6  9  1  7  5  4\n\n\n\nset.seed(123)\nsample(1:10)\n\n [1]  3 10  2  8  6  9  1  7  5  4\n\n\nA different seed\n\nset.seed(1)\nsample(1:10)\n\n [1]  9  4  7  1  2  5  3 10  6  8\n\n\n\nset.seed(1)\nsample(1:10)\n\n [1]  9  4  7  1  2  5  3 10  6  8\n\n\n\n\n\n\n\nDrawing samples from a normal distribution\nThe last function we are going to see is rnorm, that draws a random sample from a normal distribution. Two normal distributions of means 0 and 100 and standard deviations 1 and 5, noted N(0, 1) and N(100, 5), are shown below.\n\nThe three arguments, n, mean and sd, define the size of the sample, and the parameters of the normal distribution, i.e the mean and its standard deviation. The defaults of the latter are 0 and 1.\n\nrnorm(5)\n\n[1] -0.8204684  0.4874291  0.7383247  0.5757814 -0.3053884\n\n\n\nrnorm(5, 2, 2)\n\n[1]  5.0235623  2.7796865  0.7575188 -2.4293998  4.2498618\n\n\n\nrnorm(5, 100, 5)\n\n[1]  99.77533  99.91905 104.71918 104.10611 102.96951\n\n\nNow that we have learned how to write scripts, and the basics of R’s data structures, we are ready to start working with larger data, and learn about data frames."
  }
]